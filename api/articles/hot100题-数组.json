{"title":"hot100题-数组","uid":"3bcc886f37c7e248c2cc5479f2517b11","slug":"hot100题-数组","date":"2025-08-27T06:56:34.000Z","updated":"2025-08-29T07:29:18.936Z","comments":true,"path":"api/articles/hot100题-数组.json","keywords":"AI、Python","cover":null,"content":"<h1 id=\"最大子数组和-53\"><a href=\"#最大子数组和-53\" class=\"headerlink\" title=\"最大子数组和(53)\"></a>最大子数组和(53)</h1><p><a href=\"https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked\">最大子数组和</a></p>\n<blockquote>\n<p>给一个整数数组 nums ，找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n</blockquote>\n<p>开始想到使用滑动窗口来进行解题，发现在求解过程中，窗口大小不固定，没办法确定窗口长度，这里选择动态规划算法，对于每个位置 i，找到 nums[i] 结尾的最大子数组和(动态规划算法还需要强加学习)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">maxSubArray</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">        dp = [<span class=\"number\">0</span>] * n  <span class=\"comment\"># dp[i] 表示以 nums[i] 结尾的最大子数组和</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">        max_sum = dp[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">            <span class=\"comment\"># 状态转移公式</span></span><br><span class=\"line\">            dp[i] = <span class=\"built_in\">max</span>(nums[i], dp[i-<span class=\"number\">1</span>] + nums[i])</span><br><span class=\"line\">            <span class=\"comment\"># 更新全局最大值</span></span><br><span class=\"line\">            max_sum = <span class=\"built_in\">max</span>(max_sum, dp[i])</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max_sum</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"合并区间（56）\"><a href=\"#合并区间（56）\" class=\"headerlink\" title=\"合并区间（56）\"></a>合并区间（56）</h1><p><a href=\"https://leetcode.cn/problems/merge-intervals/?envType=study-plan-v2&envId=top-100-liked\">合并区间</a></p>\n<blockquote>\n<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 </p>\n</blockquote>\n<ul>\n<li>按照左端点进行排序  </li>\n<li>定义返回的列表  </li>\n<li>每次对当前子数组的值和列表中最后一个数组的尾部进行比较  </li>\n<li>如果当前子数组的 start &gt; 列表中最后一个的尾部，则不需要更新  </li>\n<li>如果当前子数组的 start &lt;&#x3D; 列表中最后一个的尾部，则需要更新列表中最后的尾部，取两者之间较大的值</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">merge</span>(<span class=\"params\">self, intervals: <span class=\"type\">List</span>[<span class=\"type\">List</span>[<span class=\"built_in\">int</span>]]</span>) -&gt; <span class=\"type\">List</span>[<span class=\"type\">List</span>[<span class=\"built_in\">int</span>]]:</span><br><span class=\"line\">        intervals.sort(key=<span class=\"keyword\">lambda</span> x:x[<span class=\"number\">0</span>])</span><br><span class=\"line\">        merged = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> interval <span class=\"keyword\">in</span> intervals:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> merged <span class=\"keyword\">or</span> merged[-<span class=\"number\">1</span>][<span class=\"number\">1</span>] &lt; interval[<span class=\"number\">0</span>]:</span><br><span class=\"line\">                <span class=\"comment\">#当前区间的start和最后的end 如果当前区间的start 大于 最后的end</span></span><br><span class=\"line\">                <span class=\"comment\">#已存在最后的[0,1]  当前的[2,3] 没有重叠</span></span><br><span class=\"line\">                merged.append(interval)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"comment\">#最后的[0,2]  当前的[1,2]  或者 最后的[0,2] 当前 [0,4] </span></span><br><span class=\"line\">                merged[-<span class=\"number\">1</span>][<span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(interval[<span class=\"number\">1</span>],merged[-<span class=\"number\">1</span>][<span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merged</span><br><span class=\"line\">        </span><br></pre></td></tr></table></figure>\n\n<h1 id=\"轮转数组（189）\"><a href=\"#轮转数组（189）\" class=\"headerlink\" title=\"轮转数组（189）\"></a>轮转数组（189）</h1><p><a href=\"https://leetcode.cn/problems/rotate-array/?envType=study-plan-v2&envId=top-100-liked\">轮转数组</a></p>\n<blockquote>\n<p>将整数数组向右轮转 k 个位置</p>\n</blockquote>\n<p>① 切片法  </p>\n<ul>\n<li>k 可能大于数组长度，因此对 k 取余  </li>\n<li>使用切片法：截取原数组后 k 个和除去数组后 k 个之前的进行拼接</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">rotate</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>], k: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"comment\">#定义一个循环的数组 然后一直移动就可以</span></span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">        k %= n</span><br><span class=\"line\">        nums[:] = nums[-k:]+nums[:-k]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>② 使用额外的数组  </p>\n<ul>\n<li>在原数组之后再加上一个一样的数组，然后进行截取</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">rotate</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>], k: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        Do not return anything, modify nums in-place instead.</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"comment\">#定义一个循环的数组 然后一直移动就可以</span></span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n==<span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        k %= n</span><br><span class=\"line\">        extend = nums+nums</span><br><span class=\"line\">        rotated = extend[n-k:n-k+n] </span><br><span class=\"line\">        nums[:] = rotated</span><br></pre></td></tr></table></figure>\n\n<p>③ 数组翻转  </p>\n<ul>\n<li>将数组向右移动 k 次，尾部 k mod n 个元素会移动到数组头部，其余元素会向后移动 k mod n 个位置  </li>\n<li>先将所有元素翻转  </li>\n<li>再翻转 [0, k mod n−1] 区间和 [k mod n, n−1] 区间即可</li>\n</ul>\n<h1 id=\"除自身以外数组的乘积（238）\"><a href=\"#除自身以外数组的乘积（238）\" class=\"headerlink\" title=\"除自身以外数组的乘积（238）\"></a>除自身以外数组的乘积（238）</h1><blockquote>\n<p>给一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 </p>\n</blockquote>\n<p><a href=\"https://leetcode.cn/problems/product-of-array-except-self/?envType=study-plan-v2&envId=top-100-liked\">除自身以外数组的乘积</a></p>\n<p>① 暴力解法  </p>\n<ul>\n<li>两层循环进行解答，但是会超时</li>\n</ul>\n<p>② 前后缀积  </p>\n<ul>\n<li>分别计算左前缀和右前缀，然后进行相乘</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">productExceptSelf</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]:</span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">        left ,right, res = [<span class=\"number\">0</span>]*n,[<span class=\"number\">0</span>]*n,[<span class=\"number\">0</span>]*n</span><br><span class=\"line\">        <span class=\"comment\">#计算第i个位置的左前缀积</span></span><br><span class=\"line\">        left[<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,n):</span><br><span class=\"line\">            left[i] = left[i-<span class=\"number\">1</span>]*nums[i-<span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"comment\">#计算第i个位置的右前缀积</span></span><br><span class=\"line\">        right[n-<span class=\"number\">1</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">reversed</span>(<span class=\"built_in\">range</span>(n-<span class=\"number\">1</span>)):</span><br><span class=\"line\">            right[i] = right[i+<span class=\"number\">1</span>]*nums[i+<span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"comment\">#分别将左前缀和右前缀对应进行相乘</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">            res[i] = left[i]*right[i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"缺失的第一个正数-41\"><a href=\"#缺失的第一个正数-41\" class=\"headerlink\" title=\"缺失的第一个正数(41)\"></a>缺失的第一个正数(41)</h1><blockquote>\n<p>已知一个未排序的整数数组 <code>nums</code> ，找出其中没有出现的最小的正整数</p>\n</blockquote>\n<p><a href=\"https://leetcode.cn/problems/first-missing-positive/description/?envType=study-plan-v2&envId=top-100-\">缺失的第一个正数</a></p>\n<p>数组有N个元素，对应索引值为0~n-1，并设置标记。如果当前的值小于n，那么将其n-1位置上面的元素做标记，如设置为负数， 如果全部被标记 ，那返回的就是n+1 ，反之，那就是第一个正数的位置 （因为其中有负数或者大于n的数 ，这样初始处理就是将这些数设置为n+1 ）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">firstMissingPositive</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">        <span class=\"comment\">#忽略无用数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i]&lt;=<span class=\"number\">0</span> <span class=\"keyword\">or</span> nums[i] &gt; n :</span><br><span class=\"line\">                nums[i] = n+<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\">#进行标记</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">        <span class=\"comment\">#为啥要取绝对值呢  因为如果是3  4 6 5  当遍历到3时候，会修改后续位置为 3 4 -6 5，所以需要取绝对值，避免索引值为负数</span></span><br><span class=\"line\">            num = <span class=\"built_in\">abs</span>(nums[i])</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num &lt;= n:</span><br><span class=\"line\">                nums[num-<span class=\"number\">1</span>] = -<span class=\"built_in\">abs</span>(nums[num-<span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i]&gt;<span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i+<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> n+<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n","text":"最大子数组和(53)最大子数组和 给一个整数数组 nums ，找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 开始想到使用滑动窗口来进...","permalink":"/post/hot100题-数组","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"hot-100题","slug":"hot-100题","count":5,"path":"api/categories/hot-100题.json"}],"tags":[{"name":"hot100-数组","slug":"hot100-数组","count":1,"path":"api/tags/hot100-数组.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-53\"><span class=\"toc-text\">最大子数组和(53)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%EF%BC%8856%EF%BC%89\"><span class=\"toc-text\">合并区间（56）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84%EF%BC%88189%EF%BC%89\"><span class=\"toc-text\">轮转数组（189）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF%EF%BC%88238%EF%BC%89\"><span class=\"toc-text\">除自身以外数组的乘积（238）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0-41\"><span class=\"toc-text\">缺失的第一个正数(41)</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"/img/logo.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"GraphRAG","uid":"a94104330904ea4342e61b1f1484bcec","slug":"GraphRAG","date":"2025-08-27T08:54:30.000Z","updated":"2025-08-30T06:21:32.270Z","comments":true,"path":"api/articles/GraphRAG.json","keywords":"AI、Python","cover":[],"text":"GraphRAG（一）GraphRAG简介 基本的RAG系统通常集成向量数据库和LLM，对知识库进行嵌入存入向量数据库，后根据相似度计算，从向量数据库中检索到相...","permalink":"/post/GraphRAG","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"GraphRAG","slug":"GraphRAG","count":1,"path":"api/categories/GraphRAG.json"}],"tags":[{"name":"GraphRAG","slug":"GraphRAG","count":1,"path":"api/tags/GraphRAG.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"/img/logo.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"实习感想","uid":"cc854447c6f723d3af33716c40268231","slug":"实习感想","date":"2025-08-27T06:04:41.000Z","updated":"2025-09-07T06:19:17.107Z","comments":true,"path":"api/articles/实习感想.json","keywords":"AI、Python","cover":[],"text":"实习感受在不知不觉中，实习已经有一个多月的时间了，简单概括一下这段经历。 回想起在找实习的这段时间里，心里还是很没底的，坦白说我的简历项目全是网上 Copy 的...","permalink":"/post/实习感想","photos":[],"count_time":{"symbolsCount":535,"symbolsTime":"1 mins."},"categories":[{"name":"实习","slug":"实习","count":1,"path":"api/categories/实习.json"}],"tags":[{"name":"实习感想","slug":"实习感想","count":1,"path":"api/tags/实习感想.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"/img/logo.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}