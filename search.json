[{"title":"10月小结","url":"//post/10%E6%9C%88%E5%B0%8F%E7%BB%93.html","content":"10月总结在11月的开始来回看10月，似乎也不知道怎么来总结过去的一个月。我觉得在对于科研这件事情来说，有的时候，做实验也好，找创新思路也好，可能有的时候真的成效很少，很多负反馈，可能有的时候都会怀疑人生了。但是在研究生的任务又不能不允许我们每个人抛开这件事情，毕业严格，硕士扩招，等待的又是什么呢。所以呢，我觉得在当下自己，可以放慢脚步，但是确实需要去考虑时间，去追溯未来，完整的过好当下，可能会遇到各种挫败，但是也要相信，失败的代价我是可以承受的，也可以重新站起来去面对各种困难，最终成为强大的自己。\n11月的目标11月对我而言是忙碌的一个月，有很多需要去做的事情，我给自己定的目标是，一步步脚踏实地，争取每天进步一点点。当然，今年的考试肯定是要好好准备的，得分开一些精力去做和去思考一些事情，不能太过于茫然，把时间花在重要的事情上。不瞎想，以当下最重要的事情为主。\n","categories":["反思总结"],"tags":["10月小结"]},{"title":"AI应用开发","url":"//post/AI%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.html","content":""},{"title":"GraphRAG","url":"//post/GraphRAG.html","content":"GraphRAG（一）GraphRAG简介\n\n\n\n\n\n\n\n\n基本的RAG系统通常集成向量数据库和LLM，对知识库进行嵌入存入向量数据库，后根据相似度计算，从向量数据库中检索到相关的片段作为大模型的上下文。但是这种在处理复杂的任务时候，如联系不同信息片段全面回答问题有些局限。 \n与使用向量数据库检索语义相似文本的基本 RAG 不同，GraphRAG 则采取了一种创新的路径，首先利用大型语言模型从非结构化文本数据中提取出实体和关系，并据此构建一个知识图谱。接着，依托图谱的拓扑结构进行社区发现，对每个社区进行逐层总结，最终形成一个分层且结构化的知识网络。在进行查询时，GraphRAG 利用这一知识网络来强化信息检索，从而为模型提供更具启发性的上下文，以回答那些需要深度推理和全局视角的问题。（结合传统的图数据库查询和强大的生成模型）\n\n索引（Indexing）：这是 GraphRAG 的数据处理阶段，它将非结构化文本转化为结构化知识。主要步骤包括：\n\n文本分块：将长文档切分成小的文本单元（TextUnit）；\n图谱提取：利用大模型从文本单元中提取出实体（Entities）和关系（Relationships），构建知识图谱；\n社区发现：使用 Leiden(图谱聚类算法) 等算法对图谱进行层次化社区聚类；（不同的社区指的是不同的知识结构或者主题）\n社区总结：利用大模型为每个层级的社区生成摘要报告；\n\n\n查询（Querying）：这是 GraphRAG 的数据检索与问答阶段，利用构建好的知识图谱和摘要来回答问题。比较常见的查询方式有：\n\n全局搜索（Global Search）：利用社区摘要，通过 Map-Reduce 的方式对整个数据集进行归纳总结，回答宏观问题；\n本地搜索（Local Search）：当问题涉及特定实体时，从该实体出发，在知识图谱中向外扩展，聚合其邻近的实体、关系以及相关的原始文本块，为大模型提供精准的局部上下文\n\n\n\n\n\n\n\nGraphRAG快速入门\n\n\n\n\n\n\n\n\n本文章是在腾讯云(免费GPU)上进行，使用的模型服务商是硅基流动，下面走进GraphRAG的开始吧！\n\n\n\n\n\n\n\n\n\n在这个平台上可以选择创建各种不同的环境，这里选择Pytorch的环境，如果要跑简单的深度学习也可以使用这个环境\n\n\n创建虚拟环境#使用conda创建graphrag虚拟环境conda create -n graphrag python=3.10#安装graphragpip install graphrag\n\n准备demo数据# 创建demo目录mkdir -p ./ragtest/input# 下载微软官方demo数据curl https://www.gutenberg.org/cache/epub/24022/pg24022.txt -o ./ragtest/input/book.txt\n\n\n\n\n\n\n\n\n\n\n初始化demo目录 执行这个命令之后 将在 ./ragtest目录中创建两个文件：.env和settings.yaml\n因为默认生成的是跟GPT模型相关的配置文件，国内使用获取其API不太方便，因此需要修改使用，这里使用硅基流动的模型服务，大模型选择deepseek-v3，嵌入模型选择 BAAI/bge-large-zh-v1.5\ngraphrag init --root ./ragtest\n\n\n\n\n\n\n\n\n\n\n修改配置文件 在settings.yaml 文件中修改初始的模型，然后再.env文件中的API为硅基流动的API\nmodels:  default_chat_model:    type: openai_chat    api_base: https://api.siliconflow.cn/v1    api_key: $&#123;GRAPHRAG_API_KEY&#125;    model: deepseek-ai/DeepSeek-V3    encoding_model: cl100k_base    concurrent_requests: 3    requests_per_minute: 30  default_embedding_model:    type: openai_embedding    api_base: https://api.siliconflow.cn/v1    api_key: $&#123;GRAPHRAG_API_KEY&#125;    model: BAAI/bge-large-zh-v1.5    encoding_model: cl100k_base    concurrent_requests: 3     requests_per_minute: 30\n\n构建索引\n\n\n\n\n\n\n\n\n执行如下命令将自动完成\n文本分块 、实体识别与关系提取（调用大模型）、构建实体-关系图谱、社区检测（Leiden算法）、生成社区摘要（调用大模型）、嵌入计算 + 向量索引构建（花费时间较长）\ncd ragtestgraphrag index --root .\n\nragtest目录结构详解\n\n\n\n\n\n\n\n\n\nragtest&#x2F; ├── settings.yaml      # 配置文件 ├── prompts&#x2F;           # 提示词模板 ├── input&#x2F;             # 数据输入目录（需手动创建） ├── .env               # 存储 API 密钥 └── output&#x2F;            # 自动生成的索引结果\n\n\n\n\n\n\n\n\n\nGraphRAG 使用 Parquet 存储数据，这是一种列式存储的二进制文件格式，专为高效存储和处理大规模结构化数据而设计，广泛用于大数据处理和分析场景。另外，LanceDB 是一个为机器学习优化的向量数据库，使用 Apache Arrow 格式存储。GraphRAG 使用它来存储文本嵌入向量，用于相似性搜索。\nGraphRAG 输出文件详解\n\n\n\n查询GraphRAG 输出文件概览\n\n\n文件&#x2F;目录\n作用\n内容\n理解\n\n\n\ndocuments.parquet\n存储原始文档的元信息与全文内容\n每个文档一个条目，包含 title、text、doc_id\n原始文档的索引表\n\n\ntext_units.parquet\n存储文档分块（chunk）后的切片内容\n每一块对应一次 LLM 调用（如实体提取），记录切分后的每个 chunk 的内容\n分块后的最小处理单元\n\n\nentities.parquet\n存储从所有文档中提取的实体信息\n实体名称、类型（人物、组织、地点、事件）、出现频率、描述、出现在哪些块中\n知识图谱的节点（Node）\n\n\nrelationships.parquet\n存储实体之间的语义关系\n两个实体之间的关系（如 “张三-管理-产品部”），关系描述、类型、权重\n知识图谱的边（Edge）\n\n\ncommunities.parquet\n存储社区检测结果\n基于图谱运行社区检测算法得到的“主题组”，每个社区包含一组相关实体\n自动发现的主题集群\n\n\ncommunity_reports.parquet\n为每个社区生成自然语言摘要\n报告标题、摘要、主要发现，由 LLM 生成，面向用户\n社区的结构化报告，便于理解主题\n\n\nlancedb/\n存储文本单元的向量表示\n用于局部语义搜索\n为后续检索提供 embedding 索引\n\n\n全局搜索（Global Search）：适用于需要对整个数据集进行宏观理解和总结的问题：\n本地搜索（Local Search）：适用于查询关于特定实体的具体信息：\n相关资料GraphRAG本地部署使用及兼容千帆通义\nGithub地址\n文档地址\ngraphrag-more地址\nGraphRAG全流程实战\nGraphRAG快速入门\nGraphRAG详解\nGraphRAG快速入门与原理详解（索引建立的详细举例介绍）\n","categories":["GraphRAG"],"tags":["GraphRAG"]},{"title":"LangChain","url":"//post/LangChain.html","content":"\n\n\n\n\n\n\n\n\n本篇文章主要介绍LangChain基础语法，RAG原理，以及使用LangChain实现简易的RAG系统，详细的RAG优化以及类型在另外的文章进行介绍\n1.LangChain 简介Langchains是用于开发大模型驱动的框架，借助LangChain可以轻松搭建基于LLM的相关应用，比如RAG系统\n此框架包含以下部分：\nlangchain-core: 基础抽象和LangChain表达式 (LCEL)langchain-community: 第三方集成，第三方相关的包langchain: 组成应用程序认知架构的链、代理和检索策略。LangGraph: 通过将步骤建模为图中的边和节点，构建强大且有状态的多参与者应用程序。与LangChain无缝集成，但也可以单独使用LangServe: 将LangChain链部署为REST APILangSmith: 一个开发者平台，让您调试、测试、评估和监控LLM应用程序\n\n\n\n\n\n\n\n2.LangChain 基础\n\n\n\n\n\n\n\n\nLangChain是为大模型应用而生的框架，结合大模型应用逻辑上，分为输入、模型处理、输出三个环节。通过构建提示词工程，作为上下文给大模型，然后通过结果解析器解析相应格式的输出\nLCEL表达式基于LangChain框架编写大模型应用的过程就像垒积木，其中的积木就是Prompts，LLMs和各OutputParser等。如何将这些积木组织起来，除了使用基本Python语法调用对应类的方法，一种更灵活的方法就是使用位于LangChain-Core层中的LCEL（LangChain Expression Language）(使用管道符来进行拼接)\nRunnable接口LCEL的基础是Runnable接口。通过实现Runnable接口，LCEL定义了一组具有通用调用方式的方法集。\nRunnable有一系列的子类，比如PromptTemplate、LLM和StrOutputParser（还有更多），这些组件子类都间接继承自Runnable(继承自RunnableSequence，而后者又继承自Runnable) 通过 管道符”|”前后两个组件合成一个Runnable的子孙类RunnableSequence对象返回，从而达到串起来形成链(chain)的目的。\n\n\n\n\n\n\n\n\n\nRunnable的__or__()方法重新定义了”|”语法，所以基于LCEL的chain就能通过或(也类似shell中的管道)操作符号”|”串起来。这也就是前面提到的“chain &#x3D; prompt | llm | output_parser”这行代码虽然看上去跟普通Python不一样，但它是合法的，原因就在这里\n3.LangChain实现RAG\n\n\n\n\n\n\n\n\nRAG的出现是为了在一定程度上缓解大模型的幻觉问题，因为大模型的输出是基于数学概率的输出预测、且信息不具有实效性、缺乏相关领域的专业知识，下面使用LangChain的链式调用实现简单的RAG。\n基础RAG系统，流程如下：\n\n文档切分\n向量嵌入\n构建提示词\n定义大模型服务\n检索相关片段作为大模型上下文\n结果解析器对大模型结果进行解析\n\n\n\n#完整的rag  from langchain_core.output_parsers  import StrOutputParserquery = &quot;在线支付取消订单后钱怎么返还&quot;from langchain_community.embeddings import DashScopeEmbeddingsfrom config.load_key import load_keyif not os.environ.get(&quot;DASHSCOPE_API_KEY&quot;):    os.environ[&quot;DASHSCOPE_API_KEY&quot;] = load_key(&quot;LANGSMITH_API_KEY&quot;)embedding_model = DashScopeEmbeddings(model=&quot;text-embedding-v1&quot;)redis_url = &quot;redis://localhost:6379&quot;config = RedisConfig(    index_name=&quot;meituan-index&quot;,   # 索引名，对应之前构建的知识库索引    redis_url=redis_url,          # Redis 连接地址)vector_store = RedisVectorStore(embedding_model, config=config)retriever = vector_store.as_retriever()#定义大模型from langchain_openai import  ChatOpenAIllm = ChatOpenAI(    model = &quot;deepseek-v3&quot;,    base_url =&quot;https://dashscope.aliyuncs.com/compatible-mode/v1 &quot;,    openai_key = load_key(&quot;LANGSMITH_API_KEY&quot;),) #定义提示模板from langchain_core.prompts import  ChatPromptTemplateprompt_template = ChatPromptTemplate.from_messages([    (&quot;user&quot;, &quot;你是一个答疑机器人，你的任务是根据下述给定的已知信息回答用户问题。\\n&quot;             &quot;已知信息：&#123;context&#125;\\n&quot;             &quot;用户问题：&#123;question&#125;\\n\\n&quot;             &quot;如果已知信息不含用户问题的答案，或者已知信息不足以回答用户问题，请直接回复“我无法回答您问题”。\\n&quot;             &quot;请不要输出已知信息中不包含的信息或答案。\\n&quot;             &quot;请用中文回答用户问题。&quot;)  ])#收集document内容def collect_document_content(segments):    text = []    for segment in segments:        text.append(segment.page_content)    return textfrom operator import itemgetterchain = (&#123;     &quot;question&quot;: query,    &quot;context&quot;: itemgetter(&quot;question&quot;)|retriever |collect_document_content,&#125;| prompt_template| llm| StrOutputParser())response = chain.invoke(&#123;&quot;question&quot;: query&#125;)  \n\n4.相关资料大模型应用开发学习资料\nLangChain中文文档\nCSDN博客\n","categories":["Langchain"],"tags":["AI"]},{"title":"LangGraph","url":"//post/LangGraph.html","content":"LangGraph图控制Agent    \n开发Agent\n节点 边\n","categories":["AI"],"tags":["LangGraph"]},{"title":"RAG","url":"//post/RAG.html","content":""},{"title":"MCP","url":"//post/MCP.html","content":"MCPFunction call\n\n\n维度\nFunction Calling（FC）\nMCP（Model Context Protocol）\n\n\n\n本质\n能力 —— 某个大模型原生就带的一种「调用函数」功能\n协议 —— 定义 AI 与外部世界如何长期、标准、可复用地交互\n\n\n工作方式\n模型在一次推理里主动决定要调用哪个函数，并吐出结构化参数\n通过「客户端 - 服务器」架构，由 MCP Server 被动等待模型或 Agent 的请求\n\n\n是否标准化\n否。OpenAI、Anthropic、百度等各家接口格式不同\n是。统一 JSON-RPC 2.0 协议，跨模型通用\n\n\n上下文管理\n单次调用，无状态；复杂多轮任务需自己维护\n协议层面支持会话、状态、长链路任务\n\n\n复用 &#x2F; 共享\n函数代码往往紧耦合在项目里，换模型就得重写\n一次写成 MCP Server，可被任何支持 MCP 的模型 &#x2F; IDE&#x2F;Agent 直接插用\n\n\nMCP介绍\n\n\n\n\n\n\n\n\n简单来说 MCP就是让大模型使用各类工具的协议\nMCP &#x3D; 双方交流的“共同语言&#x2F;协议”     指的就是环境 环境就是指周围有哪些函数可以用来调用  从而获取到外界的信息 比如获取天气信息 网络信息等等 MCP就是让模型感知上下文的协议 简称模型上下文协议 \nMCP server：其实就是一个「写好的工具&#x2F;程序」，通常是一个 NPM 包或者脚本。\nMCP client（比如 IDE 插件、AI 助手）：它不会自己实现功能，而是通过 启动你本地的 MCP server 来获得能力。\n执行方式：server 就是一个本地进程，本质就是运行命令（node、python、npx 等等），然后通过 标准输入&#x2F;输出 (stdin&#x2F;stdout) 用 MCP 协议通信。\n\n\n\n\n\n\n\n\n\nMCP server 不是远程服务，而是本地执行的工具，只是用 MCP 协议标准化了“如何跟这些工具说话”。\nMCP  Server是一个程序 程序的执行符合MCP协议\nnpx：临时拉取 npm 包到本地缓存 → 执行 → 不会马上删，但缓存会管理。\n\n\n如果同时配置了多个MCP服务，比如百度地图、Unity、Blender等。每个MCP服务需要对应Host中的一个Client来一对一通信。Client被包含在Host中。\n\n\n每个支持MCP的软件，都有一个MCP Server文件，里面列出了所有支持调用的函数，函数注释里的内容是给AI看的，告诉AI这个函数是做什么用的。MCP Server文件就是给AI看的工具说明书。\nMCP交互过程MCP交互过程如下：\n①cline与MCP server 进行寒暄    寒暄结束后，cline就知道MCP server中有哪些工具\n②用户提出问题后  cline接收到问题  将问题与注册好的MCP server 以及server中的工具列表 告诉给模型 \n③模型无法回答当前问题  但是MCP中有相应的工具可以调用 于是告诉cline 想调用MCP中的工具\n④cline接受到请求后  就跟对应的MCP server沟通  对应的MCP server 接收到请求后 调用对应的工具 返回相关的结果\n然后MCP server 将结果返回给 cline cline传给大模型\n⑤模型接收到回答后，将结果返回为cline，cline再将结果返回给用户\n\n\n\n\n\n\n\n\n\nMCP 过程的交互只涉及MCP Server 和cline的交互  不涉及跟大模型之间的交互  MCP没有规定如何与模型进行交互\nMCP协议主要规定了  ①每个MCP  Server 有哪些函数可以用  ②如何调用这些函数 总结为函数的注册和使用\n\n\nMCP 的本质MCP 就是host 和 MCP server交互的格式  (json格式)  这样不使用host 在命令行启动MCP server 输入相关的格式 就可以与MCP server进行通信\n\n\n\n\nMCP &#x3D; 一种「通信协议  + 本地扩展机制」。\nMCP server &#x3D; 各种各样的工具（新闻抓取、数据库查询、命令行工具…）。\nMCP client &#x3D; 统一的入口，把不同的工具“挂载”到 AI 或 IDE 里用。\nMCP 三种传输协议\n\n\n协议名称\n通信方式\n适用场景\n优势\n局限\n\n\n\nStdio（标准输入输出）\n使用进程的标准输入（stdin）和标准输出（stdout）进行本地通信，基于 JSON-RPC 2.0 格式\n本地开发、调试、IDE 插件、命令行工具\n简单易实现、跨平台、低延迟\n仅支持本地通信，无法跨网络，低并发\n\n\nSSE（Server-Sent Events）\n客户端通过 HTTP POST 发送请求，服务器通过 SSE 单向推送流式响应\n实时监控、新闻推送、远程服务调用\n基于 HTTP，浏览器友好，支持流式数据\n仅支持单向通信，MCP 官方已标记为 “即将废弃”\n\n\nStreamable HTTP（新型流式 HTTP）\n支持双向流式通信的现代 HTTP 协议，替代 SSE，支持会话恢复、OAuth 认证等\n分布式系统、高并发、双向实时交互\n双向通信、高性能、企业级安全机制\n实现较复杂，生态仍在发展中\n\n\n创建一个MCP server初始化项目\n\n\n\n\n\n\n\n\nuv init weather\n#进入weather执行如下命令\nuv sync\n.venv\\Scripts\\activate.bat\n#添加依赖uv add “mcp[cli]” httpx\n建立 weather.py# 导入类型提示模块，用于类型注解from typing import Any# 导入httpx库，用于发送HTTP请求import httpx# 从mcp.server.fastmcp模块导入FastMCP类# FastMCP是一个快速构建MCP（Model Control Protocol）服务器的框架from mcp.server.fastmcp import FastMCP# 创建FastMCP实例，命名为&quot;weather&quot;，日志级别设置为ERROR（只显示错误信息）mcp = FastMCP(&quot;weather&quot;, log_level=&quot;ERROR&quot;)# 常量定义# NWS（National Weather Service）API的基础URLNWS_API_BASE = &quot;https://api.weather.gov&quot;# 用户代理字符串，用于标识应用程序USER_AGENT = &quot;weather-app/1.0&quot;async def make_nws_request(url: str) -&gt; dict[str, Any] | None:    &quot;&quot;&quot;向NWS API发起请求并处理错误。        Args:        url: 要请求的API URL            Returns:        成功时返回解析后的JSON数据字典，失败时返回None    &quot;&quot;&quot;    # 设置请求头信息    headers = &#123;        &quot;User-Agent&quot;: USER_AGENT,           # 用户代理标识        &quot;Accept&quot;: &quot;application/geo+json&quot;    # 接受的数据格式    &#125;        # 创建异步HTTP客户端    async with httpx.AsyncClient() as client:        try:            # 发起GET请求，设置超时时间为30秒            response = await client.get(url, headers=headers, timeout=30.0)            # 如果响应状态码不是2xx，抛出异常            response.raise_for_status()            # 返回解析后的JSON数据            return response.json()        except Exception:            # 捕获所有异常，返回None表示请求失败            return Nonedef format_alert(feature: dict) -&gt; str:    &quot;&quot;&quot;将警报数据格式化为可读的字符串。        Args:        feature: 包含警报信息的字典            Returns:        格式化后的警报字符串    &quot;&quot;&quot;    # 获取警报属性    props = feature[&quot;properties&quot;]    # 格式化警报信息，使用get方法提供默认值防止键不存在    return f&quot;&quot;&quot;事件: &#123;props.get(&#x27;event&#x27;, &#x27;未知&#x27;)&#125;区域: &#123;props.get(&#x27;areaDesc&#x27;, &#x27;未知&#x27;)&#125;严重程度: &#123;props.get(&#x27;severity&#x27;, &#x27;未知&#x27;)&#125;描述: &#123;props.get(&#x27;description&#x27;, &#x27;无描述信息&#x27;)&#125;指示: &#123;props.get(&#x27;instruction&#x27;, &#x27;无具体指示&#x27;)&#125;&quot;&quot;&quot;# 使用@mcp.tool()装饰器将函数注册为MCP工具@mcp.tool()async def get_alerts(state: str) -&gt; str:    &quot;&quot;&quot;获取指定美国州的天气警报。        Args:        state: 两个字母的美国州代码（例如：CA, NY）            Returns:        格式化后的警报信息字符串    &quot;&quot;&quot;    # 构建获取州警报的URL    url = f&quot;&#123;NWS_API_BASE&#125;/alerts/active/area/&#123;state&#125;&quot;    # 发起API请求获取数据    data = await make_nws_request(url)    # 检查数据是否有效    if not data or &quot;features&quot; not in data:        return &quot;无法获取警报或未找到警报。&quot;    # 检查是否有警报    if not data[&quot;features&quot;]:        return &quot;该州无活动警报。&quot;    # 格式化所有警报    alerts = [format_alert(feature) for feature in data[&quot;features&quot;]]    # 用分隔符连接所有警报    return &quot;\\n---\\n&quot;.join(alerts)# 注册为MCP工具的天气预报函数@mcp.tool()async def get_forecast(latitude: float, longitude: float) -&gt; str:    &quot;&quot;&quot;获取指定位置的天气预报。        Args:        latitude: 位置的纬度        longitude: 位置的经度            Returns:        格式化后的天气预报字符串    &quot;&quot;&quot;    # 首先获取预报网格端点    points_url = f&quot;&#123;NWS_API_BASE&#125;/points/&#123;latitude&#125;,&#123;longitude&#125;&quot;    points_data = await make_nws_request(points_url)    # 检查点数据是否获取成功    if not points_data:        return &quot;无法获取此位置的预报数据。&quot;    # 从点响应中获取预报URL    forecast_url = points_data[&quot;properties&quot;][&quot;forecast&quot;]    forecast_data = await make_nws_request(forecast_url)    # 检查预报数据是否获取成功    if not forecast_data:        return &quot;无法获取详细预报。&quot;    # 将时间段格式化为可读的预报    periods = forecast_data[&quot;properties&quot;][&quot;periods&quot;]    forecasts = []    # 只显示接下来的5个时间段    for period in periods[:5]:        forecast = f&quot;&quot;&quot;&#123;period[&#x27;name&#x27;]&#125;:温度: &#123;period[&#x27;temperature&#x27;]&#125;°&#123;period[&#x27;temperatureUnit&#x27;]&#125;风力: &#123;period[&#x27;windSpeed&#x27;]&#125; &#123;period[&#x27;windDirection&#x27;]&#125;预报: &#123;period[&#x27;detailedForecast&#x27;]&#125;&quot;&quot;&quot;        forecasts.append(forecast)    # 用分隔符连接所有预报    return &quot;\\n---\\n&quot;.join(forecasts)# 程序入口点if __name__ == &quot;__main__&quot;:    # 初始化并运行服务器，使用stdio传输方式    mcp.run(transport=&#x27;stdio&#x27;)\n\n配置到cline中\n&quot;weather&quot;: &#123;    &quot;disabled&quot;: false,    &quot;timeout&quot;: 60,    &quot;command&quot;: &quot;uv&quot;,    &quot;args&quot;: [      &quot;--directory&quot;,      &quot;E:/MCP/weather&quot;,      &quot;run&quot;,      &quot;weather.py&quot;    ],    &quot;transportType&quot;: &quot;stdio&quot;  &#125;\n\n\n\n\n\n\n\n\n\n\n“disabled”: false 表示该服务是否被禁用。false 表示该服务是启用状态，可以正常运行。\n“timeout”: 60 设置该服务的超时时间，单位为秒。\n“command”: “uv” 指定执行该服务时使用的命令。\n“args” 出了执行 command 时需要传递的参数。\n“transportType”: “stdio” 指定服务的通信方式。stdio 表示标准输入输出流（Standard Input Output），通常用于进程间通信。\n大部分的MCP server是通过输入输出与cline沟通的，如果MCP server是在终端启动的，那可以直接看到输入和输出，但是目前是有cline启动的，输入输出只有cline才能看到\n相关资源mcp.so\n魔搭MCP广场\n百度搜索开放平台\nMCP b站视频\nMCP笔记\n","categories":["AI"],"tags":["MCP"]},{"title":"hexo博客搭建教程","url":"//post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B.html","content":"\n\n\n\n\n\n\n\n\n初衷：\n我记得在刚上大三那会儿，想把自己学的一些东西记录到微信公众号上。刚开始坚持了几天，但是后来放弃了，因为大部分是Copy，也缺少自己的思考。\n经过最近的经历，我明白了一个道理：记录也是一个输出的过程。先自己理解，再把学习内容记录下来（记录适合自己学习或者找资料的过程），也是一种输出。\n所以，我决定从此开始，记录自己的过程，无论是：\n技术学习 、碎碎念  、成长困惑  、考试学习\n我想说，我可能走得很慢，但是我不会停下来，向内生长，加油!\n1. hexo介绍正如hexo的首页所显示的，它是一款非常快速，简介，高效的博客框架平台，我们可以利用hexo快速生成博客网站的模板，然后部署为我们自己的博客网站\n\n\n2. hexo教程下面博客记录完整搭建的教程，比较简易，我就是根据这个教程来搭建的，简短的时间就可以搭建一个属于自己的博客。\n其中主要步骤包括：\n\n软件的安装如git、Nodejs\nhexo部署到Github\nhexo配置（如用户个人信息、头像、主题下载配置分类目录）\n\n配置好hexo以及主题之后就可以开始写个人博客了，常见的命令是 \nhexo  clean             # 清除缓存文件和生成的静态文件hexo  new &quot;文章名称&quot;     # 新建界面hexo  generate          # 生成静态文件 可以简写成hexo g hexo  server            # 启动服务器   可以简写hexo shexo  deploy            # 部署网站，构建在GitHub的服务器中，网页文件将上传到关联的个人仓库 可以简写成hexo d\n\n\n\nHexo+Next部署github搭建个人博客+优化全过程（完整详细版）\n3. hexo中图片上传问题\n\n\n\n\n\n\n\n\n平时我们写文章可能会记录相关的图片，我个人也喜欢将别人写得好好理解的图片记录下来，但是在图片处理的过程中遇到一些问题（网上的方法各异，试了很多都不行），找了很多的教程，也是自己没有好好思考问题出在哪里，弄了很长时间，最后发现了相应的问题，仅以此记录我的处理方式。（参考CSDN并修改）\nTypora安装Typora\nTypora破解教程(破解序列号在评论区)\n​       修改Typora 偏好设置  如下图更改，此操作将图片文件保存路径: .&#x2F;${filename} 即保存到与 当前正在编辑的文件名相同的同级文件\n\n\n修改hexo配置修改_config.yml中的post_asset_folder，false 改为 true，这样修改后，每次 hexo new page生成新文章，都会在文章文件同级目录创建一个与文章文件名同名的文件夹，我们就在这里存放此文章的图片\n注：在md文档中存放的路径为文件夹/图片名称  \n之前找到有一种方式自定义安装一个插件，将md文档中的路径进行转换，第一天可以，但是第二天就不可以，找了很多办法，还是借助AI写了一个脚本实现相应的功能\n\n\n\n\n\n\n具体实现以下是在 hexo 中实现：Markdown 写 文件夹/图片名称 也能自动到相对应文章资源文件夹并生成 &#123;% asset_img %&#125; 标签。（使用插件进行实现）\n创建文件夹mkdir hexo-asset-imgcd hexo-asset-imgnpm init\n\n编写插件index.js&#x27;use strict&#x27;;/** * md文件返回 true * @param &#123;*&#125; data  */function ignore(data) &#123;    // TODO: 好奇怪，试了一下, md返回true, 但却需要忽略 取反!    var source = data.source;    var ext = source.substring(source.lastIndexOf(&#x27;.&#x27;)).toLowerCase();    return [&#x27;md&#x27;,].indexOf(ext) &gt; -1;&#125;function action(data) &#123;    var reverseSource = data.source.split(&quot;&quot;).reverse().join(&quot;&quot;);    var fileName = reverseSource.substring(3, reverseSource.indexOf(&quot;/&quot;)).split(&quot;&quot;).reverse().join(&quot;&quot;);    // ![example](postname/example.jpg)  --&gt;  &#123;% asset_img example.jpg example %&#125;    var regExp = RegExp(&quot;!\\\\[(.*?)\\\\]\\\\(&quot; + fileName + &#x27;/(.+?)\\\\)&#x27;, &quot;g&quot;);    // hexo g    data.content = data.content.replace(regExp, &quot;&#123;% asset_img $2 $1 %&#125;&quot;,&quot;g&quot;);    // log.info(`hexo-asset-img: filename: $&#123;fileName&#125;, title: $&#123;data.title.trim()&#125;`);        return data;&#125;hexo.extend.filter.register(&#x27;before_post_render&#x27;,(data)=&gt;&#123;    if(!ignore(data))&#123;        action(data)    &#125;&#125;, 0);\n\n本地测试插件\nHexo 根目录下 package.json 中 dependencies 添加一行 &quot;hexo-asset-img&quot;: &quot;^1.0.0&quot;, \n\n将 hexo-asset-img 文件夹复制到 Hexo 根目录下 node_modules 文件夹下 \n   hexo clean &amp;&amp; hexo g   hexo s # 本地预览   #编译后的文件在public文件夹下Markdown 图片写法在 Markdown 里可以写带文件夹的图片：```markdown![示例](demo/demo.png)![另一张](test/other.png)\n\n\n\n\n\n\n\n\n\n\n图片相对路径是相对于 Markdown 文件所在目录。\n4.Netlify部署Netlify部署方法\n5. 相关资料插件方法 （插件方法可行）\n","categories":["博客搭建教程"],"tags":["博客搭建教程"]},{"title":"hot100题-二分查找","url":"//post/hot100%E9%A2%98-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html","content":"二分查找区间的选择（易错点） \n两种区间定义方式 [l,r] 和 [l,r) 都可以用在所有场合，只是写法不同，关键是要保证「区间定义 → 循环条件 → 更新规则 → 退出条件」保持一致\n①左闭右闭区间[l,r]   查找目标值\n\n\n\n\n\n\n\n\n\n含义：查找的范围内，l和r都位置都是可能的答案\n指针变化：r  &#x3D; mid -1 或 l &#x3D; mid+1\nclass Solution:    def search(self, nums: List[int], target: int) -&gt; int:        left, right = 0, len(nums) - 1  # 定义target在左闭右闭的区间里，[left, right]        while left &lt;= right:            middle = left + (right - left) // 2                        if nums[middle] &gt; target:                right = middle - 1  # target在左区间，所以[left, middle - 1]            elif nums[middle] &lt; target:                left = middle + 1  # target在右区间，所以[middle + 1, right]            else:                return middle  # 数组中找到目标值，直接返回下标        return -1  # 未找到目标值\n\n②左闭右开区间[l,r)   找插入位置 \n\n\n\n\n\n\n\n\n\n含义：查找的范围内，l是可能的答案，但r一定不是\n指针变化：r  &#x3D; mid  或 l &#x3D; mid+1\nclass Solution:    def search(self, nums: List[int], target: int) -&gt; int:        left, right = 0, len(nums)  # 定义target在左闭右开的区间里，即：[left, right)        while left &lt; right:  # 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;            middle = left + (right - left) // 2            if nums[middle] &gt; target:                right = middle  # target 在左区间，在[left, middle)中            elif nums[middle] &lt; target:                left = middle + 1  # target 在右区间，在[middle + 1, right)中            else:                return middle  # 数组中找到目标值，直接返回下标        return -1  # 未找到目标值\n\n搜索插入位置\n\n\n\n\n\n\n\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。请必须使用时间复杂度为 O(log n) 的算法。\n35. 搜索插入位置\n本题可以使用二分查找进行查找，使用的是闭区间的形式，最后left &gt; right ，如果目标值在数组中则直接返回数组中的索引，如果不存在则应该插入的位置就是left的位置\nclass Solution:    def searchInsert(self, nums: List[int], target: int) -&gt; int:        left,right = 0,len(nums)-1        while left&lt;=right:            mid = (left+right)//2            if nums[mid] == target:                return mid             elif nums[mid] &gt; target:                right = mid -1            else:                left = mid + 1        return left \n\n搜索二维矩阵\n\n\n\n\n\n\n\n\n给你一个满足下述两条属性的 m x n 整数矩阵：\n\n每行中的整数从左到右按非严格递增顺序排列。\n每行的第一个整数大于前一行的最后一个整数。\n\n给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。\n74. 搜索二维矩阵\n暴力求解本题不适用，首先得确定目标值在元素中的哪一行，第一种方式是直接判断，在确定的行中在使用二分查找。第二种方式。\n① 直接当确定目标值的行之后 使用二分查找进行查找\nclass Solution:     def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:        # 遍历每一行，找到存在 target 的那一行        for nums in matrix:            if target &gt;= nums[0] and target&lt;=nums[-1]:                left,right = 0,len(nums)-1                while left &lt;=right:                    mid = (left+right)//2                    if nums[mid] == target:                        return True                    elif nums[mid] &gt; target:                        right = mid -1                    else:                        left = mid + 1                return False        return False\n\n②因为数组第一列的元素是有序的，因此可以先对数组第一列的元素进行二分查找，当然条件判断跟二分查找的条件不一样（此时不是值相等），然后针对那一行使用二分查找。\nclass Solution:     def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:        # 遍历每一行，找到存在 target 的那一行        m,n = len(matrix),len(matrix[0])        top,bottom = 0,m-1        row = -1         while top&lt;=bottom:            mid = (top+bottom)//2            if matrix[mid][0] &lt;= target &lt;=matrix[mid][-1]:                row = mid                break            elif matrix[mid][0] &gt; target:                bottom = mid - 1            else:                top = mid + 1        if row == -1:            return False        left,right = 0,n-1        while left&lt;=right:            mid = (left+right)//2            if matrix[row][mid] == target:                return True            elif matrix[row][mid] &gt;target:                right = mid -1            else:                left = mid + 1        return False\n\n在排序数组中查找元素的第一个和最后一个位置\n\n\n\n\n\n\n\n\n给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。\n34. 在排序数组中查找元素的第一个和最后一个位置\n搜索旋转排序数组\n\n\n\n\n\n\n\n\n整数数组 nums 按升序排列，数组中的值 互不相同 。\n在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 向左旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 下标 3 上向左旋转后可能变为 [4,5,6,7,0,1,2] 。\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。\n33. 搜索旋转排序数组\n寻找旋转排序数组中的最小值\n\n\n\n\n\n\n\n\n已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：\n\n若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]\n若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]\n\n注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。\n给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。\n你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\n153. 寻找旋转排序数组中的最小值\n寻找两个正序数组的中位数\n\n\n\n\n\n\n\n\n给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\n算法的时间复杂度应该为 O(log (m+n)\n4. 寻找两个正序数组的中位数\n","categories":["hot-100题"],"tags":["hot100-二分查找"]},{"title":"hot100题-哈希","url":"//post/hot100%E9%A2%98-%E5%93%88%E5%B8%8C.html","content":"两数之和（1）\n\n\n\n\n\n\n\n\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标\n1.两数之和\n①暴力解法 \n使用两层循环暴力进行解答\n②使用哈希表\n为啥要用到哈希表呢？ 在数组中查询时间复杂度太高，需要顺序查找，而哈希表可根据值快速查找\n\n\n\n\n\n\n\n\n\npython中字典也是哈希表的一种实现。定义哈希表后，遍历数组，如果目标值-当前值不在哈希表中，则将当前值以及对应的索引存入哈希表。如果能在哈希表中找到对应的值，则返回对应的下标\nclass Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        #定义哈希表 如果 target-当前元素不在哈希表中 就加入哈希表         t = &#123;&#125;        for i,num in enumerate(nums):            if target-num in t:                return [t[target-num],i]            t[num] = i        return \n\n字母异位词分组（49）49. 字母异位词分组\n\n\n\n\n\n\n\n\n\n给你一个字符串数组，请你将字母异位词组合在一起。可以按任意顺序返回结果列表。\n字母异位词组成单词相同，仅仅是位置不一样，可以建立哈希表，找到作为字母异位词的相同点作为哈希表的键，字母异位词的键值都是相等的，根据这一点，实现了不同的字母异位词的分类\n然后将每个字符串进行排序之后组合新的字符串作为哈希表的键，加入到哈希表中，这样就实现了不同的字母异位词的分类\n①将每个字符串按照字典顺序进行排序，排列组合成新的字符串作为哈希表的键\nclass Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        mp = defaultdict(list)  # 创建哈希表，value 默认是列表        for st in strs:            key = &quot;&quot;.join(sorted(st))  # 对字符串排序，得到 key            mp[key].append(st)         # 加入对应分组        return list(mp.values())       # 返回所有分组\n\n②计数，定义数组计算每个字符串字母出现的个数，组成字母异位词的字符个数是相等的，但是列表是可变的所以不能哈希，需要转化成元组才能哈希\nclass Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        mp = defaultdict(list)  # 创建哈希表，value 默认是列表        for st in strs:            counts = [0]*26            for ch in st:                counts[ord(ch)-ord(&quot;a&quot;)] += 1            mp[tuple(counts)].append(st)        return list(mp.values())       # 返回所有分组\n\n最长连续序列（128）128. 最长连续序列\n\n\n\n\n\n\n\n\n\n给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n本题目限制了时间复杂度为O(N)，因此不能使用排序。\n如果单独从列表找元素时间较长，因此先可以将列表转化为哈希集合，直接检索哈希结合，在找序列的时候也要注意就是，因为没有排序，那可能从当前位置x开始，可能x-1在哈希集合中因此如果x-1在哈希集合中，此时就跳过。\nclass Solution:    def longestConsecutive(self, nums: List[int]) -&gt; int:        #把nums转化成哈希集合        st = set(nums)        ans = 0        for x in st:            #如果x-1在集合里面 从x为起点 不如x-1为起点的序列长            if x-1 in st:                continue            y = x +1             #一直往后遍历 找到连续的序列            while y in st:                y += 1            ans = max(ans,y-x)        return ans \n\n","categories":["hot-100题"],"tags":["hot100-哈希"]},{"title":"hot100题-数组","url":"//post/hot100%E9%A2%98-%E6%95%B0%E7%BB%84.html","content":"最大子数组和(53)最大子数组和\n\n\n\n\n\n\n\n\n\n给一个整数数组 nums ，找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n开始想到使用滑动窗口来进行解题，发现在求解过程中，窗口大小不固定，没办法确定窗口长度，这里选择动态规划算法，对于每个位置 i，找到 nums[i] 结尾的最大子数组和(动态规划算法还需要强加学习)\nclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        n = len(nums)        dp = [0] * n  # dp[i] 表示以 nums[i] 结尾的最大子数组和        dp[0] = nums[0]        max_sum = dp[0]        for i in range(1, n):            # 状态转移公式            dp[i] = max(nums[i], dp[i-1] + nums[i])            # 更新全局最大值            max_sum = max(max_sum, dp[i])        return max_sum\n\n合并区间（56）合并区间\n\n\n\n\n\n\n\n\n\n以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 \n\n按照左端点进行排序  \n定义返回的列表  \n每次对当前子数组的值和列表中最后一个数组的尾部进行比较  \n如果当前子数组的 start &gt; 列表中最后一个的尾部，则不需要更新  \n如果当前子数组的 start &lt;&#x3D; 列表中最后一个的尾部，则需要更新列表中最后的尾部，取两者之间较大的值\n\nclass Solution:    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:        intervals.sort(key=lambda x:x[0])        merged = []        for interval in intervals:            if not merged or merged[-1][1] &lt; interval[0]:                #当前区间的start和最后的end 如果当前区间的start 大于 最后的end                #已存在最后的[0,1]  当前的[2,3] 没有重叠                merged.append(interval)            else:                #最后的[0,2]  当前的[1,2]  或者 最后的[0,2] 当前 [0,4]                 merged[-1][1] = max(interval[1],merged[-1][1])        return merged        \n\n轮转数组（189）轮转数组\n\n\n\n\n\n\n\n\n\n将整数数组向右轮转 k 个位置\n① 切片法  \n\nk 可能大于数组长度，因此对 k 取余  \n使用切片法：截取原数组后 k 个和除去数组后 k 个之前的进行拼接\n\nclass Solution:    def rotate(self, nums: List[int], k: int) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        #定义一个循环的数组 然后一直移动就可以        n = len(nums)        k %= n        nums[:] = nums[-k:]+nums[:-k]\n\n② 使用额外的数组  \n\n在原数组之后再加上一个一样的数组，然后进行截取\n\nclass Solution:    def rotate(self, nums: List[int], k: int) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        #定义一个循环的数组 然后一直移动就可以        n = len(nums)        if n==0:            return         k %= n        extend = nums+nums        rotated = extend[n-k:n-k+n]         nums[:] = rotated\n\n③ 数组翻转  \n\n将数组向右移动 k 次，尾部 k mod n 个元素会移动到数组头部，其余元素会向后移动 k mod n 个位置  \n先将所有元素翻转  \n再翻转 [0, k mod n−1] 区间和 [k mod n, n−1] 区间即可\n\n除自身以外数组的乘积（238）\n\n\n\n\n\n\n\n\n给一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 \n除自身以外数组的乘积\n① 暴力解法  \n\n两层循环进行解答，但是会超时\n\n② 前后缀积  \n\n分别计算左前缀和右前缀，然后进行相乘\n\nclass Solution:    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:        n = len(nums)        left ,right, res = [0]*n,[0]*n,[0]*n        #计算第i个位置的左前缀积        left[0] = 1        for i in range(1,n):            left[i] = left[i-1]*nums[i-1]        #计算第i个位置的右前缀积        right[n-1] = 1        for i in reversed(range(n-1)):            right[i] = right[i+1]*nums[i+1]        #分别将左前缀和右前缀对应进行相乘        for i in range(n):            res[i] = left[i]*right[i]        return res\n\n缺失的第一个正数(41)\n\n\n\n\n\n\n\n\n已知一个未排序的整数数组 nums ，找出其中没有出现的最小的正整数\n缺失的第一个正数\n数组有N个元素，对应索引值为0~n-1，并设置标记。如果当前的值小于n，那么将其n-1位置上面的元素做标记，如设置为负数， 如果全部被标记 ，那返回的就是n+1 ，反之，那就是第一个正数的位置 （因为其中有负数或者大于n的数 ，这样初始处理就是将这些数设置为n+1 ）\nclass Solution:    def firstMissingPositive(self, nums: List[int]) -&gt; int:        n = len(nums)        #忽略无用数        for i in range(n):            if nums[i]&lt;=0 or nums[i] &gt; n :                nums[i] = n+1        #进行标记        for i in range(n):        #为啥要取绝对值呢  因为如果是3  4 6 5  当遍历到3时候，会修改后续位置为 3 4 -6 5，所以需要取绝对值，避免索引值为负数            num = abs(nums[i])            if num &lt;= n:                nums[num-1] = -abs(nums[num-1])        for i in range(n):            if nums[i]&gt;0:                return i+1        return n+1\n\n","categories":["hot-100题"],"tags":["hot100-数组"]},{"title":"hot100题-双指针","url":"//post/hot100%E9%A2%98-%E5%8F%8C%E6%8C%87%E9%92%88.html","content":"移动零（283）283. 移动零\n\n\n\n\n\n\n\n\n\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n①两次单循环，一次用于将数组中大于0的数移动到首部，然后另一次将后面的值补上0\nclass Solution:    def moveZeroes(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        k = 0        for i in range(len(nums)):            if nums[i]:                nums[k] = nums[i]                k += 1        for i in range(k,len(nums)):            nums[i] = 0\n\n②使用快慢双指针，快慢指针都是从头开始，快指针出发去寻找大于0的数（只有在大于0的时候才进行交换），然后左指针指向为0的数或者就是大于0 的数，交换两个元素的值，然后左指针右移动。右指针左侧一直到左指针，中间都是0。（如果都是正数，那本质就是自己跟自己交换，左右指针同时移动）\nclass Solution:    def moveZeroes(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        #双指针        n = len(nums)        left = right = 0        for right in range(n):            if nums[right]:                nums[left],nums[right] = nums[right],nums[left]                left += 1          \n\n\n\n盛水最多的容器（11）11. 盛最多水的容器\n\n\n\n\n\n\n\n\n\n给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。\n找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n返回容器可以储存的最大水量。（说明：你不能倾斜容器。）\n①暴力法 （会超时）\n固定左端点不动，右端点不断左移动，计算容积\nclass Solution:    def maxArea(self, height: List[int]) -&gt; int:        # 确定两个位置 可以容纳最多的水 就是两个位置的距离之差 乘以最小的高度        # 不能排序 什么时候更新指针的移动难点         n = len(height)        res = 0        for left in range(n):            right = n-1            while left &lt; right:                v = (right - left)* min(height[right],height[left])                  right -= 1                res = max(res,v)        return res\n\n②双指针\n本题最难的点就是双指针的移动策略，因为容积计算是两个位置距离之差，乘以最小的高度，因此本题目的移动策略就是移动最小的高度，因为长的那一边即使不动，高度还是由短的那边决定。 \nclass Solution:    def maxArea(self, height: List[int]) -&gt; int:        # 确定两个位置 可以容纳最多的水 就是两个位置的距离之差 乘以最小的高度        # 不能排序 什么时候更新指针的移动难点         n = len(height)        res = 0        left,right = 0,n-1        while left &lt; right:            v = (right - left)*min(height[right],height[left])              res = max(res,v)            if height[left]&lt;height[right]:                left += 1            else:                right -= 1        return res\n\n三数之和（15）15.三数之和\n\n\n\n\n\n\n\n\n\n给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。（答案中不可以包含重复的三元组）\n①暴力破解  三重循环  问题：超时 、需要去重（通过不了）\nclass Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        #暴力破解  三重循环进行 问题是：时间问题 而且还要去重        res = []        n = len(nums)        for i in range(n):            for j in range(i+1,n):                for k in range(j+1,n):                    if nums[i]+nums[j]+nums[k]==0:                        res.append([nums[i], nums[j], nums[k]])        result = set(tuple(sorted(x)) for x in res)        return [list(x) for x in result]\n\n②双指针移动\n因为本题目不能留下重复的三元组，所以将数组进行排序，然后遇到重复的数进行跳过，然后从当前位置i开始，区间为i+1~n-1，不断去遍历，当满足条件的值就加入列表，如果不满足，则指针进行移动，如果小于0，说明左边的数太小了，左指针需要右移动；如果大于0，说明右边的数太大了，右指针需要往左移动，直至满足条件\nclass Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        #双指针  排序 去重        res = []        #排序         nums.sort()        n = len(nums)        for i in range(n):            #跳过重复的值            if i&gt;0 and nums[i] == nums[i-1]:                continue            #左指针从i+1的位置开始  右指针从最后的位置开始            l,r = i+1,n-1            while l&lt;r:                s = nums[i]+nums[l]+nums[r]                if s==0:                    res.append([nums[i], nums[l], nums[r]])                    while l&lt;r and nums[l] ==nums[l+1]:                        l += 1                    while l&lt;r and nums[r] == nums[r-1]:                        r -= 1                    l += 1                    r -= 1                elif s&lt;0:                    l += 1                else:                    r -= 1        return res\n\n\n\n接雨水（42）42. 接雨水\n\n\n\n\n\n\n\n\n\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n 某一位置的积水量 &#x3D; min(左边最高柱子, 右边最高柱子) - 当前高度\n双指针解法：\n首先确定了某一位置的积水量计算公式之后，那么重点就是确定左边和右边的最高柱子。使用双指针从两侧往中间进行，如果当前左高度小于右边的高度，说明此时可以计算左边的积水，此时公式就是左边的最高柱子的高度-当前高度，但是如果当前的高度大于左侧的最高高度，那么是不能积水的（因为水要依靠比它更高的墙才能积起来，如果当前位置本身就是新最高的墙，那么这里是不会积水的），此时只能更新左侧的最高高度。同理，右侧也如此\n\n\n\n\n\n\n\n\n\n开始有困惑，我理解了对于每个位置来说的积水量的计算，取决于它左右最高的柱子（决定的还是左右两侧低的柱子）。使用双指针的时候，计算的事局部最高墙，不理解。后面借助AI的提示。想象水从上往下落，左边最高墙挡住了水，当前柱子比左边墙高 → 水直接落在它两侧，不会在它顶上停留，所以只要局部左边最高墙等于或小于当前位置，当前位置就不会积水\nclass Solution:    def trap(self, height: List[int]) -&gt; int:        #问题 雨水的位置 怎么计算雨水        n = len(height)        left_max = right_max = 0        res = 0         left,right = 0,n-1        while left &lt; right:            #说明此时可以计算左侧的积水            if height[left]&lt;height[right]:                if height[left] &gt; left_max:                    #说明当前位置是局部最高墙  不会积水                    left_max = height[left]                else:                    res += left_max -height[left]                left += 1            else:                if height[right] &gt; right_max:                    #说明当前位置是局部最高墙  不会积水                    right_max = height[right]                else:                    res += right_max -height[right]                right -= 1        return res\n\n\n\n","categories":["hot-100题"],"tags":["hot100-双指针"]},{"title":"python 依赖管理","url":"//post/python-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86.html","content":"\n\n\n\n\n\n\n\n\n本文主要介绍python中虚拟环境管理的另一种方式uv，开始接触深度学习conda用得比较多，后面发现有的项目是用uv进行环境管理，因此简单介绍一下这种方式。我的理解就是conda和uv都可以用来创建虚拟环境，如果是深度学习项目可使用conda建立虚拟环境，uv来下载依赖。其余的如web项目都可以使用uv来建立环境来进行管理依赖\nPython-uv虚拟环境管理uv简介uv和conda一样是python中的包管理工具，与其他Python中的包管理工具相比，uv更像是一个全能选手，有以下优势：\n\n速度快\n统一管理 Python 版本\n自动解决依赖冲突\n跨平台一致性\n\nuv工具主要使用的两个文件：\npyproject.toml：定义项目的主要依赖，包括项目名称、版本、描述、支持的 Python 版本等信息uv.lock：记录项目的所有依赖，包括依赖的依赖，且跨平台，确保在不同环境下安装的一致性。由 uv 自动管理，不用手动编辑\nuv安装\n\n\n\n\n\n\n\n\n主要介绍在windows uv的安装，以及uv建立虚拟环境，下载依赖\n# On Windows.powershell -ExecutionPolicy ByPass -c &quot;irm https://astral.sh/uv/install.ps1 | iex&quot;# With pip.pip install uv\n\nuv使用# 创建指定 Python 版本的环境uv venv --python=3.11 myenv# 从 requirements.txt 安装（带哈希校验！）uv pip install -r requirements.txt# 生成精简版依赖uv pip compile requirements.in -o requirements.txt# 查看当前环境已安装的依赖uv pip list#安装依赖并写入 pyproject.tomluv add requests #移除依赖uv remove requests #同步依赖到虚拟环境uv sync #导出 lock 文件为 requirements.txt 等格式uv export #构建源码包和 wheeluv build发布到 PyPI #发布到 PyPIuv publish \n\nuv安装并设置镜像\nuv使用\n相关资料python环境管理大比拼\nuv管理\n","categories":["python"],"tags":["python环境管理"]},{"title":"hot100题-滑动窗口","url":"//post/hot100%E9%A2%98-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.html","content":"滑动窗口（定长、不定长、多指针）定长的滑动窗口三步走  入–更新–出\n入：下标为 i 的元素进入窗口，更新相关统计量。如果 i&lt;k−1 则重复第一步。\n更新：更新答案。一般是更新最大值&#x2F;最小值。\n出：下标为 i−k+1 的元素离开窗口，更新相关统计量。\n思考：先找到前面k-1个元素，然后进入的元素与前面的k-1的元素成定长窗口，然后前面的元素出，后面的元素进入\n解决循环数组问题 可以使用扩展数组 将数组扩大一倍 \n滑动窗口模版题\n\n\n\n\n\n\n\n\n&#x2F;&#x2F;外层循环扩展右边界，内层循环扩展左边界 \nfor (int l &#x3D; 0, r &#x3D; 0 ; r &lt; n ; r++) { \n​\t&#x2F;&#x2F;当前考虑的元素 \t\nwhile (l &lt;&#x3D; r &amp;&amp; check()) {&#x2F;&#x2F;区间[left,right]不符合题意 &#x2F;&#x2F;扩展左边界 } &#x2F;&#x2F;区间[left,right]符合题意，统计相关信息 }\n无重复字符的最长子串（3）\n\n\n\n\n\n\n\n\n3. 无重复字符的最长子串\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。\n本题使用滑动窗口的思想，满足条件时进入窗口，当条件不满足时，移动窗口的值，然后更新相关的值。使用 list 里的 in 和 pop(0) 操作时间复杂，因此合理的方式是使用哈希集合+滑动窗口\n①列表+滑动窗口\nclass Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        #定义列表 如果当前字符不在列表中 则进入列表        #如果在列表中 需要循环删除 直到当前字符不在列表中        t = []        res = 0        for i in range(len(s)):            while s[i] in t:                t.pop(0)   #删除之前的值 使得当前加入的值             t.append(s[i])            res = max(res,len(t))        return res\n\n②哈希集合+滑动窗口\nclass Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        #使用滑动窗口+双指针进行维护         char_set = set()        l = 0        res = 0        for r in range(len(s)):            while s[r] in char_set:   # 如果重复，就缩小窗口                char_set.remove(s[l])                l += 1            char_set.add(s[r])            res = max(res, r - l + 1)  # 更新窗口最大长度        return res\n\n\n\n找到字符串中所有字母异位词（438）\n\n\n\n\n\n\n\n\n438. 找到字符串中所有字母异位词\n给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n本题使用滑动窗口+计数的方式来进行，维持一个维持一个 跟字符串p长度相等的滑动窗口，然后转化成字符列表进行计算来判断是否是异位词\nclass Solution:    def findAnagrams(self, s: str, p: str) -&gt; List[int]:        #维持一个 跟字符串p长度相等的 滑动窗口        #转化成字符列表或者哈希表来比较滑动窗口组成的值和字符串p是否是异位词        s_len,p_len = len(s),len(p)        if s_len &lt; p_len:            return []        ans = []        p_count = [0]*26        s_count = [0]*26        for i in range(p_len):            s_count[ord(s[i])-ord(&#x27;a&#x27;)]+= 1            p_count[ord(p[i])-ord(&#x27;a&#x27;)]+= 1        if s_count==p_count:            ans.append(0)        for i in range(s_len-p_len):            #把下标为i的数去掉            s_count[ord(s[i])-ord(&#x27;a&#x27;)]-= 1            #加入下标为i+p_len的数 此时区间就为 [i+1,i+p_len]            s_count[ord(s[i+p_len])-ord(&#x27;a&#x27;)]+= 1            if s_count==p_count:                #如果相等 则将首部索引加入                ans.append(i+1)                    return ans          \n\n","categories":["hot-100题"],"tags":["hot100-滑动窗口"]},{"title":"python哈希","url":"//post/python%E5%93%88%E5%B8%8C.html","content":"\n\n\n\n\n\n\n\n\n本文是借助ChatGPT结合总结的关于哈希相关的知识，以及哈希表的相关定义和使用，帮助理解哈希表的作用以及哈希表的使用场景\nPython中的哈希哈希的含义哈希的含义是把 任意长度的数据（如字符串、数字、对象）通过 哈希函数（Hash Function），转换成一个 固定长度的整数，通常用作 索引或标识。\n哈希函数的作用：把数据“映射”到一个整数，用这个整数可以在数组或表里快速找到对应位置\n哈希表（Hash Table）哈希表是哈希的最常见应用：\n\n由 数组 + 哈希函数 构成\n使用 key 的哈希值快速找到 value 的存储位置\n插入&#x2F;查找&#x2F;删除平均时间复杂度 O(1)\n\nkey = &quot;apple&quot;hash(&quot;apple&quot;) = 7  → 存在数组索引 7value = 5\n\n哈希表基础哈希表（Hash Table） 是一种 基于键值映射的数据结构，核心特点：\n\n键（key） → 哈希函数 → 数组索引 → 值（value）\n查找、插入、删除平均时间复杂度 O(1)\nPython 内部使用 开放寻址 + 链表&#x2F;红黑树 来处理冲突\n\nkey=&quot;apple&quot; → hash(&quot;apple&quot;) → 索引 7 → value=5key=&quot;banana&quot; → hash(&quot;banana&quot;) → 索引 3 → value=2\n\ndict（字典）Python中内置的哈希表类型\nkey：不可变的类型（int，str，tuple）\nvalue：任意类型\nscores = &#123;&quot;Alice&quot;: 90, &quot;Bob&quot;: 85&#125;print(scores[&quot;Alice&quot;])  # 90scores[&quot;Charlie&quot;] = 92  # 新增\n\ndefaultdict（带默认值的字典）来自来自 collections 模块，工厂函数指定默认值类型\n常用类型：\n\nint → 默认 0，用于计数\nlist → 默认 []，用于分组\nset → 默认 set()，用于去重\n\nfrom collections import defaultdict# 计数cnt = defaultdict(int)for ch in &quot;abracadabra&quot;:    cnt[ch] += 1print(cnt)  # &#123;&#x27;a&#x27;:5, &#x27;b&#x27;:2, &#x27;r&#x27;:2, &#x27;c&#x27;:1, &#x27;d&#x27;:1&#125;# 分组groups = defaultdict(list)words = [&quot;eat&quot;,&quot;tea&quot;,&quot;tan&quot;,&quot;ate&quot;,&quot;nat&quot;,&quot;bat&quot;]for w in words:    key = &quot;&quot;.join(sorted(w))    groups[key].append(w)print(groups.values())  # [[&#x27;eat&#x27;,&#x27;tea&#x27;,&#x27;ate&#x27;], [&#x27;tan&#x27;,&#x27;nat&#x27;], [&#x27;bat&#x27;]]\n\nCounter（计数器）\ncollections.Counter 是 dict + int 封装的计数工具\n功能：统计元素频率，直接返回哈希表\n\nfrom collections import Counters = &quot;abracadabra&quot;cnt = Counter(s)print(cnt)  # &#123;&#x27;a&#x27;:5,&#x27;b&#x27;:2,&#x27;r&#x27;:2,&#x27;c&#x27;:1,&#x27;d&#x27;:1&#125;\n\nset（集合）哈希实现的无序集合，元素唯一、查找快速，常用于去重、快速判断元素是否存在\nnums = [1,2,2,3,4,4,5]s = set(nums)print(s)  # &#123;1,2,3,4,5&#125;print(3 in s)  # True\n\n哈希使用场景\n\n\n场景\n常用类型\n说明\n\n\n\n元素去重\nset\n判断元素是否存在\n\n\n计数&#x2F;频率统计\ndict / Counter / defaultdict(int)\n统计出现次数\n\n\n分组&#x2F;归类\ndefaultdict(list)\n通过 key 分组元素\n\n\n查找&#x2F;索引映射\ndict\nkey → value 快速查找\n\n\n注意事项Python 中的哈希表主要是 dict、defaultdict、set、Counter\n核心思想：key → hash → 索引 → value\n\nkey 必须可哈希（不可变类型）\n哈希表顺序：Python 3.7+ 保留插入顺序\n冲突处理：Python 内部自动解决，一般不需要手动处理\n空间换时间：哈希表使用额外内存来换取 O(1) 查找速度\n\n","categories":["python"],"tags":["python哈希"]},{"title":"transformer学习","url":"//post/transformer%E5%AD%A6%E4%B9%A0.html","content":"Transformer1. Transformer 主要结构及对比 RNN编码器（Encoder）编码器由多个相同的编码器层堆叠而成，每一层包含以下部分：\n\n多头自注意力机制（Multi-Head Self-Attention）：通过多个注意力头从不同角度学习词与词之间的关系。\n前馈神经网络（Feed-Forward Neural Networks）：对注意力机制的输出进行非线性变换，增强模型的表达能力。\n残差连接和层归一化（Residual Connection &amp; Layer Normalization）：帮助信息流动并稳定训练过程，防止梯度消失。\n\n解码器（Decoder）解码器与编码器类似，但每层解码器额外包含以下机制：\n\n掩蔽多头自注意力机制（Masked Multi-Head Attention）：用于处理目标序列，通过掩码防止当前位置关注未来位置，确保生成过程的自回归特性。\n\n编码器 - 解码器注意力机制（Encoder-Decoder Attention）：使解码器能够关注编码器输出的上下文信息，建立输入与输出序列之间的关联。\n\n前馈神经网络（Feed-Forward Neural Network）：对注意力机制的输出进行非线性变换，增强解码器的表达能力。\n\n\n\n\n对比 RNN\n优点：\n并行化：取消递归结构，Transformer 允许序列中的所有位置同时处理，而 RNN 是逐步处理的，这使得 Transformer 能在训练过程中实现并行化，从而大幅加速训练。\n长距离依赖：RNN 在处理长序列时，容易出现梯度消失或梯度爆炸的问题，而 Transformer 通过自注意力机制能够直接捕捉到序列中任意位置的依赖关系。（引入位置编码， 在不依赖 RNN 结构的情况下，通过位置编码为序列中的每个元素嵌入位置信息，从而使模型能够感知输入的顺序）\n计算效率：Transformer 在每一层的计算是对称的，计算效率较高，且可以扩展到大规模的训练数据。\n\n\nRNN 的缺点：\n训练速度慢：由于其顺序处理的特点，RNN 的计算速度较慢，无法进行高效并行。\n长程依赖问题：RNN 在捕捉长期依赖时表现较差，通常会遭遇梯度消失或爆炸问题，导致学习效果不佳。\n\n\n\n2. 为什么要进行位置嵌入（Positional Encoding）？位置嵌入的作用Transformer 不像 RNN 那样天然具有序列顺序的处理能力，因此需要通过位置嵌入来为模型提供位置信息，使其能理解输入数据的顺序。\n位置嵌入的方式最常用的方式是通过 正弦和余弦函数 来生成位置嵌入。具体做法是为每个位置计算一个向量，使用不同频率的正弦和余弦函数来表示不同位置的信息。这个方式的优点是它可以在不依赖训练的情况下生成，且具有很好的可扩展性。\ntransformer 的自注意力机制（Self-Attention）是位置无关（position-agnostic）的。也就是说，如果不做任何处理，模型无法区分 “我爱你” 和 “你爱我” 这两个句子的差异，因为自注意力机制只关注 token 之间的相关性，而不考虑它们在序列中的顺序。\n为了让模型感知到 token 的位置信息，Transformer 引入了位置编码。\n在原始论文中，Transformer 使用的是固定位置编码（Positional Encoding），其公式如下：\n\n\n其中：\npos 表示位置索引（Position）。\ni 表示维度索引。\ndmodel 是嵌入向量的维度。\n流程：输入的是一个整数索引（位置序号 0,1,2,…）。位置编码模块先把这些整数映射成与词向量同维度的向量（例如 512 维），再把结果加到词向量上。\n如何理解位置嵌入\nhttps://www.zhihu.com/question/347678607\n3. 自注意力机制自注意力机制的作用\n随着模型处理输入序列的每个单词，自注意力会关注整个输入序列的所有单词，帮助模型对本单词更好地进行编码。在处理过程中，自注意力机制会将对所有相关单词的理解融入到我们正在处理的单词中。更具体的功能如下：\n序列建模：自注意力可以用于序列数据（例如文本、时间序列、音频等）的建模。它可以捕捉序列中不同位置的依赖关系，从而更好地理解上下文。这对于机器翻译、文本生成、情感分析等任务非常有用。\n并行计算：自注意力可以并行计算，这意味着可以有效地在现代硬件上进行加速。相比于RNN和CNN等序列模型，它更容易在GPU和TPU等硬件上进行高效的训练和推理。（因为在自注意力中可以并行的计算得分）\n长距离依赖捕捉：传统的循环神经网络（RNN）在处理长序列时可能面临梯度消失或梯度爆炸的问题。自注意力可以更好地处理长距离依赖关系，因为它不需要按顺序处理输入序列。\n\nQ, K, V 的含义\nQ（Query）：查询向量，表示当前关注的词。\nK（Key）：键向量，表示其它词的特征。\nV（Value）：值向量，表示与键向量关联的实际信息。\n\n注意力分数计算公式\n\n\n\n注意力分数的计算方式是通过 Q 和 K 的点积 来衡量 Query 与 Key 之间的相关性。计算公式为：其中，d_k 是 K 向量的维度，* 表示矩阵乘法，softmax 用于标准化分数，使其成为概率分布。\n问题：为什么要除以dk？\n当 dk 较大时，点积的数值可能会过大，导致 Softmax 过后的梯度变得极小\n\n\n\n\n\n\n\n\n\n\nSoftmax函数\n\n在 Transformer 模型中，Softmax 函数不仅在计算注意力权重时用到，在预测阶段的输出处理环节也会用到，因为预测 token 的过程可以看成是多分类问题。\nSoftmax或称归一化指数函数，它将每一个元素的范围都压缩到（0，1）之间，并且所有元素的和为1\n最后经过线性层后进入softmax函数，将每个值向量乘以softmax分数(这是为了准备之后将它们求和)。这里的直觉是希望关注语义上相关的单词，并弱化不相关的单词(例如，让它们乘以0.001这样的小数)。\nSoftmax 通过指数变换放大数值间的差异，让较大的值对应更高的概率，同时避免了负值和数值过小的问题，让模型聚焦于权重最高的位置，同时保留全局信息（低权重仍非零）\n4. 多头注意力机制多头注意力机制就是存在多个不同的权重矩阵（Q、K、V），形成多个矩阵 Z，再把它们 按最后一维（hidden）拼接（concat）→ 做一次线性变换 得到最终输出。\n线性层把拼接后的多头结果 Z_concat（形状 batch×seq×d_model）重新线性映射回与输入相同的维度，同时让网络可以学习如何融合不同头的信息。\n\n\n\n\n\n\n\n\n\n\n5. 残差层和归一化层的作用Add（残差连接，Residual Connection）残差连接是一种跳跃连接（Skip Connection），它将层的输入直接加到输出上（观察架构图中的箭头）：\nAdd，就是在z的基础上加了一个残差块X，加入残差块的目的是为了防止在深度神经网络的训练过程中发生退化的问题，退化的意思就是深度神经网络通过增加网络的层数，Loss逐渐减小，然后趋于稳定达到饱和，然后再继续增加网络层数，Loss反而增大\n\n\n通过直接将输入添加到输出中，帮助缓解深度网络中的梯度消失问题，保证信息能够有效流动。这种连接方式有效缓解了深层神经网络的梯度消失问题\nResNet残差神经网络为了了解残差块，我们引入ResNet残差神经网络，神经网络退化指的是在达到最优网络层数之后，神经网络还在继续训练导致Loss增大，对于多余的层，我们需要保证多出来的网络进行恒等映射。只有进行了恒等映射之后才能保证这多出来的神经网络不会影响到模型的效果。残差连接主要是为了防止网络退化。\n\n\n上图就是构造的一个残差块，X是输入值，F（X）是经过第一层线性变换后并且激活的输出，在第二层线性变化之后，激活之前，F（X）加入了这一层输入值X，然后再进行激活后输出。\n要恒等映射，我们只需要让F（X）&#x3D;0就可以了。x经过线性变换（随机初始化权重一般偏向于0），输出值明显会偏向于0，而且经过激活函数Relu会将负数变为0，过滤了负数的影响。这样当网络自己决定哪些网络层为冗余层时，使用ResNet的网络很大程度上解决了学习恒等映射的问题，用学习残差F(x)&#x3D;0更新该冗余层的参数来代替学习h(x)&#x3D;x更新冗余层的参数。\nNorm（层归一化，Layer Normalization）用于将每一层的输出进行标准化，保持均值为 0，方差为 1。它有助于加速训练，并且提高模型的稳定性。 使用到的归一化方法是Layer Normalization)\nLN是在同一个样本中不同神经元之间进行归一化，而BN是在同一个batch中不同样本之间的同一位置的神经元之间进行归一化。BN是对于相同的维度进行归一化，但是咱们NLP中输入的都是词向量，一个300维的词向量，单独去分析它的每一维是没有意义地，在每一维上进行归一化也是适合地，因此这里选用的是LN。\n  \n\n\n\n6. 前馈神经网络 Position-wise Feed-Forward Networks（FFN）\n\n在 Transformer 中，前馈网络层（Feed-Forward Network，FFN）的作用可以概括为一句话： “对每个位置的向量进行非线性变换，增加模型的表达能力。\n全连接层是一个两层的神经网络，先线性变换，然后ReLU非线性，再线性变换。这两层网络就是为了将输入的Z映射到更加高维的空间中然后通过非线性函数ReLU进行筛选，筛选完后再变回原来的维度经过6个encoder后输入到decoder中。\n7. 三种注意力对比学习（三种注意力）Masked Attention、Self-Attention 和 Cross-Attention 的本质是一致的，这一点从代码调用可以看出来，三者的区别在于未来掩码的使用和输入数据的来源：\n\nMasked Attention：用于解码过程，通过掩码屏蔽未来的时间步，确保模型只能基于已生成的部分进行预测，论文中解码器部分的第一个 Attention 使用的是 Masked Self-Attention。\n\nSelf-Attention：查询、键和值矩阵来自同一输入序列，模型通过自注意力机制学习输入序列的全局依赖关系。\n\nCross-Attention：查询矩阵来自解码器的输入，而键和值矩阵来自编码器的输出，解码器的第二个 Attention 模块就是 Cross-Attention，用于从编码器输出中获取相关的上下文信息。\n以机器翻译中的中译英任务为例：对于中文句子 “中国的首都是北京”，假设模型已经生成了部分译文  “The capital of China is”，此时需要预测下一个单词。\n在这一阶段，解码器中的交叉注意力机制会使用当前已生成的译文 “The capital of China is” 的编码表示作为查询，并将编码器对输入句子 “中国的首都是北京” 编码表示作为键和值，通过计算查询与键之间的匹配程度，生成相应的注意力权重，以此从值中提取上下文信息，基于这些信息生成下一个可能的单词（token），比如：“Beijing”。\n\n\n需要掩码注意力的原因在解码阶段，每一步生成的词语只依赖于前面已生成的词语。因此，需要通过 掩码（Masking） 来确保每个位置的注意力只关注其前面的位置，而不允许查看未来的位置。\n输入需要编码器的输入的原因解码器需要编码器的输出作为上下文信息来生成最终的目标序列。编码器提供的上下文信息有助于解码器更好地理解输入序列的语义和结构。\n解码器和编码器的输出\n编码器的输出：编码器生成的隐藏状态序列，包含了输入序列的语义信息。这些信息将被解码器用于生成最终的输出。\n解码器的输出：解码器根据编码器的输出和已生成的部分输出，逐步生成目标序列（首先经过一次线性变换（线性变换层是一个简单的全连接神经网络，它可以把解码组件产生的向量投射到一个比它大得多的，被称为对数几率的向量里），然后Softmax得到输出的概率分布（softmax层会把向量变成概率），然后通过词典，输出概率最大的对应的单词作为我们的预测输出。）\n\n8. GPT与 Transformer 的关系GPT，即 Generative Pre-Training Language Model，是由 OpenAI 团队于 2018 年发布的预训练语言模型。虽然学界普遍认可 BERT 作为预训练语言模型时代的代表，但首先明确提出预训练 - 微调思想的模型其实是 GPT。\nGPT 提出了通用预训练的概念，也就是在海量无监督语料上预训练，进而在每个特定任务上进行微调，从而实现这些任务的巨大收益。虽然在发布之初，由于性能略输于不久后发布的 BERT，没能取得轰动性成果，也没能让 GPT 所使用的 Decoder-Only 架构成为学界研究的主流，但 OpenAI 团队坚定地选择了不断扩大预训练数据、增加模型参数，在 GPT 架构上不断优化，最终在 2020 年发布的 GPT-3 成就了 LLM 时代的基础，并以 GPT-3 为基座模型的 ChatGPT 成功打开新时代的大门，成为 LLM 时代的最强竞争者也是目前的最大赢家。\n9. 相关资料Transformer 论文精读\nCSDN博客文章\nTransformer快速入门\n","categories":["transformer"],"tags":["AI"]},{"title":"从当下开始","url":"//post/%E4%BB%8E%E5%BD%93%E4%B8%8B%E5%BC%80%E5%A7%8B.html","content":"对学历的理解本硕双非，曾经的理解，双非就像一个标签刻在自己身上，也是会有一种想法，觉得考上双非特别是研究生，是不是落后别人一大截，怎么挺身而出？其实在现在看来，我不会这么想了，每个人都会有自己的一段路程，在读研的过程中，我深刻体会到需要自洽、自强，好的学历会接触更多优秀的人、有更好的资源，强大的开始就是对学历祛魅跟自己和解，找到自己的舒服方式，接触更多优秀的人，让自己有实力有能力去接受挑战，双非不是标签，理性看待学历，专注于自身硬实力和软实力的成长。\n对自律的理解最近在寻找 AI 相关资料时，看到了一个博主的技术博客，特别是博主写的碎碎念。我开始深思：自己在过去的一段时间里，好像不太明白学习的目的究竟是什么，没有明确坚定的方向，学习似乎更多是为了感动自己。我开始思考何为自律，是自愿的学习，还是仅仅担忧未来是否能够有一个好的事业。回头想想，我没有坚持培养积极的爱好，容易陷入误区。\n我也看到许多高考励志的故事，或许在今后的路上，我再也不会指责过去的自己。无论结果如何，如果可以再来一次，我可能会走上相似的道路，经历相似的挑战。\n关于学习与成长我很喜欢阅读美文，自己表达的能力并不强，常常遇到一些好的文章或句子时，会将它们收藏起来。在业余时间，我会选择去阅读书籍，这是之前的领导给我的建议，很多事情其实可以在书中找到答案。虽然一些道理我已经看过很多遍，但真正能执行下去的却并不多。\n从这么长时间的读书生涯中，我意识到自己并不是一个特别擅长学习的人，对自己的专业也没有特别深的热爱。有时候，学习并没有深入专研，我一直处于输入阶段，却没有足够的输出。与此同时，我也意识到软实力同样重要——交际表达、为人处事等等。\n未来的路在今后的日子里，可能我会走得比较慢，但我依然希望不负当下的时光，成为一个更好的自己。我会向优秀的人学习，跳出眼前的视野，继续前行。\n","categories":["碎碎念念"],"tags":["碎碎念念"]},{"title":"python相关","url":"//post/python%E7%9B%B8%E5%85%B3.html","content":"装饰器\n"},{"title":"大模型基础","url":"//post/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80.html","content":""},{"title":"实习感想","url":"//post/%E5%AE%9E%E4%B9%A0%E6%84%9F%E6%83%B3.html","content":"实习感受在不知不觉中，实习已经有一个多月的时间了，简单概括一下这段经历。\n回想起在找实习的这段时间里，心里还是很没底的，坦白说我的简历项目全是网上 Copy 的，接触 AI 这个方向也是因为小红书上面的博主分享的一些经历，跟着博主的路径，了解到 AI 应用开发这个新的方向，目前赛道还不是很卷。之前也接触过 AI 低代码平台，想着试一试。\n公司是一个比较大一点的外包公司，要说有啥活，倒是真的没啥活，项目也不是很多。坦白说，要想在这个公司学点高一点的技术还是很难的，部门主要是后端开发的部分，AI 刚刚起步。目前做的相关技术就是 LangChain 实现 RAG 系统，Python 后端相关的技术，暂时还没有涉及到大模型微调和 RAG 优化技术。\n最后想对自己说，确实是先出发很重要，慢慢认识自己，定目标，达到成就，有责任感，让自己充满力量去抵御未知的困难。最后呢，还是挺感恩每一次的遇见，记录每个阶段的感受，达成阶段性可实现的目标和计划，最后也要好好生活，认真对待当下的时光。\n\n\n\n\n\n\n\n\n\n在 8 月也和前同事一起交流了，他也告诉我很多道理，但是呢，有的时候其实确实得自己去经历去感受一些事情。比如学会做实事、定阶段性的目标和规划、学会理财（当然得先有资本，但得有意识）\n\n","categories":["实习"],"tags":["实习感想"]},{"title":"王阳明：知行合一的智慧","url":"//post/%E7%8E%8B%E9%98%B3%E6%98%8E%EF%BC%9A%E7%9F%A5%E8%A1%8C%E5%90%88%E4%B8%80%E7%9A%84%E6%99%BA%E6%85%A7.html","content":"王阳明：知行合一的智慧简介王阳明是明代“心学”的集大成者，他以“心即理”“知行合一”“致良知”的思想，开创了影响深远的哲学体系。阳明心学融汇儒释道三家智慧，启人自省、修身立德，揭示了心性与实践的统一之道。本书由国内知名心学专家罗智倾心撰写，凝结三年研究心血，以通俗而深刻的笔触，带领读者理解阳明心学的精神内核，体悟知行合一的真义，修炼笃定自信的心智，开启充盈而自在的人生。\n\n\n\n\n\n\n\n\n\n感受：断断续续的看完了这一本书，但是自己对于本书所有传递的道理和精髓没有很好的体会，于是决定在读一遍，认真读几遍，然后记录下自己的感想。先认识到，再去执行，认识是行动的开始。\n阅读笔记（一）\n\n\n\n\n\n\n\n\n时间 ：2025&#x2F;10&#x2F;25\n第一章：立志乃完事之本            \n本书第一章要传达的核心，是“树立志向是成功的根本”，以及在实现目标的过程中所必备的品质。我们生活在一个物质丰富、诱惑无处不在的时代，如果没有足够的定力与清醒，很容易被外界牵着走，从而忘记自己最初想做的事。每个人都有不同的追求，或渴望外在的富足，或追求内心的宁静。然而，在欲望与诱惑面前，唯有坚定志向、专注前行，才能不偏离轨道，真正做到“业精于勤”，实现心中所想。\n确定坚定的志向\n书中提到，一个人要想达到人生中的目标，首先得树立坚定的志向。说到这一点，我也深受感受，举一个例子，我的本科室友当初在考研的时候就树立要考211大学，而且就为了这个目标真的全身心投入，最后终于成功了。但是我呢，我在这个其中有一些个人的原因，遇到一些问题，然后缺乏正向的思维，导致我失败了。坚定的志向我认为很重要，好比指南针，指引前进的方向。为什么要强调坚定呢？上面是我自己的一个例子，坚定的志向，就是强大的能量，有的时候会发现身边的大家可能都差不多，为啥后面会那么优秀呢？在努力追求梦想、志向的过程中，会遇到各种因素如挫败感、外在的干扰等等，导致可能没有那么坚定了，志向如果没有坚定，那相当于存在动力不足，可能心里会想到失败的结果就不会那么努力。有道是：苦心人，天不负。要相信上天不会辜负每一个努力的人，困难只是暂时的，总会有拨云见日的那天。树立坚定的志向，排除掉外界的各种干扰，用尽全部的努力，一心奔赴自己的前程，梦想才有实现的可能。\n\n\n\n\n\n\n\n\n\n因此，在确定志向方向后，时常问一问自己，自己是否为之付出了不遗余力的努力了吗？是否尽全力了吗？跟自己对比，不让自己留下遗憾。\n正向的思维\n那确定了志向之后，在实现的过程中需要有哪些品质呢？第一，坚定，要相信每个志向都有实现的可能；第二，正向的思维；第三，保持耐心；第四，在头脑中看到自己的志向。成长的过程中会遇到各种各样的困难和挫折，但是不能让挫折的情绪一直困扰着我们，可以短暂停留，但是更重要的是还要继续前行。王阳明在仕途中也遇到了很多的挫折，有一个故事是他被贬后，惨遭追杀，逃离之后发现自己的士兵都病了，照顾他的人都没有，但是王阳明还是没有抱怨当时的环境，改变心态，自己做家务，组织娱乐活动，结果是士兵们都好了起来。在我成长的过程中也遇到了很多的挫败，在回看过去的经历，能感触到很多。书中说到，其实历史上的很多人物，都遭遇了很多的挫折，但是他们并没有就此放弃自己，如孙斌、司马迁等等，还留下了许多著名的著作。因此，在困难面前，抱怨是没有用的，改变我们的心态，保持正向的思维，持续不断地努力，当情绪涌上心头的时候，可以想想假设是别人，他会怎么做，换一个角度来思考问题，避免一直处于抱怨的情绪中。\n保持耐心\n所谓欲速则不达，不以绝对的动机去完成任务。书中谈到王阳明对兵法精髓的理解，兵法不是书本上的死的、教条的东西，需要千锤百炼，理解之后融会贯通，而不是背下来，然后纸上谈兵。因此，就如很多专家说的，在一个领域专心科研，第一是可以成为自己的职业，第二是热爱，不断学习更深层次的东西。因此，在科研的路上或者是在未来的职业发展道路中，保持耐心，不冲动行事，慢慢积累，对领域达到更深层的理解。\n看到自己的志向\n谈到在头脑中看到自己的志向，我想到现实生活中的一个例子，我姐在干销售的过程中，有很大的愿力，就是每个月一定要达到规划的业绩。她不仅写下来，还常常在心里描绘完成后的场景。这种愿力让她在压力中始终充满斗志，最后是她真的实现了。就好比我第二次考研，我心中就知道我一定可以考上，结果我花了50多天的时间就考上了。\n\n\n\n\n\n\n\n\n\n最后附上书中的一段语录：\n首先，在心中思索、想象自己想要达成什么样的理想，要尽量想得清晰，确立一个具体的目标。其次，找出自己树立志向的动机或意义，想清楚为了实现目标自己要做些什么，要成为什么样的人。\n最后，以行动来实践、证明自己的志向，在行动中不断强化自己的信念，调整自己的心态，让志向成为生命中最重要的一件事。\n阅读笔记（二）\n\n\n\n\n\n\n\n\n时间：2025&#x2F;11&#x2F;8\n第二章：王阳明的修养之道\n本文第二章讲授的王阳明的心性修养之道，主要包含掌握情绪、培养定力、认识自我\n镇静\n当下是一个容易让人心浮气躁的时代，或多或少的杂事围绕着，短视频的兴起让大家都没有耐心，导致我们都慢慢变得很急躁，做一件事想立马看到效果，一段关系急着想知道答案。为什么要静心？静下来去感受，允许自己慢慢思考，不急功切利，缓一缓，遇到问题静心思考，在采取行动，会有不一样的效果。临危不惧者，乃强者也。不管遇到什么，先让自己静下心来，在冷静思考，达成很好的执行力。\n凡是要小心谨慎\n书中提到**“敬畏，并不是心中有恐惧忧患的意思，而是在别人看不见听不到的地方，也要自觉地进行修养，不因没人看见而放荡不羁，时时保持戒慎恐惧之心。”**在不同的环境场合之中，保持敬畏、谨慎和自我约束的态度，不太放纵和大意，言行谨慎，学会倾听，洞察事物之间微妙的关系，学会掌握情绪。\n不让负面情绪折磨自己\n俗话说：“人非圣贤，孰能无过。”绝大多数人都会犯错，既然已经发生的事情，那么沉浸在过错之中就会一直消耗自己的情绪。比如一场考试的失利，没有准备好，结果是失利，这个时候如果说“要是自己好好准备就能过了”这样的话已经为时已晚。可以允许自己犯错，因为有些因素我们没法把控，但是也一定要有翻篇的能力，不让那些负面的情绪让自己内耗。如果有失利，要反思失利的原因，经历这么多的考试，我也发现周围也有一些同学真的对考试很认真的一个态度去学习，我自认为在这一点上我还需要努力。我也才慢慢感受到，有些选择是冥冥之中注定的，不用去责怪过去的自己，更不用去后悔，可能再来一次，又会有相同的结局。\n\n\n\n\n\n\n\n\n\n王阳明认为，对于做错的事情，有悔恨之心可以理解的，也是改正错误必经的过程，但必须要有一个‘度’，有了失误察觉到了，及时改正就行了。如果对不如意的事念念不忘，老是让这种负面情绪停留在心中折磨自己，则又会因此产生新的毛病。\n认识自己\n如果要问我这个问题：“你认识自己吗？”我可能还不知道完整回答这个问题，但是我想说我在慢慢认识自己的路上。明确内心真正要成为的人和实现的目标，倾听内心的声音，心无旁旁骛朝着目标前进。书中讲到王阳明探索圣贤之路的历程，老师说了一句这样的话深深触动了王阳明的内心，“圣人必可学而至“。在他的脑海里仿佛就看到经过重重困难，成为圣人的场景，这是我们常常听到的念念不忘，必有回响。因此，不要说”江山易改，本性难移“，我们要说为了成为心中那个更好的自己，愿意改变自己的缺点和不足，接纳短暂的失利，不断打破旧的自己，在默默无闻之处沉淀，朝着大路走，为实现长期的目标，永远相信美好的事情即将发生。\n\n\n\n\n\n\n\n\n\n在安静放松的状态中，排除一切干扰，向内心的自我提问，在你的心目中，自己希望过着怎样的人生，什么东西是你生命中最重要的？如果自己的梦想有可能实现的话，自己为什么不去采取行动？当前是什么东西阻碍了自己？如果你一定要追求自己的梦想，你要改变哪些行为习惯？你会做些什么?\n释放怒气\n在不同的环境之中，我们每个人都会有偏激的情绪，学会掌控情绪也是一个很重要的事情。对我来说，这也是我也需要学习的，有的事情其实换个角度来说真的不一样，不积累糟糕的情绪，真正做情绪的掌控者。\n\n\n\n\n\n\n\n\n\n书中提到的一种释放方式：在觉得自己心中那些愤懑的情绪在不断积累，即将爆发出来时，一定要及早觉察，知道情绪不对了，就赶快转移自己的注意力，坚决制止自己，深呼吸放松自己，不再往负面事件联想下去，同时想想辽阔的天空，宽厚的大地，尽量往好的方面去想，用大自然的力量来冲淡心头的愤懑，让心胸保持一种豁达的状态\n","categories":["阅读"],"tags":["阅读"]},{"title":"知识图谱","url":"//post/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.html","content":"知识图谱实体在自然语言处理中，实体（Entity）通常指的是文本中具有独立存在、能够被明确识别并且具有特定意义的对象。实体通常是指一些特定的名词，它们代表现实世界中的对象或概念，可以是人、地点、组织、事件、日期、物品、概念等。\n例如：\n\n人名：维克托·迈尔-舍恩伯格、肯尼斯·库克耶\n地点：北京、美国\n组织名：微软公司、谷歌\n事件：新冠疫情、2024东京奥运会\n日期：2024年12月、2023年11月\n物品：iPhone、蓝牙耳机\n概念：大数据、机器学习\n\n知识图谱中的实体\n在知识图谱中，每个实体都有其独特的标识符和属性（例如，姓名、类型、描述等）。这些属性和关系帮助我们理解实体在特定领域中的作用和上下文。实体识别是图谱构建的重要步骤之一。\n例如，假设我们有以下句子：”维克托·迈尔-舍恩伯格是《大数据时代》一书的作者，他是大数据领域的专家。”\n在这个句子中，实体包括：\n\n维克托·迈尔-舍恩伯格（人名）\n《大数据时代》（书名）\n大数据领域（概念）\n\n这些实体在知识图谱中将被标识为节点，并且可以与其他节点（如其他作者、书籍、领域等）通过关系（如“写书”，“属于领域”）连接，形成知识图谱中的一个网络结构。同时，在知识图谱中，实体是基础组成单元，它们通过关系（relationship）连接，构成一个图的结构。实体和关系是构建知识图谱的两个基本元素。实体之间的连接关系定义了图谱中的知识和数据。\n","categories":["知识图谱"],"tags":["知识图谱"]},{"title":"语录","url":"//post/%E8%AF%AD%E5%BD%95.html","content":"优秀是一种惯性，会要求自己各方面都做得好，而马虎也是一种惯性，会习惯什么都是低水平徘徊。  \n优秀的人之所以优秀，不是因为他们最终达到了什么样的高度，而是因为在实现目标的过程中，他们挤压出了灵魂中全力以赴的一面。  \n如果你想要征服星辰大海，必须先征服自己的内心。  \n🌟 坚持，是最温柔的力量。\n\n\n\n\n\n\n\n\n\n这是今天课上PPT上的一段话，我想把他拿出来，然后就是今天从历史故事中学到了很多，以后当自己遇到一些想不通的事情或者是一些困难的时候，换个角度来看看怎么解决问题。\n","categories":["语录"],"tags":["学习感想"]},{"title":"语录分享","url":"//post/%E8%AF%AD%E5%BD%95%E5%88%86%E4%BA%AB.html","content":"昙花若只一现，更要开得耀眼 🌸✨\n毕淑敏 有一句很励志的话： “在光芒万丈之前，我们都要欣然接受眼下的孤独和偶然无助，认真做好眼前的每一件事， 你想要的都会有。” 💪🌟\n村上春树 的话也常常触动心灵： “我知道你最近很累，是那种看不见、身体上和精神上的疲惫感，但是请你一点要坚持下去。就算无人问津也好，技不如人也罢，千万别让烦躁和焦虑，毁了你本就不多的热情和定力。前路漫漫，当克己，当慎独，别贪心，我们不可能什么都有，也别灰心，我们不可能什么都没有。” 🌙🌱\n“尽管当下的糟糕也只是黎明前的短暂黑暗而已，所有经历的苦难都会是未来惊喜的伏笔。花会沿路盛开，我们未来的路也是。” 🌅🌸 —— 你一定会看到属于你的美好！ 🌈💖\n","categories":["语录"],"tags":["语录"]}]