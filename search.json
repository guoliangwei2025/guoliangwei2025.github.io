[{"title":"AI应用开发","url":"/2025/08/27/AI%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/","content":""},{"title":"MCP","url":"/2025/08/28/MCP/","content":""},{"title":"RAG","url":"/2025/08/30/RAG/","content":""},{"title":"LangChain","url":"/2025/08/25/LangChain/","content":"\n本篇文章主要介绍LangChain基础语法，RAG原理，以及使用LangChain实现简易的RAG系统，详细的RAG优化以及类型在另外的文章进行介绍\n\n1.LangChain 简介Langchains是用于开发大模型驱动的框架，借助LangChain可以轻松搭建基于LLM的相关应用，比如RAG系统\n此框架包含以下部分：\nlangchain-core: 基础抽象和LangChain表达式 (LCEL)langchain-community: 第三方集成，第三方相关的包langchain: 组成应用程序认知架构的链、代理和检索策略。LangGraph: 通过将步骤建模为图中的边和节点，构建强大且有状态的多参与者应用程序。与LangChain无缝集成，但也可以单独使用LangServe: 将LangChain链部署为REST APILangSmith: 一个开发者平台，让您调试、测试、评估和监控LLM应用程序\n\n\n\n\n\n\n\n2.LangChain 基础\nLangChain是为大模型应用而生的框架，结合大模型应用逻辑上，分为输入、模型处理、输出三个环节。通过构建提示词工程，作为上下文给大模型，然后通过结果解析器解析相应格式的输出\n\nLCEL表达式基于LangChain框架编写大模型应用的过程就像垒积木，其中的积木就是Prompts，LLMs和各OutputParser等。如何将这些积木组织起来，除了使用基本Python语法调用对应类的方法，一种更灵活的方法就是使用位于LangChain-Core层中的LCEL（LangChain Expression Language）(使用管道符来进行拼接)\nRunnable接口LCEL的基础是Runnable接口。通过实现Runnable接口，LCEL定义了一组具有通用调用方式的方法集。\nRunnable有一系列的子类，比如PromptTemplate、LLM和StrOutputParser（还有更多），这些组件子类都间接继承自Runnable(继承自RunnableSequence，而后者又继承自Runnable) 通过 管道符”|”前后两个组件合成一个Runnable的子孙类RunnableSequence对象返回，从而达到串起来形成链(chain)的目的。\n\nRunnable的__or__()方法重新定义了”|”语法，所以基于LCEL的chain就能通过或(也类似shell中的管道)操作符号”|”串起来。这也就是前面提到的“chain &#x3D; prompt | llm | output_parser”这行代码虽然看上去跟普通Python不一样，但它是合法的，原因就在这里\n\n3.LangChain实现RAG\nRAG的出现是为了在一定程度上缓解大模型的幻觉问题，因为大模型的输出是基于数学概率的输出预测、且信息不具有实效性、缺乏相关领域的专业知识，下面使用LangChain的链式调用实现简单的RAG。\n\n基础RAG系统，流程如下：\n\n文档切分\n向量嵌入\n构建提示词\n定义大模型服务\n检索相关片段作为大模型上下文\n结果解析器对大模型结果进行解析\n\n\n\n#完整的rag  from langchain_core.output_parsers  import StrOutputParserquery = &quot;在线支付取消订单后钱怎么返还&quot;from langchain_community.embeddings import DashScopeEmbeddingsfrom config.load_key import load_keyif not os.environ.get(&quot;DASHSCOPE_API_KEY&quot;):    os.environ[&quot;DASHSCOPE_API_KEY&quot;] = load_key(&quot;LANGSMITH_API_KEY&quot;)embedding_model = DashScopeEmbeddings(model=&quot;text-embedding-v1&quot;)redis_url = &quot;redis://localhost:6379&quot;config = RedisConfig(    index_name=&quot;meituan-index&quot;,   # 索引名，对应之前构建的知识库索引    redis_url=redis_url,          # Redis 连接地址)vector_store = RedisVectorStore(embedding_model, config=config)retriever = vector_store.as_retriever()#定义大模型from langchain_openai import  ChatOpenAIllm = ChatOpenAI(    model = &quot;deepseek-v3&quot;,    base_url =&quot;https://dashscope.aliyuncs.com/compatible-mode/v1 &quot;,    openai_key = load_key(&quot;LANGSMITH_API_KEY&quot;),) #定义提示模板from langchain_core.prompts import  ChatPromptTemplateprompt_template = ChatPromptTemplate.from_messages([    (&quot;user&quot;, &quot;你是一个答疑机器人，你的任务是根据下述给定的已知信息回答用户问题。\\n&quot;             &quot;已知信息：&#123;context&#125;\\n&quot;             &quot;用户问题：&#123;question&#125;\\n\\n&quot;             &quot;如果已知信息不含用户问题的答案，或者已知信息不足以回答用户问题，请直接回复“我无法回答您问题”。\\n&quot;             &quot;请不要输出已知信息中不包含的信息或答案。\\n&quot;             &quot;请用中文回答用户问题。&quot;)  ])#收集document内容def collect_document_content(segments):    text = []    for segment in segments:        text.append(segment.page_content)    return textfrom operator import itemgetterchain = (&#123;     &quot;question&quot;: query,    &quot;context&quot;: itemgetter(&quot;question&quot;)|retriever |collect_document_content,&#125;| prompt_template| llm| StrOutputParser())response = chain.invoke(&#123;&quot;question&quot;: query&#125;)  \n\n4.相关资料大模型应用开发学习资料\nLangChain中文文档\nCSDN博客\n","categories":["Langchain"],"tags":["AI"]},{"title":"hexo博客搭建教程","url":"/2025/08/24/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/","content":"\n初衷：\n我记得在刚上大三那会儿，想把自己学的一些东西记录到微信公众号上。刚开始坚持了几天，但是后来放弃了，因为大部分是Copy，也缺少自己的思考。\n经过最近的经历，我明白了一个道理：记录也是一个输出的过程。先自己理解，再把学习内容记录下来（记录适合自己学习或者找资料的过程），也是一种输出。\n所以，我决定从此开始，记录自己的过程，无论是：\n技术学习 、碎碎念  、成长困惑  、考试学习\n我想说，我可能走得很慢，但是我不会停下来，向内生长，加油!\n\n1. hexo介绍正如hexo的首页所显示的，它是一款非常快速，简介，高效的博客框架平台，我们可以利用hexo快速生成博客网站的模板，然后部署为我们自己的博客网站\n\n\n2. hexo教程下面博客记录完整搭建的教程，比较简易，我就是根据这个教程来搭建的，简短的时间就可以搭建一个属于自己的博客。\n其中主要步骤包括：\n\n软件的安装如git、Nodejs\nhexo部署到Github\nhexo配置（如用户个人信息、头像、主题下载配置分类目录）\n\n配置好hexo以及主题之后就可以开始写个人博客了，常见的命令是 \nhexo  clean             # 清除缓存文件和生成的静态文件hexo  new &quot;文章名称&quot;     # 新建界面hexo  generate          # 生成静态文件 可以简写成hexo g hexo  server            # 启动服务器   可以简写hexo shexo  deploy            # 部署网站，构建在GitHub的服务器中，网页文件将上传到关联的个人仓库 可以简写成hexo d\n\n\n\nHexo+Next部署github搭建个人博客+优化全过程（完整详细版）\n3. hexo中图片上传问题\n平时我们写文章可能会记录相关的图片，我个人也喜欢将别人写得好好理解的图片记录下来，但是在图片处理的过程中遇到一些问题（网上的方法各异，试了很多都不行），找了很多的教程，也是自己没有好好思考问题出在哪里，弄了很长时间，最后发现了相应的问题，仅以此记录我的处理方式。（参考CSDN并修改）\n\nTypora安装Typora\nTypora破解教程(破解序列号在评论区)\n​       修改Typora 偏好设置  如下图更改，此操作将图片文件保存路径: .&#x2F;${filename} 即保存到与 当前正在编辑的文件名相同的同级文件\n\n\n修改hexo配置修改_config.yml中的post_asset_folder，false 改为 true，这样修改后，每次 hexo new page生成新文章，都会在文章文件同级目录创建一个与文章文件名同名的文件夹，我们就在这里存放此文章的图片\n注：在md文档中存放的路径为文件夹/图片名称  \n之前找到有一种方式自定义安装一个插件，将md文档中的路径进行转换，第一天可以，但是第二天就不可以，找了很多办法，还是借助AI写了一个脚本实现相应的功能\n\n\n\n\n\n\n具体实现以下是在 hexo 中实现：Markdown 写 文件夹/图片名称 也能自动到相对应文章资源文件夹并生成 &#123;% asset_img %&#125; 标签。（使用插件进行实现）\n创建文件夹mkdir hexo-asset-imgcd hexo-asset-imgnpm init\n\n编写插件index.js&#x27;use strict&#x27;;/** * md文件返回 true * @param &#123;*&#125; data  */function ignore(data) &#123;    // TODO: 好奇怪，试了一下, md返回true, 但却需要忽略 取反!    var source = data.source;    var ext = source.substring(source.lastIndexOf(&#x27;.&#x27;)).toLowerCase();    return [&#x27;md&#x27;,].indexOf(ext) &gt; -1;&#125;function action(data) &#123;    var reverseSource = data.source.split(&quot;&quot;).reverse().join(&quot;&quot;);    var fileName = reverseSource.substring(3, reverseSource.indexOf(&quot;/&quot;)).split(&quot;&quot;).reverse().join(&quot;&quot;);    // ![example](postname/example.jpg)  --&gt;  &#123;% asset_img example.jpg example %&#125;    var regExp = RegExp(&quot;!\\\\[(.*?)\\\\]\\\\(&quot; + fileName + &#x27;/(.+?)\\\\)&#x27;, &quot;g&quot;);    // hexo g    data.content = data.content.replace(regExp, &quot;&#123;% asset_img $2 $1 %&#125;&quot;,&quot;g&quot;);    // log.info(`hexo-asset-img: filename: $&#123;fileName&#125;, title: $&#123;data.title.trim()&#125;`);        return data;&#125;hexo.extend.filter.register(&#x27;before_post_render&#x27;,(data)=&gt;&#123;    if(!ignore(data))&#123;        action(data)    &#125;&#125;, 0);\n\n本地测试插件\nHexo 根目录下 package.json 中 dependencies 添加一行 &quot;hexo-asset-img&quot;: &quot;^1.0.0&quot;, \n\n将 hexo-asset-img 文件夹复制到 Hexo 根目录下 node_modules 文件夹下 \n   hexo clean &amp;&amp; hexo g   hexo s # 本地预览   #编译后的文件在public文件夹下Markdown 图片写法在 Markdown 里可以写带文件夹的图片：```markdown![示例](demo/demo.png)![另一张](test/other.png)\n\n\n图片相对路径是相对于 Markdown 文件所在目录。\n\n4.Netlify部署Netlify部署方法\n5. 相关资料插件方法 （插件方法可行）\n","categories":["博客搭建教程"],"tags":["博客搭建教程"]},{"title":"hot100题-双指针","url":"/2025/08/29/hot100%E9%A2%98-%E5%8F%8C%E6%8C%87%E9%92%88/","content":"移动零（283）283. 移动零\n\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n①两次单循环，一次用于将数组中大于0的数移动到首部，然后另一次将后面的值补上0\nclass Solution:    def moveZeroes(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        k = 0        for i in range(len(nums)):            if nums[i]:                nums[k] = nums[i]                k += 1        for i in range(k,len(nums)):            nums[i] = 0\n\n②使用快慢双指针，快慢指针都是从头开始，快指针出发去寻找大于0的数（只有在大于0的时候才进行交换），然后左指针指向为0的数或者就是大于0 的数，交换两个元素的值，然后左指针右移动。右指针左侧一直到左指针，中间都是0。（如果都是正数，那本质就是自己跟自己交换，左右指针同时移动）\nclass Solution:    def moveZeroes(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        #双指针        n = len(nums)        left = right = 0        for right in range(n):            if nums[right]:                nums[left],nums[right] = nums[right],nums[left]                left += 1          \n\n\n\n盛水最多的容器（11）11. 盛最多水的容器\n\n给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。\n找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n返回容器可以储存的最大水量。（说明：你不能倾斜容器。）\n\n①暴力法 （会超时）\n固定左端点不动，右端点不断左移动，计算容积\nclass Solution:    def maxArea(self, height: List[int]) -&gt; int:        # 确定两个位置 可以容纳最多的水 就是两个位置的距离之差 乘以最小的高度        # 不能排序 什么时候更新指针的移动难点         n = len(height)        res = 0        for left in range(n):            right = n-1            while left &lt; right:                v = (right - left)* min(height[right],height[left])                  right -= 1                res = max(res,v)        return res\n\n②双指针\n本题最难的点就是双指针的移动策略，因为容积计算是两个位置距离之差，乘以最小的高度，因此本题目的移动策略就是移动最小的高度，因为长的那一边即使不动，高度还是由短的那边决定。 \nclass Solution:    def maxArea(self, height: List[int]) -&gt; int:        # 确定两个位置 可以容纳最多的水 就是两个位置的距离之差 乘以最小的高度        # 不能排序 什么时候更新指针的移动难点         n = len(height)        res = 0        left,right = 0,n-1        while left &lt; right:            v = (right - left)*min(height[right],height[left])              res = max(res,v)            if height[left]&lt;height[right]:                left += 1            else:                right -= 1        return res\n\n三数之和（15）15.三数之和\n\n给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。（答案中不可以包含重复的三元组）\n\n①暴力破解  三重循环  问题：超时 、需要去重（通过不了）\nclass Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        #暴力破解  三重循环进行 问题是：时间问题 而且还要去重        res = []        n = len(nums)        for i in range(n):            for j in range(i+1,n):                for k in range(j+1,n):                    if nums[i]+nums[j]+nums[k]==0:                        res.append([nums[i], nums[j], nums[k]])        result = set(tuple(sorted(x)) for x in res)        return [list(x) for x in result]\n\n②双指针移动\n因为本题目不能留下重复的三元组，所以将数组进行排序，然后遇到重复的数进行跳过，然后从当前位置i开始，区间为i+1~n-1，不断去遍历，当满足条件的值就加入列表，如果不满足，则指针进行移动，如果小于0，说明左边的数太小了，左指针需要右移动；如果大于0，说明右边的数太大了，右指针需要往左移动，直至满足条件\nclass Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        #双指针  排序 去重        res = []        #排序         nums.sort()        n = len(nums)        for i in range(n):            #跳过重复的值            if i&gt;0 and nums[i] == nums[i-1]:                continue            #左指针从i+1的位置开始  右指针从最后的位置开始            l,r = i+1,n-1            while l&lt;r:                s = nums[i]+nums[l]+nums[r]                if s==0:                    res.append([nums[i], nums[l], nums[r]])                    while l&lt;r and nums[l] ==nums[l+1]:                        l += 1                    while l&lt;r and nums[r] == nums[r-1]:                        r -= 1                    l += 1                    r -= 1                elif s&lt;0:                    l += 1                else:                    r -= 1        return res\n\n\n\n接雨水（42）42. 接雨水\n\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n 某一位置的积水量 &#x3D; min(左边最高柱子, 右边最高柱子) - 当前高度\n双指针解法：\n首先确定了某一位置的积水量计算公式之后，那么重点就是确定左边和右边的最高柱子。使用双指针从两侧往中间进行，如果当前左高度小于右边的高度，说明此时可以计算左边的积水，此时公式就是左边的最高柱子的高度-当前高度，但是如果当前的高度大于左侧的最高高度，那么是不能积水的（因为水要依靠比它更高的墙才能积起来，如果当前位置本身就是新最高的墙，那么这里是不会积水的），此时只能更新左侧的最高高度。同理，右侧也如此\n\n开始有困惑，我理解了对于每个位置来说的积水量的计算，取决于它左右最高的柱子（决定的还是左右两侧低的柱子）。使用双指针的时候，计算的事局部最高墙，不理解。后面借助AI的提示。想象水从上往下落，左边最高墙挡住了水，当前柱子比左边墙高 → 水直接落在它两侧，不会在它顶上停留，所以只要局部左边最高墙等于或小于当前位置，当前位置就不会积水\n\nclass Solution:    def trap(self, height: List[int]) -&gt; int:        #问题 雨水的位置 怎么计算雨水        n = len(height)        left_max = right_max = 0        res = 0         left,right = 0,n-1        while left &lt; right:            #说明此时可以计算左侧的积水            if height[left]&lt;height[right]:                if height[left] &gt; left_max:                    #说明当前位置是局部最高墙  不会积水                    left_max = height[left]                else:                    res += left_max -height[left]                left += 1            else:                if height[right] &gt; right_max:                    #说明当前位置是局部最高墙  不会积水                    right_max = height[right]                else:                    res += right_max -height[right]                right -= 1        return res\n\n\n\n","categories":["hot-100题"],"tags":["hot100-双指针"]},{"title":"hot100题-哈希","url":"/2025/08/29/hot100%E9%A2%98-%E5%93%88%E5%B8%8C/","content":"两数之和（1）\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标\n\n1.两数之和\n①暴力解法 \n使用两层循环暴力进行解答\n②使用哈希表\n为啥要用到哈希表呢？ 在数组中查询时间复杂度太高，需要顺序查找，而哈希表可根据值快速查找\n\npython中字典也是哈希表的一种实现。定义哈希表后，遍历数组，如果目标值-当前值不在哈希表中，则将当前值以及对应的索引存入哈希表。如果能在哈希表中找到对应的值，则返回对应的下标\n\nclass Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        #定义哈希表 如果 target-当前元素不在哈希表中 就加入哈希表         t = &#123;&#125;        for i,num in enumerate(nums):            if target-num in t:                return [t[target-num],i]            t[num] = i        return \n\n字母异位词分组（49）49. 字母异位词分组\n\n给你一个字符串数组，请你将字母异位词组合在一起。可以按任意顺序返回结果列表。\n\n字母异位词组成单词相同，仅仅是位置不一样，可以建立哈希表，找到作为字母异位词的相同点作为哈希表的键，字母异位词的键值都是相等的，根据这一点，实现了不同的字母异位词的分类\n然后将每个字符串进行排序之后组合新的字符串作为哈希表的键，加入到哈希表中，这样就实现了不同的字母异位词的分类\n①将每个字符串按照字典顺序进行排序，排列组合成新的字符串作为哈希表的键\nclass Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        mp = defaultdict(list)  # 创建哈希表，value 默认是列表        for st in strs:            key = &quot;&quot;.join(sorted(st))  # 对字符串排序，得到 key            mp[key].append(st)         # 加入对应分组        return list(mp.values())       # 返回所有分组\n\n②计数，定义数组计算每个字符串字母出现的个数，组成字母异位词的字符个数是相等的，但是列表是可变的所以不能哈希，需要转化成元组才能哈希\nclass Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        mp = defaultdict(list)  # 创建哈希表，value 默认是列表        for st in strs:            counts = [0]*26            for ch in st:                counts[ord(ch)-ord(&quot;a&quot;)] += 1            mp[tuple(counts)].append(st)        return list(mp.values())       # 返回所有分组\n\n最长连续序列（128）128. 最长连续序列\n\n给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n\n本题目限制了时间复杂度为O(N)，因此不能使用排序。\n如果单独从列表找元素时间较长，因此先可以将列表转化为哈希集合，直接检索哈希结合，在找序列的时候也要注意就是，因为没有排序，那可能从当前位置x开始，可能x-1在哈希集合中因此如果x-1在哈希集合中，此时就跳过。\nclass Solution:    def longestConsecutive(self, nums: List[int]) -&gt; int:        #把nums转化成哈希集合        st = set(nums)        ans = 0        for x in st:            #如果x-1在集合里面 从x为起点 不如x-1为起点的序列长            if x-1 in st:                continue            y = x +1             #一直往后遍历 找到连续的序列            while y in st:                y += 1            ans = max(ans,y-x)        return ans \n\n","categories":["hot-100题"],"tags":["hot100-哈希"]},{"title":"GraphRAG","url":"/2025/08/27/GraphRAG/","content":"GraphRAG（一）GraphRAG简介\n基本的RAG系统通常集成向量数据库和LLM，对知识库进行嵌入存入向量数据库，后根据相似度计算，从向量数据库中检索到相关的片段作为大模型的上下文。但是这种在处理复杂的任务时候，如联系不同信息片段全面回答问题有些局限。 \n\n与使用向量数据库检索语义相似文本的基本 RAG 不同，GraphRAG 则采取了一种创新的路径，首先利用大型语言模型从非结构化文本数据中提取出实体和关系，并据此构建一个知识图谱。接着，依托图谱的拓扑结构进行社区发现，对每个社区进行逐层总结，最终形成一个分层且结构化的知识网络。在进行查询时，GraphRAG 利用这一知识网络来强化信息检索，从而为模型提供更具启发性的上下文，以回答那些需要深度推理和全局视角的问题。（结合传统的图数据库查询和强大的生成模型）\n\n索引（Indexing）：这是 GraphRAG 的数据处理阶段，它将非结构化文本转化为结构化知识。主要步骤包括：\n\n文本分块：将长文档切分成小的文本单元（TextUnit）；\n图谱提取：利用大模型从文本单元中提取出实体（Entities）和关系（Relationships），构建知识图谱；\n社区发现：使用 Leiden(图谱聚类算法) 等算法对图谱进行层次化社区聚类；（不同的社区指的是不同的知识结构或者主题）\n社区总结：利用大模型为每个层级的社区生成摘要报告；\n\n\n查询（Querying）：这是 GraphRAG 的数据检索与问答阶段，利用构建好的知识图谱和摘要来回答问题。比较常见的查询方式有：\n\n全局搜索（Global Search）：利用社区摘要，通过 Map-Reduce 的方式对整个数据集进行归纳总结，回答宏观问题；\n本地搜索（Local Search）：当问题涉及特定实体时，从该实体出发，在知识图谱中向外扩展，聚合其邻近的实体、关系以及相关的原始文本块，为大模型提供精准的局部上下文\n\n\n\n\n\n\n\nGraphRAG快速入门\n本文章是在腾讯云(免费GPU)上进行，使用的模型服务商是硅基流动，下面走进GraphRAG的开始吧！\n\n\n在这个平台上可以选择创建各种不同的环境，这里选择Pytorch的环境，如果要跑简单的深度学习也可以使用这个环境\n\n\n\n创建虚拟环境#使用conda创建graphrag虚拟环境conda create -n graphrag python=3.10#安装graphragpip install graphrag\n\n准备demo数据# 创建demo目录mkdir -p ./ragtest/input# 下载微软官方demo数据curl https://www.gutenberg.org/cache/epub/24022/pg24022.txt -o ./ragtest/input/book.txt\n\n\n初始化demo目录 执行这个命令之后 将在 ./ragtest目录中创建两个文件：.env和settings.yaml\n因为默认生成的是跟GPT模型相关的配置文件，国内使用获取其API不太方便，因此需要修改使用，这里使用硅基流动的模型服务，大模型选择deepseek-v3，嵌入模型选择 BAAI/bge-large-zh-v1.5\n\ngraphrag init --root ./ragtest\n\n\n修改配置文件 在settings.yaml 文件中修改初始的模型，然后再.env文件中的API为硅基流动的API\n\nmodels:  default_chat_model:    type: openai_chat    api_base: https://api.siliconflow.cn/v1    api_key: $&#123;GRAPHRAG_API_KEY&#125;    model: deepseek-ai/DeepSeek-V3    encoding_model: cl100k_base    concurrent_requests: 3    requests_per_minute: 30  default_embedding_model:    type: openai_embedding    api_base: https://api.siliconflow.cn/v1    api_key: $&#123;GRAPHRAG_API_KEY&#125;    model: BAAI/bge-large-zh-v1.5    encoding_model: cl100k_base    concurrent_requests: 3     requests_per_minute: 30\n\n构建索引\n执行如下命令将自动完成\n文本分块 、实体识别与关系提取（调用大模型）、构建实体-关系图谱、社区检测（Leiden算法）、生成社区摘要（调用大模型）、嵌入计算 + 向量索引构建（花费时间较长）\n\ncd ragtestgraphrag index --root .\n\nragtest目录结构详解\n\nragtest&#x2F; ├── settings.yaml      # 配置文件 ├── prompts&#x2F;           # 提示词模板 ├── input&#x2F;             # 数据输入目录（需手动创建） ├── .env               # 存储 API 密钥 └── output&#x2F;            # 自动生成的索引结果\n\n\nGraphRAG 使用 Parquet 存储数据，这是一种列式存储的二进制文件格式，专为高效存储和处理大规模结构化数据而设计，广泛用于大数据处理和分析场景。另外，LanceDB 是一个为机器学习优化的向量数据库，使用 Apache Arrow 格式存储。GraphRAG 使用它来存储文本嵌入向量，用于相似性搜索。\n\nGraphRAG 输出文件详解\n\n\n\n查询GraphRAG 输出文件概览\n\n\n文件&#x2F;目录\n作用\n内容\n理解\n\n\n\ndocuments.parquet\n存储原始文档的元信息与全文内容\n每个文档一个条目，包含 title、text、doc_id\n原始文档的索引表\n\n\ntext_units.parquet\n存储文档分块（chunk）后的切片内容\n每一块对应一次 LLM 调用（如实体提取），记录切分后的每个 chunk 的内容\n分块后的最小处理单元\n\n\nentities.parquet\n存储从所有文档中提取的实体信息\n实体名称、类型（人物、组织、地点、事件）、出现频率、描述、出现在哪些块中\n知识图谱的节点（Node）\n\n\nrelationships.parquet\n存储实体之间的语义关系\n两个实体之间的关系（如 “张三-管理-产品部”），关系描述、类型、权重\n知识图谱的边（Edge）\n\n\ncommunities.parquet\n存储社区检测结果\n基于图谱运行社区检测算法得到的“主题组”，每个社区包含一组相关实体\n自动发现的主题集群\n\n\ncommunity_reports.parquet\n为每个社区生成自然语言摘要\n报告标题、摘要、主要发现，由 LLM 生成，面向用户\n社区的结构化报告，便于理解主题\n\n\nlancedb/\n存储文本单元的向量表示\n用于局部语义搜索\n为后续检索提供 embedding 索引\n\n\n全局搜索（Global Search）：适用于需要对整个数据集进行宏观理解和总结的问题：\n本地搜索（Local Search）：适用于查询关于特定实体的具体信息：\n相关资料GraphRAG本地部署使用及兼容千帆通义\nGithub地址\n文档地址\ngraphrag-more地址\nGraphRAG全流程实战\nGraphRAG快速入门\nGraphRAG详解\nGraphRAG快速入门与原理详解（索引建立的详细举例介绍）\n","categories":["GraphRAG"],"tags":["GraphRAG"]},{"title":"hot100题-滑动窗口","url":"/2025/08/29/hot100%E9%A2%98-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","content":"无重复字符的最长子串（3）\n3. 无重复字符的最长子串\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。\n\n找到字符串中所有字母异位词（438）\n438. 找到字符串中所有字母异位词\n给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n\n","categories":["hot-100题"],"tags":["hot100-滑动窗口"]},{"title":"hot100题-数组","url":"/2025/08/27/hot100%E9%A2%98-%E6%95%B0%E7%BB%84/","content":"最大子数组和(53)最大子数组和\n\n给一个整数数组 nums ，找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n开始想到使用滑动窗口来进行解题，发现在求解过程中，窗口大小不固定，没办法确定窗口长度，这里选择动态规划算法，对于每个位置 i，找到 nums[i] 结尾的最大子数组和(动态规划算法还需要强加学习)\nclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        n = len(nums)        dp = [0] * n  # dp[i] 表示以 nums[i] 结尾的最大子数组和        dp[0] = nums[0]        max_sum = dp[0]        for i in range(1, n):            # 状态转移公式            dp[i] = max(nums[i], dp[i-1] + nums[i])            # 更新全局最大值            max_sum = max(max_sum, dp[i])        return max_sum\n\n合并区间（56）合并区间\n\n以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 \n\n\n按照左端点进行排序  \n定义返回的列表  \n每次对当前子数组的值和列表中最后一个数组的尾部进行比较  \n如果当前子数组的 start &gt; 列表中最后一个的尾部，则不需要更新  \n如果当前子数组的 start &lt;&#x3D; 列表中最后一个的尾部，则需要更新列表中最后的尾部，取两者之间较大的值\n\nclass Solution:    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:        intervals.sort(key=lambda x:x[0])        merged = []        for interval in intervals:            if not merged or merged[-1][1] &lt; interval[0]:                #当前区间的start和最后的end 如果当前区间的start 大于 最后的end                #已存在最后的[0,1]  当前的[2,3] 没有重叠                merged.append(interval)            else:                #最后的[0,2]  当前的[1,2]  或者 最后的[0,2] 当前 [0,4]                 merged[-1][1] = max(interval[1],merged[-1][1])        return merged        \n\n轮转数组（189）轮转数组\n\n将整数数组向右轮转 k 个位置\n\n① 切片法  \n\nk 可能大于数组长度，因此对 k 取余  \n使用切片法：截取原数组后 k 个和除去数组后 k 个之前的进行拼接\n\nclass Solution:    def rotate(self, nums: List[int], k: int) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        #定义一个循环的数组 然后一直移动就可以        n = len(nums)        k %= n        nums[:] = nums[-k:]+nums[:-k]\n\n② 使用额外的数组  \n\n在原数组之后再加上一个一样的数组，然后进行截取\n\nclass Solution:    def rotate(self, nums: List[int], k: int) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        #定义一个循环的数组 然后一直移动就可以        n = len(nums)        if n==0:            return         k %= n        extend = nums+nums        rotated = extend[n-k:n-k+n]         nums[:] = rotated\n\n③ 数组翻转  \n\n将数组向右移动 k 次，尾部 k mod n 个元素会移动到数组头部，其余元素会向后移动 k mod n 个位置  \n先将所有元素翻转  \n再翻转 [0, k mod n−1] 区间和 [k mod n, n−1] 区间即可\n\n除自身以外数组的乘积（238）\n给一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 \n\n除自身以外数组的乘积\n① 暴力解法  \n\n两层循环进行解答，但是会超时\n\n② 前后缀积  \n\n分别计算左前缀和右前缀，然后进行相乘\n\nclass Solution:    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:        n = len(nums)        left ,right, res = [0]*n,[0]*n,[0]*n        #计算第i个位置的左前缀积        left[0] = 1        for i in range(1,n):            left[i] = left[i-1]*nums[i-1]        #计算第i个位置的右前缀积        right[n-1] = 1        for i in reversed(range(n-1)):            right[i] = right[i+1]*nums[i+1]        #分别将左前缀和右前缀对应进行相乘        for i in range(n):            res[i] = left[i]*right[i]        return res\n\n缺失的第一个正数(41)\n已知一个未排序的整数数组 nums ，找出其中没有出现的最小的正整数\n\n缺失的第一个正数\n数组有N个元素，对应索引值为0~n-1，并设置标记。如果当前的值小于n，那么将其n-1位置上面的元素做标记，如设置为负数， 如果全部被标记 ，那返回的就是n+1 ，反之，那就是第一个正数的位置 （因为其中有负数或者大于n的数 ，这样初始处理就是将这些数设置为n+1 ）\nclass Solution:    def firstMissingPositive(self, nums: List[int]) -&gt; int:        n = len(nums)        #忽略无用数        for i in range(n):            if nums[i]&lt;=0 or nums[i] &gt; n :                nums[i] = n+1        #进行标记        for i in range(n):        #为啥要取绝对值呢  因为如果是3  4 6 5  当遍历到3时候，会修改后续位置为 3 4 -6 5，所以需要取绝对值，避免索引值为负数            num = abs(nums[i])            if num &lt;= n:                nums[num-1] = -abs(nums[num-1])        for i in range(n):            if nums[i]&gt;0:                return i+1        return n+1\n\n","categories":["hot-100题"],"tags":["hot100-数组"]},{"title":"python哈希","url":"/2025/08/29/python%E5%93%88%E5%B8%8C/","content":"\n本文是借助ChatGPT结合总结的关于哈希相关的知识，以及哈希表的相关定义和使用，帮助理解哈希表的作用以及哈希表的使用场景\n\nPython中的哈希哈希的含义哈希的含义是把 任意长度的数据（如字符串、数字、对象）通过 哈希函数（Hash Function），转换成一个 固定长度的整数，通常用作 索引或标识。\n哈希函数的作用：把数据“映射”到一个整数，用这个整数可以在数组或表里快速找到对应位置\n哈希表（Hash Table）哈希表是哈希的最常见应用：\n\n由 数组 + 哈希函数 构成\n使用 key 的哈希值快速找到 value 的存储位置\n插入&#x2F;查找&#x2F;删除平均时间复杂度 O(1)\n\nkey = &quot;apple&quot;hash(&quot;apple&quot;) = 7  → 存在数组索引 7value = 5\n\n哈希表基础哈希表（Hash Table） 是一种 基于键值映射的数据结构，核心特点：\n\n键（key） → 哈希函数 → 数组索引 → 值（value）\n查找、插入、删除平均时间复杂度 O(1)\nPython 内部使用 开放寻址 + 链表&#x2F;红黑树 来处理冲突\n\nkey=&quot;apple&quot; → hash(&quot;apple&quot;) → 索引 7 → value=5key=&quot;banana&quot; → hash(&quot;banana&quot;) → 索引 3 → value=2\n\ndict（字典）Python中内置的哈希表类型\nkey：不可变的类型（int，str，tuple）\nvalue：任意类型\nscores = &#123;&quot;Alice&quot;: 90, &quot;Bob&quot;: 85&#125;print(scores[&quot;Alice&quot;])  # 90scores[&quot;Charlie&quot;] = 92  # 新增\n\ndefaultdict（带默认值的字典）来自来自 collections 模块，工厂函数指定默认值类型\n常用类型：\n\nint → 默认 0，用于计数\nlist → 默认 []，用于分组\nset → 默认 set()，用于去重\n\nfrom collections import defaultdict# 计数cnt = defaultdict(int)for ch in &quot;abracadabra&quot;:    cnt[ch] += 1print(cnt)  # &#123;&#x27;a&#x27;:5, &#x27;b&#x27;:2, &#x27;r&#x27;:2, &#x27;c&#x27;:1, &#x27;d&#x27;:1&#125;# 分组groups = defaultdict(list)words = [&quot;eat&quot;,&quot;tea&quot;,&quot;tan&quot;,&quot;ate&quot;,&quot;nat&quot;,&quot;bat&quot;]for w in words:    key = &quot;&quot;.join(sorted(w))    groups[key].append(w)print(groups.values())  # [[&#x27;eat&#x27;,&#x27;tea&#x27;,&#x27;ate&#x27;], [&#x27;tan&#x27;,&#x27;nat&#x27;], [&#x27;bat&#x27;]]\n\nCounter（计数器）\ncollections.Counter 是 dict + int 封装的计数工具\n功能：统计元素频率，直接返回哈希表\n\nfrom collections import Counters = &quot;abracadabra&quot;cnt = Counter(s)print(cnt)  # &#123;&#x27;a&#x27;:5,&#x27;b&#x27;:2,&#x27;r&#x27;:2,&#x27;c&#x27;:1,&#x27;d&#x27;:1&#125;\n\nset（集合）哈希实现的无序集合，元素唯一、查找快速，常用于去重、快速判断元素是否存在\nnums = [1,2,2,3,4,4,5]s = set(nums)print(s)  # &#123;1,2,3,4,5&#125;print(3 in s)  # True\n\n哈希使用场景\n\n\n场景\n常用类型\n说明\n\n\n\n元素去重\nset\n判断元素是否存在\n\n\n计数&#x2F;频率统计\ndict / Counter / defaultdict(int)\n统计出现次数\n\n\n分组&#x2F;归类\ndefaultdict(list)\n通过 key 分组元素\n\n\n查找&#x2F;索引映射\ndict\nkey → value 快速查找\n\n\n注意事项Python 中的哈希表主要是 dict、defaultdict、set、Counter\n核心思想：key → hash → 索引 → value\n\nkey 必须可哈希（不可变类型）\n哈希表顺序：Python 3.7+ 保留插入顺序\n冲突处理：Python 内部自动解决，一般不需要手动处理\n空间换时间：哈希表使用额外内存来换取 O(1) 查找速度\n\n","categories":["python"],"tags":["python哈希"]},{"title":"transformer学习","url":"/2025/08/23/transformer%E5%AD%A6%E4%B9%A0/","content":"Transformer1. Transformer 主要结构及对比 RNN编码器（Encoder）编码器由多个相同的编码器层堆叠而成，每一层包含以下部分：\n\n多头自注意力机制（Multi-Head Self-Attention）：通过多个注意力头从不同角度学习词与词之间的关系。\n前馈神经网络（Feed-Forward Neural Networks）：对注意力机制的输出进行非线性变换，增强模型的表达能力。\n残差连接和层归一化（Residual Connection &amp; Layer Normalization）：帮助信息流动并稳定训练过程，防止梯度消失。\n\n解码器（Decoder）解码器与编码器类似，但每层解码器额外包含以下机制：\n\n掩蔽多头自注意力机制（Masked Multi-Head Attention）：用于处理目标序列，通过掩码防止当前位置关注未来位置，确保生成过程的自回归特性。\n\n编码器 - 解码器注意力机制（Encoder-Decoder Attention）：使解码器能够关注编码器输出的上下文信息，建立输入与输出序列之间的关联。\n\n前馈神经网络（Feed-Forward Neural Network）：对注意力机制的输出进行非线性变换，增强解码器的表达能力。\n\n\n\n\n对比 RNN\n优点：\n并行化：取消递归结构，Transformer 允许序列中的所有位置同时处理，而 RNN 是逐步处理的，这使得 Transformer 能在训练过程中实现并行化，从而大幅加速训练。\n长距离依赖：RNN 在处理长序列时，容易出现梯度消失或梯度爆炸的问题，而 Transformer 通过自注意力机制能够直接捕捉到序列中任意位置的依赖关系。（引入位置编码， 在不依赖 RNN 结构的情况下，通过位置编码为序列中的每个元素嵌入位置信息，从而使模型能够感知输入的顺序）\n计算效率：Transformer 在每一层的计算是对称的，计算效率较高，且可以扩展到大规模的训练数据。\n\n\nRNN 的缺点：\n训练速度慢：由于其顺序处理的特点，RNN 的计算速度较慢，无法进行高效并行。\n长程依赖问题：RNN 在捕捉长期依赖时表现较差，通常会遭遇梯度消失或爆炸问题，导致学习效果不佳。\n\n\n\n2. 为什么要进行位置嵌入（Positional Encoding）？位置嵌入的作用Transformer 不像 RNN 那样天然具有序列顺序的处理能力，因此需要通过位置嵌入来为模型提供位置信息，使其能理解输入数据的顺序。\n位置嵌入的方式最常用的方式是通过 正弦和余弦函数 来生成位置嵌入。具体做法是为每个位置计算一个向量，使用不同频率的正弦和余弦函数来表示不同位置的信息。这个方式的优点是它可以在不依赖训练的情况下生成，且具有很好的可扩展性。\ntransformer 的自注意力机制（Self-Attention）是位置无关（position-agnostic）的。也就是说，如果不做任何处理，模型无法区分 “我爱你” 和 “你爱我” 这两个句子的差异，因为自注意力机制只关注 token 之间的相关性，而不考虑它们在序列中的顺序。\n为了让模型感知到 token 的位置信息，Transformer 引入了位置编码。\n在原始论文中，Transformer 使用的是固定位置编码（Positional Encoding），其公式如下：\n\n\n其中：\npos 表示位置索引（Position）。\ni 表示维度索引。\ndmodel 是嵌入向量的维度。\n流程：输入的是一个整数索引（位置序号 0,1,2,…）。位置编码模块先把这些整数映射成与词向量同维度的向量（例如 512 维），再把结果加到词向量上。\n如何理解位置嵌入\nhttps://www.zhihu.com/question/347678607\n3. 自注意力机制自注意力机制的作用\n随着模型处理输入序列的每个单词，自注意力会关注整个输入序列的所有单词，帮助模型对本单词更好地进行编码。在处理过程中，自注意力机制会将对所有相关单词的理解融入到我们正在处理的单词中。更具体的功能如下：\n序列建模：自注意力可以用于序列数据（例如文本、时间序列、音频等）的建模。它可以捕捉序列中不同位置的依赖关系，从而更好地理解上下文。这对于机器翻译、文本生成、情感分析等任务非常有用。\n并行计算：自注意力可以并行计算，这意味着可以有效地在现代硬件上进行加速。相比于RNN和CNN等序列模型，它更容易在GPU和TPU等硬件上进行高效的训练和推理。（因为在自注意力中可以并行的计算得分）\n长距离依赖捕捉：传统的循环神经网络（RNN）在处理长序列时可能面临梯度消失或梯度爆炸的问题。自注意力可以更好地处理长距离依赖关系，因为它不需要按顺序处理输入序列。\n\nQ, K, V 的含义\nQ（Query）：查询向量，表示当前关注的词。\nK（Key）：键向量，表示其它词的特征。\nV（Value）：值向量，表示与键向量关联的实际信息。\n\n注意力分数计算公式\n\n\n\n注意力分数的计算方式是通过 Q 和 K 的点积 来衡量 Query 与 Key 之间的相关性。计算公式为：其中，d_k 是 K 向量的维度，* 表示矩阵乘法，softmax 用于标准化分数，使其成为概率分布。\n问题：为什么要除以dk？\n当 dk 较大时，点积的数值可能会过大，导致 Softmax 过后的梯度变得极小\n\n\n\n\n\n\n\n\n\n\nSoftmax函数\n\n在 Transformer 模型中，Softmax 函数不仅在计算注意力权重时用到，在预测阶段的输出处理环节也会用到，因为预测 token 的过程可以看成是多分类问题。\nSoftmax或称归一化指数函数，它将每一个元素的范围都压缩到（0，1）之间，并且所有元素的和为1\n最后经过线性层后进入softmax函数，将每个值向量乘以softmax分数(这是为了准备之后将它们求和)。这里的直觉是希望关注语义上相关的单词，并弱化不相关的单词(例如，让它们乘以0.001这样的小数)。\nSoftmax 通过指数变换放大数值间的差异，让较大的值对应更高的概率，同时避免了负值和数值过小的问题，让模型聚焦于权重最高的位置，同时保留全局信息（低权重仍非零）\n4. 多头注意力机制多头注意力机制就是存在多个不同的权重矩阵（Q、K、V），形成多个矩阵 Z，再把它们 按最后一维（hidden）拼接（concat）→ 做一次线性变换 得到最终输出。\n线性层把拼接后的多头结果 Z_concat（形状 batch×seq×d_model）重新线性映射回与输入相同的维度，同时让网络可以学习如何融合不同头的信息。\n\n\n\n\n\n\n\n\n\n\n5. 残差层和归一化层的作用Add（残差连接，Residual Connection）残差连接是一种跳跃连接（Skip Connection），它将层的输入直接加到输出上（观察架构图中的箭头）：\nAdd，就是在z的基础上加了一个残差块X，加入残差块的目的是为了防止在深度神经网络的训练过程中发生退化的问题，退化的意思就是深度神经网络通过增加网络的层数，Loss逐渐减小，然后趋于稳定达到饱和，然后再继续增加网络层数，Loss反而增大\n\n\n通过直接将输入添加到输出中，帮助缓解深度网络中的梯度消失问题，保证信息能够有效流动。这种连接方式有效缓解了深层神经网络的梯度消失问题\nResNet残差神经网络为了了解残差块，我们引入ResNet残差神经网络，神经网络退化指的是在达到最优网络层数之后，神经网络还在继续训练导致Loss增大，对于多余的层，我们需要保证多出来的网络进行恒等映射。只有进行了恒等映射之后才能保证这多出来的神经网络不会影响到模型的效果。残差连接主要是为了防止网络退化。\n\n\n上图就是构造的一个残差块，X是输入值，F（X）是经过第一层线性变换后并且激活的输出，在第二层线性变化之后，激活之前，F（X）加入了这一层输入值X，然后再进行激活后输出。\n要恒等映射，我们只需要让F（X）&#x3D;0就可以了。x经过线性变换（随机初始化权重一般偏向于0），输出值明显会偏向于0，而且经过激活函数Relu会将负数变为0，过滤了负数的影响。这样当网络自己决定哪些网络层为冗余层时，使用ResNet的网络很大程度上解决了学习恒等映射的问题，用学习残差F(x)&#x3D;0更新该冗余层的参数来代替学习h(x)&#x3D;x更新冗余层的参数。\nNorm（层归一化，Layer Normalization）用于将每一层的输出进行标准化，保持均值为 0，方差为 1。它有助于加速训练，并且提高模型的稳定性。 使用到的归一化方法是Layer Normalization)\nLN是在同一个样本中不同神经元之间进行归一化，而BN是在同一个batch中不同样本之间的同一位置的神经元之间进行归一化。BN是对于相同的维度进行归一化，但是咱们NLP中输入的都是词向量，一个300维的词向量，单独去分析它的每一维是没有意义地，在每一维上进行归一化也是适合地，因此这里选用的是LN。\n  \n\n\n\n6. 前馈神经网络 Position-wise Feed-Forward Networks（FFN）\n\n在 Transformer 中，前馈网络层（Feed-Forward Network，FFN）的作用可以概括为一句话： “对每个位置的向量进行非线性变换，增加模型的表达能力。\n全连接层是一个两层的神经网络，先线性变换，然后ReLU非线性，再线性变换。这两层网络就是为了将输入的Z映射到更加高维的空间中然后通过非线性函数ReLU进行筛选，筛选完后再变回原来的维度经过6个encoder后输入到decoder中。\n7. 三种注意力对比学习（三种注意力）Masked Attention、Self-Attention 和 Cross-Attention 的本质是一致的，这一点从代码调用可以看出来，三者的区别在于未来掩码的使用和输入数据的来源：\n\nMasked Attention：用于解码过程，通过掩码屏蔽未来的时间步，确保模型只能基于已生成的部分进行预测，论文中解码器部分的第一个 Attention 使用的是 Masked Self-Attention。\n\nSelf-Attention：查询、键和值矩阵来自同一输入序列，模型通过自注意力机制学习输入序列的全局依赖关系。\n\nCross-Attention：查询矩阵来自解码器的输入，而键和值矩阵来自编码器的输出，解码器的第二个 Attention 模块就是 Cross-Attention，用于从编码器输出中获取相关的上下文信息。\n以机器翻译中的中译英任务为例：对于中文句子 “中国的首都是北京”，假设模型已经生成了部分译文  “The capital of China is”，此时需要预测下一个单词。\n在这一阶段，解码器中的交叉注意力机制会使用当前已生成的译文 “The capital of China is” 的编码表示作为查询，并将编码器对输入句子 “中国的首都是北京” 编码表示作为键和值，通过计算查询与键之间的匹配程度，生成相应的注意力权重，以此从值中提取上下文信息，基于这些信息生成下一个可能的单词（token），比如：“Beijing”。\n\n\n需要掩码注意力的原因在解码阶段，每一步生成的词语只依赖于前面已生成的词语。因此，需要通过 掩码（Masking） 来确保每个位置的注意力只关注其前面的位置，而不允许查看未来的位置。\n输入需要编码器的输入的原因解码器需要编码器的输出作为上下文信息来生成最终的目标序列。编码器提供的上下文信息有助于解码器更好地理解输入序列的语义和结构。\n解码器和编码器的输出\n编码器的输出：编码器生成的隐藏状态序列，包含了输入序列的语义信息。这些信息将被解码器用于生成最终的输出。\n解码器的输出：解码器根据编码器的输出和已生成的部分输出，逐步生成目标序列（首先经过一次线性变换（线性变换层是一个简单的全连接神经网络，它可以把解码组件产生的向量投射到一个比它大得多的，被称为对数几率的向量里），然后Softmax得到输出的概率分布（softmax层会把向量变成概率），然后通过词典，输出概率最大的对应的单词作为我们的预测输出。）\n\n8. GPT与 Transformer 的关系GPT，即 Generative Pre-Training Language Model，是由 OpenAI 团队于 2018 年发布的预训练语言模型。虽然学界普遍认可 BERT 作为预训练语言模型时代的代表，但首先明确提出预训练 - 微调思想的模型其实是 GPT。\nGPT 提出了通用预训练的概念，也就是在海量无监督语料上预训练，进而在每个特定任务上进行微调，从而实现这些任务的巨大收益。虽然在发布之初，由于性能略输于不久后发布的 BERT，没能取得轰动性成果，也没能让 GPT 所使用的 Decoder-Only 架构成为学界研究的主流，但 OpenAI 团队坚定地选择了不断扩大预训练数据、增加模型参数，在 GPT 架构上不断优化，最终在 2020 年发布的 GPT-3 成就了 LLM 时代的基础，并以 GPT-3 为基座模型的 ChatGPT 成功打开新时代的大门，成为 LLM 时代的最强竞争者也是目前的最大赢家。\n9. 相关资料Transformer 论文精读\nCSDN博客文章\nTransformer快速入门\n","categories":["transformer"],"tags":["AI"]},{"title":"python相关","url":"/2025/08/28/python%E7%9B%B8%E5%85%B3/","content":"装饰器\n"},{"title":"从当下开始","url":"/2025/08/23/%E4%BB%8E%E5%BD%93%E4%B8%8B%E5%BC%80%E5%A7%8B/","content":"对学历的理解本硕双非，曾经的理解，双非就像一个标签刻在自己身上，也是会有一种想法，觉得考上双非特别是研究生，是不是落后别人一大截，怎么挺身而出？其实在现在看来，我不会这么想了，每个人都会有自己的一段路程，在读研的过程中，我深刻体会到需要自洽、自强，好的学历会接触更多优秀的人、有更好的资源，强大的开始就是对学历祛魅跟自己和解，找到自己的舒服方式，接触更多优秀的人，让自己有实力有能力去接受挑战，双非不是标签，理性看待学历，专注于自身硬实力和软实力的成长。\n对自律的理解最近在寻找 AI 相关资料时，看到了一个博主的技术博客，特别是博主写的碎碎念。我开始深思：自己在过去的一段时间里，好像不太明白学习的目的究竟是什么，没有明确坚定的方向，学习似乎更多是为了感动自己。我开始思考何为自律，是自愿的学习，还是仅仅担忧未来是否能够有一个好的事业。回头想想，我没有坚持培养积极的爱好，容易陷入误区。\n我也看到许多高考励志的故事，或许在今后的路上，我再也不会指责过去的自己。无论结果如何，如果可以再来一次，我可能会走上相似的道路，经历相似的挑战。\n关于学习与成长我很喜欢阅读美文，自己表达的能力并不强，常常遇到一些好的文章或句子时，会将它们收藏起来。在业余时间，我会选择去阅读书籍，这是之前的领导给我的建议，很多事情其实可以在书中找到答案。虽然一些道理我已经看过很多遍，但真正能执行下去的却并不多。\n从这么长时间的读书生涯中，我意识到自己并不是一个特别擅长学习的人，对自己的专业也没有特别深的热爱。有时候，学习并没有深入专研，我一直处于输入阶段，却没有足够的输出。与此同时，我也意识到软实力同样重要——交际表达、为人处事等等。\n未来的路在今后的日子里，可能我会走得比较慢，但我依然希望不负当下的时光，成为一个更好的自己。我会向优秀的人学习，跳出眼前的视野，继续前行。\n","categories":["碎碎念念"],"tags":["碎碎念念"]},{"title":"大模型基础","url":"/2025/08/30/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80/","content":""},{"title":"知识图谱","url":"/2025/08/30/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/","content":"知识图谱实体在自然语言处理中，实体（Entity）通常指的是文本中具有独立存在、能够被明确识别并且具有特定意义的对象。实体通常是指一些特定的名词，它们代表现实世界中的对象或概念，可以是人、地点、组织、事件、日期、物品、概念等。\n例如：\n\n人名：维克托·迈尔-舍恩伯格、肯尼斯·库克耶\n地点：北京、美国\n组织名：微软公司、谷歌\n事件：新冠疫情、2024东京奥运会\n日期：2024年12月、2023年11月\n物品：iPhone、蓝牙耳机\n概念：大数据、机器学习\n\n知识图谱中的实体\n在知识图谱中，每个实体都有其独特的标识符和属性（例如，姓名、类型、描述等）。这些属性和关系帮助我们理解实体在特定领域中的作用和上下文。实体识别是图谱构建的重要步骤之一。\n例如，假设我们有以下句子：”维克托·迈尔-舍恩伯格是《大数据时代》一书的作者，他是大数据领域的专家。”\n在这个句子中，实体包括：\n\n维克托·迈尔-舍恩伯格（人名）\n《大数据时代》（书名）\n大数据领域（概念）\n\n这些实体在知识图谱中将被标识为节点，并且可以与其他节点（如其他作者、书籍、领域等）通过关系（如“写书”，“属于领域”）连接，形成知识图谱中的一个网络结构。同时，在知识图谱中，实体是基础组成单元，它们通过关系（relationship）连接，构成一个图的结构。实体和关系是构建知识图谱的两个基本元素。实体之间的连接关系定义了图谱中的知识和数据。\n","categories":["知识图谱"],"tags":["知识图谱"]},{"title":"实习感想","url":"/2025/08/27/%E5%AE%9E%E4%B9%A0%E6%84%9F%E6%83%B3/","content":"实习感受在不知不觉中，实习已经有一个多月的时间了，简单概括一下这段经历。\n回想起在找实习的这段时间里，其实我是有点儿担忧和害怕的心理的。坦白说我的简历项目全是网上 Copy 的，接触 AI 这个方向也是因为小红书上面的博主分享的一些经历，跟着博主的路径，了解到 AI 应用开发这个新的方向，目前赛道还不是很卷。之前也接触过 AI 低代码平台，想着试一试。\n公司是一个比较大一点的外包公司，要说有啥活，倒是真的没啥活，项目也不是很多。坦白说，要想在这个公司学点高一点的技术还是很难的，部门主要是后端开发的部分，AI 刚刚起步。目前做的相关技术就是 LangChain 实现 RAG 系统，Python 后端相关的技术，暂时还没有涉及到大模型微调和 RAG 优化技术。\n公司的领导同事们比较好，有一种亲切感，虽然没有专门的部门在这边，但是我能感觉到氛围还算不错的。也认识了中国海洋大学的本硕同事，他也教会我一点 AI 相关的东西，然后也接触了比我年长的广哥，跟他说话聊天还挺好玩，我还专门向他请教关于电脑刷机相关的知识。\n最后想对自己说，确实是先出发很重要，慢慢认识自己，定目标，达到成就，有责任感，让自己充满力量去抵御未知的困难。最后呢，还是挺感恩每一次的遇见，记录每个阶段的感受，达成阶段性可实现的目标和计划，最后也要好好生活，认真对待当下的时光。\n\n在 8 月也向前同事学习了下，他告诉我很多道理，比如学会做实事、定阶段性的目标和规划、学会理财（当然得先有资本，但得有意识）\n\n\n","categories":["实习"],"tags":["实习感想"]},{"title":"python 依赖管理","url":"/2025/08/28/python-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/","content":"\n本文主要介绍python中虚拟环境管理的另一种方式uv，开始接触深度学习conda用得比较多，后面发现有的项目是用uv进行环境管理，因此简单介绍一下这种方式。我的理解就是conda和uv都可以用来创建虚拟环境，如果是深度学习项目可使用conda建立虚拟环境，uv来下载依赖。其余的如web项目都可以使用uv来建立环境来进行管理依赖\n\nPython-uv虚拟环境管理uv简介uv和conda一样是python中的包管理工具，与其他Python中的包管理工具相比，uv更像是一个全能选手，有以下优势：\n\n速度快\n统一管理 Python 版本\n自动解决依赖冲突\n跨平台一致性\n\nuv工具主要使用的两个文件：\npyproject.toml：定义项目的主要依赖，包括项目名称、版本、描述、支持的 Python 版本等信息uv.lock：记录项目的所有依赖，包括依赖的依赖，且跨平台，确保在不同环境下安装的一致性。由 uv 自动管理，不用手动编辑\nuv安装\n主要介绍在windows uv的安装，以及uv建立虚拟环境，下载依赖\n\n# On Windows.powershell -ExecutionPolicy ByPass -c &quot;irm https://astral.sh/uv/install.ps1 | iex&quot;# With pip.pip install uv\n\nuv使用# 创建指定 Python 版本的环境uv venv --python=3.11 myenv# 从 requirements.txt 安装（带哈希校验！）uv pip install -r requirements.txt# 生成精简版依赖uv pip compile requirements.in -o requirements.txt# 查看当前环境已安装的依赖uv pip list#安装依赖并写入 pyproject.tomluv add requests #移除依赖uv remove requests #同步依赖到虚拟环境uv sync #导出 lock 文件为 requirements.txt 等格式uv export #构建源码包和 wheeluv build发布到 PyPI #发布到 PyPIuv publish \n\nuv安装并设置镜像\nuv使用\n相关资料python环境管理大比拼\nuv管理\n","categories":["python"],"tags":["python环境管理"]}]