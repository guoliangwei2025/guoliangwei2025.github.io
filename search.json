[{"title":"AI应用开发","url":"//post/AI%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.html","content":""},{"title":"GraphRAG","url":"//post/GraphRAG.html","content":"GraphRAG（一）GraphRAG简介\n\n\n\n\n\n\n\n\n基本的RAG系统通常集成向量数据库和LLM，对知识库进行嵌入存入向量数据库，后根据相似度计算，从向量数据库中检索到相关的片段作为大模型的上下文。但是这种在处理复杂的任务时候，如联系不同信息片段全面回答问题有些局限。 \n与使用向量数据库检索语义相似文本的基本 RAG 不同，GraphRAG 则采取了一种创新的路径，首先利用大型语言模型从非结构化文本数据中提取出实体和关系，并据此构建一个知识图谱。接着，依托图谱的拓扑结构进行社区发现，对每个社区进行逐层总结，最终形成一个分层且结构化的知识网络。在进行查询时，GraphRAG 利用这一知识网络来强化信息检索，从而为模型提供更具启发性的上下文，以回答那些需要深度推理和全局视角的问题。（结合传统的图数据库查询和强大的生成模型）\n\n索引（Indexing）：这是 GraphRAG 的数据处理阶段，它将非结构化文本转化为结构化知识。主要步骤包括：\n\n文本分块：将长文档切分成小的文本单元（TextUnit）；\n图谱提取：利用大模型从文本单元中提取出实体（Entities）和关系（Relationships），构建知识图谱；\n社区发现：使用 Leiden(图谱聚类算法) 等算法对图谱进行层次化社区聚类；（不同的社区指的是不同的知识结构或者主题）\n社区总结：利用大模型为每个层级的社区生成摘要报告；\n\n\n查询（Querying）：这是 GraphRAG 的数据检索与问答阶段，利用构建好的知识图谱和摘要来回答问题。比较常见的查询方式有：\n\n全局搜索（Global Search）：利用社区摘要，通过 Map-Reduce 的方式对整个数据集进行归纳总结，回答宏观问题；\n本地搜索（Local Search）：当问题涉及特定实体时，从该实体出发，在知识图谱中向外扩展，聚合其邻近的实体、关系以及相关的原始文本块，为大模型提供精准的局部上下文\n\n\n\n\n\n\n\nGraphRAG快速入门\n\n\n\n\n\n\n\n\n本文章是在腾讯云(免费GPU)上进行，使用的模型服务商是硅基流动，下面走进GraphRAG的开始吧！\n\n\n\n\n\n\n\n\n\n在这个平台上可以选择创建各种不同的环境，这里选择Pytorch的环境，如果要跑简单的深度学习也可以使用这个环境\n\n\n创建虚拟环境#使用conda创建graphrag虚拟环境conda create -n graphrag python=3.10#安装graphragpip install graphrag\n\n准备demo数据# 创建demo目录mkdir -p ./ragtest/input# 下载微软官方demo数据curl https://www.gutenberg.org/cache/epub/24022/pg24022.txt -o ./ragtest/input/book.txt\n\n\n\n\n\n\n\n\n\n\n初始化demo目录 执行这个命令之后 将在 ./ragtest目录中创建两个文件：.env和settings.yaml\n因为默认生成的是跟GPT模型相关的配置文件，国内使用获取其API不太方便，因此需要修改使用，这里使用硅基流动的模型服务，大模型选择deepseek-v3，嵌入模型选择 BAAI/bge-large-zh-v1.5\ngraphrag init --root ./ragtest\n\n\n\n\n\n\n\n\n\n\n修改配置文件 在settings.yaml 文件中修改初始的模型，然后再.env文件中的API为硅基流动的API\nmodels:  default_chat_model:    type: openai_chat    api_base: https://api.siliconflow.cn/v1    api_key: $&#123;GRAPHRAG_API_KEY&#125;    model: deepseek-ai/DeepSeek-V3    encoding_model: cl100k_base    concurrent_requests: 3    requests_per_minute: 30  default_embedding_model:    type: openai_embedding    api_base: https://api.siliconflow.cn/v1    api_key: $&#123;GRAPHRAG_API_KEY&#125;    model: BAAI/bge-large-zh-v1.5    encoding_model: cl100k_base    concurrent_requests: 3     requests_per_minute: 30\n\n构建索引\n\n\n\n\n\n\n\n\n执行如下命令将自动完成\n文本分块 、实体识别与关系提取（调用大模型）、构建实体-关系图谱、社区检测（Leiden算法）、生成社区摘要（调用大模型）、嵌入计算 + 向量索引构建（花费时间较长）\ncd ragtestgraphrag index --root .\n\nragtest目录结构详解\n\n\n\n\n\n\n\n\n\nragtest&#x2F; ├── settings.yaml      # 配置文件 ├── prompts&#x2F;           # 提示词模板 ├── input&#x2F;             # 数据输入目录（需手动创建） ├── .env               # 存储 API 密钥 └── output&#x2F;            # 自动生成的索引结果\n\n\n\n\n\n\n\n\n\nGraphRAG 使用 Parquet 存储数据，这是一种列式存储的二进制文件格式，专为高效存储和处理大规模结构化数据而设计，广泛用于大数据处理和分析场景。另外，LanceDB 是一个为机器学习优化的向量数据库，使用 Apache Arrow 格式存储。GraphRAG 使用它来存储文本嵌入向量，用于相似性搜索。\nGraphRAG 输出文件详解\n\n\n\n查询GraphRAG 输出文件概览\n\n\n文件&#x2F;目录\n作用\n内容\n理解\n\n\n\ndocuments.parquet\n存储原始文档的元信息与全文内容\n每个文档一个条目，包含 title、text、doc_id\n原始文档的索引表\n\n\ntext_units.parquet\n存储文档分块（chunk）后的切片内容\n每一块对应一次 LLM 调用（如实体提取），记录切分后的每个 chunk 的内容\n分块后的最小处理单元\n\n\nentities.parquet\n存储从所有文档中提取的实体信息\n实体名称、类型（人物、组织、地点、事件）、出现频率、描述、出现在哪些块中\n知识图谱的节点（Node）\n\n\nrelationships.parquet\n存储实体之间的语义关系\n两个实体之间的关系（如 “张三-管理-产品部”），关系描述、类型、权重\n知识图谱的边（Edge）\n\n\ncommunities.parquet\n存储社区检测结果\n基于图谱运行社区检测算法得到的“主题组”，每个社区包含一组相关实体\n自动发现的主题集群\n\n\ncommunity_reports.parquet\n为每个社区生成自然语言摘要\n报告标题、摘要、主要发现，由 LLM 生成，面向用户\n社区的结构化报告，便于理解主题\n\n\nlancedb/\n存储文本单元的向量表示\n用于局部语义搜索\n为后续检索提供 embedding 索引\n\n\n全局搜索（Global Search）：适用于需要对整个数据集进行宏观理解和总结的问题：\n本地搜索（Local Search）：适用于查询关于特定实体的具体信息：\n相关资料GraphRAG本地部署使用及兼容千帆通义\nGithub地址\n文档地址\ngraphrag-more地址\nGraphRAG全流程实战\nGraphRAG快速入门\nGraphRAG详解\nGraphRAG快速入门与原理详解（索引建立的详细举例介绍）\n","categories":["GraphRAG"],"tags":["GraphRAG"]},{"title":"Agent Skills","url":"//post/Agent-Skills.html","content":"Agent Skills\n\n\n\n\n\n\n\n\nAgent Skills 一句话总结就是带目录的说明书。\n渐进式披露原则分阶段，按需加载\n\n\n\n\n\n\n\n\n\nSkill是模块化的能力，包含指令、脚本和资源。每个Skills都是一个个独立的文件夹，每个Skill做一件事。\n每个Skill文件夹包含：\nSKILL.md（核心指令文件，必需）\nscripts&#x2F;（可执行脚本，可选）\nreferences&#x2F;（参考文档，可选）\nassets&#x2F;（模板和资源，可选）\nClaude会根据任务描述，自动判断需要哪个Skill，然后加载\n如下图所示，Agent Skill中包含元数据层、指令层和资源层。\n元数据层：SKILL.md文件开头的YAML部分，就两个字段：name和description。（总是加载）\n---name: ai-proofreadingdescription: 系统化降低AI检测率，增加人味。使用场景：审校文章、降低AI味、初稿完成后。---\n\n指令层：SKILL.md的主体部分，详细的操作指南，只有当用户请求匹配某个Skill的description时候，才会加载Skill的完整内容。\n资源层：scripts&#x2F;目录里的脚本、references&#x2F;目录里的参考文档、assets&#x2F;目录里的模板。只有当SKILL.md中的指令引用这些文件时才加载。脚本执行后只有输出进入上下文，代码本身不占Token。（脚本只执行不消耗Token）\n\n\n\n\nSkills vs MCP vs SubagentMCP让Claude能碰到外部系统。Skills告诉Claude碰到之后怎么用。Subagent是派一个人出去干活。\nMCP（Model Context Protocol）MCP是一个连接协议，可以让Claude能够访问外部系统：数据库、API、文件系统、各种SaaS服务。\n\n\n\n\n\n\n\n\n\n你可以把MCP想象成”给Claude发工具”。\n比如GitHub MCP，让Claude能够读取仓库、创建PR、管理Issues。Notion MCP，让Claude能够读写Notion页面。\nMCP的核心价值是连接。它解决的问题是”Claude能访问什么数据”。\nSkillsSkills是什么？使用手册。它告诉Claude拿到数据之后怎么用。\n\n\n\n\n\n\n\n\n\n比如你用GitHub MCP连接了仓库，Claude能读代码了。但”怎么做代码审查”——检查哪些方面、用什么标准、输出什么格式——这些是Skills的工作。你可以把Skills想象成”教Claude怎么用工具”。Skills的核心价值是程序化知识。它解决的问题是”Claude应该怎么做”。\nSubagentSubagent是什么？派出去干活的人。\n\n\n\n\n\n\n\n\n\n当你让Claude Code派一个Subagent去做任务时，Claude会新开一个独立的对话会话。这个Subagent有自己的上下文窗口、自己的系统提示、自己的工具权限。它干完活，把结果带回来。\n你可以把Subagent想象成”派一个助手出去”。\nSubagent的核心价值是并行执行和上下文隔离。它解决的问题是”怎么处理复杂的多步骤任务”。\n\n\n\n维度\nMCP\nSkills\nSubagent\n\n\n\n核心作用\n连接外部系统\n提供程序化知识\n并行执行任务\n\n\n类比\n发工具\n使用手册\n派助手\n\n\nToken消耗\n高（预加载能力描述）\n低（按需加载）\n高（独立会话）\n\n\n技术门槛\n需要写代码、配服务器\n写Markdown就行\n需要配置\n\n\n能访问外部数据\n✅\n❌\n❌\n\n\n适用场景\n需要实时数据\n重复性工作流\n复杂多步骤任务\n\n\nMCP为什么Token消耗大？\n\n\n\n\n\n\n\n\n\nMCP需要预先加载所有能力的描述。连接一个MCP服务器，Claude就要知道这个服务器能做什么、每个功能怎么调用、参数是什么。这些描述加起来，动辄几万tokens。Skills不一样。平时只加载元数据（100 tokens&#x2F;Skill），需要时才加载完整内容。\n简介即优势\n\n\n\n\n\n\n\n\n\nMCP是一个完整的协议规范。要实现一个MCP服务器，需要：\n\n理解协议结构\n写服务端代码\n配置JSON\n处理通信\n\n“Skills只是Markdown加上一点YAML元数据，和一些可选的脚本。”\n跨平台兼容\n\n\n\n\n\n\n\n\n\nMCP服务器是特定于宿主的。为Claude Code写的MCP服务器，不一定能直接用在其他地方。\nSkills不一样。它就是文件夹，里面是Markdown和脚本。\n如何创建Skills学习资源Claude Skills完全指南：从概念到实战\nAgent Skill 从使用到原理\nOpenCode+OmO+skills上手指南\n","categories":["AI"],"tags":["AI"]},{"title":"10月小结","url":"//post/10%E6%9C%88%E5%B0%8F%E7%BB%93.html","content":"10月总结在11月的开始来回看10月，似乎也不知道怎么来总结过去的一个月。我觉得在对于科研这件事情来说，有的时候，做实验也好，找创新思路也好，可能有的时候真的成效很少，很多负反馈，可能有的时候都会怀疑人生了。但是在研究生的任务又不能不允许我们每个人抛开这件事情，毕业严格，硕士扩招，等待的又是什么呢。所以呢，我觉得在当下自己，可以放慢脚步，但是确实需要去考虑时间，去追溯未来，完整的过好当下，可能会遇到各种挫败，但是也要相信，失败的代价我是可以承受的，也可以重新站起来去面对各种困难，最终成为强大的自己。\n11月的目标11月对我而言是忙碌的一个月，有很多需要去做的事情，我给自己定的目标是，一步步脚踏实地，争取每天进步一点点。当然，今年的考试肯定是要好好准备的，得分开一些精力去做和去思考一些事情，不能太过于茫然，把时间花在重要的事情上。不瞎想，以当下最重要的事情为主。\n","categories":["反思总结"],"tags":["10月小结"]},{"title":"LangChain","url":"//post/LangChain.html","content":"\n\n\n\n\n\n\n\n\n本篇文章主要介绍LangChain基础语法，RAG原理，以及使用LangChain实现简易的RAG系统，详细的RAG优化以及类型在另外的文章进行介绍\n1.LangChain 简介Langchains是用于开发大模型驱动的框架，借助LangChain可以轻松搭建基于LLM的相关应用，比如RAG系统\n此框架包含以下部分：\nlangchain-core: 基础抽象和LangChain表达式 (LCEL)langchain-community: 第三方集成，第三方相关的包langchain: 组成应用程序认知架构的链、代理和检索策略。LangGraph: 通过将步骤建模为图中的边和节点，构建强大且有状态的多参与者应用程序。与LangChain无缝集成，但也可以单独使用LangServe: 将LangChain链部署为REST APILangSmith: 一个开发者平台，让您调试、测试、评估和监控LLM应用程序\n\n\n\n\n\n\n\n2.LangChain 基础\n\n\n\n\n\n\n\n\nLangChain是为大模型应用而生的框架，结合大模型应用逻辑上，分为输入、模型处理、输出三个环节。通过构建提示词工程，作为上下文给大模型，然后通过结果解析器解析相应格式的输出\nLCEL表达式基于LangChain框架编写大模型应用的过程就像垒积木，其中的积木就是Prompts，LLMs和各OutputParser等。如何将这些积木组织起来，除了使用基本Python语法调用对应类的方法，一种更灵活的方法就是使用位于LangChain-Core层中的LCEL（LangChain Expression Language）(使用管道符来进行拼接)\nRunnable接口LCEL的基础是Runnable接口。通过实现Runnable接口，LCEL定义了一组具有通用调用方式的方法集。\nRunnable有一系列的子类，比如PromptTemplate、LLM和StrOutputParser（还有更多），这些组件子类都间接继承自Runnable(继承自RunnableSequence，而后者又继承自Runnable) 通过 管道符”|”前后两个组件合成一个Runnable的子孙类RunnableSequence对象返回，从而达到串起来形成链(chain)的目的。\n\n\n\n\n\n\n\n\n\nRunnable的__or__()方法重新定义了”|”语法，所以基于LCEL的chain就能通过或(也类似shell中的管道)操作符号”|”串起来。这也就是前面提到的“chain &#x3D; prompt | llm | output_parser”这行代码虽然看上去跟普通Python不一样，但它是合法的，原因就在这里\n3.LangChain实现RAG\n\n\n\n\n\n\n\n\nRAG的出现是为了在一定程度上缓解大模型的幻觉问题，因为大模型的输出是基于数学概率的输出预测、且信息不具有实效性、缺乏相关领域的专业知识，下面使用LangChain的链式调用实现简单的RAG。\n基础RAG系统，流程如下：\n\n文档切分\n向量嵌入\n构建提示词\n定义大模型服务\n检索相关片段作为大模型上下文\n结果解析器对大模型结果进行解析\n\n\n\n#完整的rag  from langchain_core.output_parsers  import StrOutputParserquery = &quot;在线支付取消订单后钱怎么返还&quot;from langchain_community.embeddings import DashScopeEmbeddingsfrom config.load_key import load_keyif not os.environ.get(&quot;DASHSCOPE_API_KEY&quot;):    os.environ[&quot;DASHSCOPE_API_KEY&quot;] = load_key(&quot;LANGSMITH_API_KEY&quot;)embedding_model = DashScopeEmbeddings(model=&quot;text-embedding-v1&quot;)redis_url = &quot;redis://localhost:6379&quot;config = RedisConfig(    index_name=&quot;meituan-index&quot;,   # 索引名，对应之前构建的知识库索引    redis_url=redis_url,          # Redis 连接地址)vector_store = RedisVectorStore(embedding_model, config=config)retriever = vector_store.as_retriever()#定义大模型from langchain_openai import  ChatOpenAIllm = ChatOpenAI(    model = &quot;deepseek-v3&quot;,    base_url =&quot;https://dashscope.aliyuncs.com/compatible-mode/v1 &quot;,    openai_key = load_key(&quot;LANGSMITH_API_KEY&quot;),) #定义提示模板from langchain_core.prompts import  ChatPromptTemplateprompt_template = ChatPromptTemplate.from_messages([    (&quot;user&quot;, &quot;你是一个答疑机器人，你的任务是根据下述给定的已知信息回答用户问题。\\n&quot;             &quot;已知信息：&#123;context&#125;\\n&quot;             &quot;用户问题：&#123;question&#125;\\n\\n&quot;             &quot;如果已知信息不含用户问题的答案，或者已知信息不足以回答用户问题，请直接回复“我无法回答您问题”。\\n&quot;             &quot;请不要输出已知信息中不包含的信息或答案。\\n&quot;             &quot;请用中文回答用户问题。&quot;)  ])#收集document内容def collect_document_content(segments):    text = []    for segment in segments:        text.append(segment.page_content)    return textfrom operator import itemgetterchain = (&#123;     &quot;question&quot;: query,    &quot;context&quot;: itemgetter(&quot;question&quot;)|retriever |collect_document_content,&#125;| prompt_template| llm| StrOutputParser())response = chain.invoke(&#123;&quot;question&quot;: query&#125;)  \n\n4.相关资料大模型应用开发学习资料\nLangChain中文文档\nCSDN博客\n","categories":["Langchain"],"tags":["AI"]},{"url":"//post/MCP.html","content":"MCPFunction call\n\n\n维度\nFunction Calling（FC）\nMCP（Model Context Protocol）\n\n\n\n本质\n能力 —— 某个大模型原生就带的一种「调用函数」功能\n协议 —— 定义 AI 与外部世界如何长期、标准、可复用地交互\n\n\n工作方式\n模型在一次推理里主动决定要调用哪个函数，并吐出结构化参数\n通过「客户端 - 服务器」架构，由 MCP Server 被动等待模型或 Agent 的请求\n\n\n是否标准化\n否。OpenAI、Anthropic、百度等各家接口格式不同\n是。统一 JSON-RPC 2.0 协议，跨模型通用\n\n\n上下文管理\n单次调用，无状态；复杂多轮任务需自己维护\n协议层面支持会话、状态、长链路任务\n\n\n复用 &#x2F; 共享\n函数代码往往紧耦合在项目里，换模型就得重写\n一次写成 MCP Server，可被任何支持 MCP 的模型 &#x2F; IDE&#x2F;Agent 直接插用\n\n\nMCP介绍\n\n\n\n\n\n\n\n\n简单来说 MCP就是让大模型使用各类工具的协议\nMCP &#x3D; 双方交流的“共同语言&#x2F;协议”     指的就是环境 环境就是指周围有哪些函数可以用来调用  从而获取到外界的信息 比如获取天气信息 网络信息等等 MCP就是让模型感知上下文的协议 简称模型上下文协议 \nMCP server：其实就是一个「写好的工具&#x2F;程序」，通常是一个 NPM 包或者脚本。\nMCP client（比如 IDE 插件、AI 助手）：它不会自己实现功能，而是通过 启动你本地的 MCP server 来获得能力。\n执行方式：server 就是一个本地进程，本质就是运行命令（node、python、npx 等等），然后通过 标准输入&#x2F;输出 (stdin&#x2F;stdout) 用 MCP 协议通信。\n\n\n\n\n\n\n\n\n\nMCP server 不是远程服务，而是本地执行的工具，只是用 MCP 协议标准化了“如何跟这些工具说话”。\nMCP  Server是一个程序 程序的执行符合MCP协议\nnpx：临时拉取 npm 包到本地缓存 → 执行 → 不会马上删，但缓存会管理。\n\n\n如果同时配置了多个MCP服务，比如百度地图、Unity、Blender等。每个MCP服务需要对应Host中的一个Client来一对一通信。Client被包含在Host中。\n\n\n每个支持MCP的软件，都有一个MCP Server文件，里面列出了所有支持调用的函数，函数注释里的内容是给AI看的，告诉AI这个函数是做什么用的。MCP Server文件就是给AI看的工具说明书。\nMCP交互过程MCP交互过程如下：\n①cline与MCP server 进行寒暄    寒暄结束后，cline就知道MCP server中有哪些工具\n②用户提出问题后  cline接收到问题  将问题与注册好的MCP server 以及server中的工具列表 告诉给模型 \n③模型无法回答当前问题  但是MCP中有相应的工具可以调用 于是告诉cline 想调用MCP中的工具\n④cline接受到请求后  就跟对应的MCP server沟通  对应的MCP server 接收到请求后 调用对应的工具 返回相关的结果\n然后MCP server 将结果返回给 cline cline传给大模型\n⑤模型接收到回答后，将结果返回为cline，cline再将结果返回给用户\n\n\n\n\n\n\n\n\n\nMCP 过程的交互只涉及MCP Server 和cline的交互  不涉及跟大模型之间的交互  MCP没有规定如何与模型进行交互\nMCP协议主要规定了  ①每个MCP  Server 有哪些函数可以用  ②如何调用这些函数 总结为函数的注册和使用\n\n\nMCP 的本质MCP 就是host 和 MCP server交互的格式  (json格式)  这样不使用host 在命令行启动MCP server 输入相关的格式 就可以与MCP server进行通信\n\n\n\n\nMCP &#x3D; 一种「通信协议  + 本地扩展机制」。\nMCP server &#x3D; 各种各样的工具（新闻抓取、数据库查询、命令行工具…）。\nMCP client &#x3D; 统一的入口，把不同的工具“挂载”到 AI 或 IDE 里用。\nMCP 三种传输协议\n\n\n协议名称\n通信方式\n适用场景\n优势\n局限\n\n\n\nStdio（标准输入输出）\n使用进程的标准输入（stdin）和标准输出（stdout）进行本地通信，基于 JSON-RPC 2.0 格式\n本地开发、调试、IDE 插件、命令行工具\n简单易实现、跨平台、低延迟\n仅支持本地通信，无法跨网络，低并发\n\n\nSSE（Server-Sent Events）\n客户端通过 HTTP POST 发送请求，服务器通过 SSE 单向推送流式响应\n实时监控、新闻推送、远程服务调用\n基于 HTTP，浏览器友好，支持流式数据\n仅支持单向通信，MCP 官方已标记为 “即将废弃”\n\n\nStreamable HTTP（新型流式 HTTP）\n支持双向流式通信的现代 HTTP 协议，替代 SSE，支持会话恢复、OAuth 认证等\n分布式系统、高并发、双向实时交互\n双向通信、高性能、企业级安全机制\n实现较复杂，生态仍在发展中\n\n\n创建一个MCP server初始化项目\n\n\n\n\n\n\n\n\nuv init weather\n#进入weather执行如下命令\nuv sync\n.venv\\Scripts\\activate.bat\n#添加依赖uv add “mcp[cli]” httpx\n建立 weather.py# 导入类型提示模块，用于类型注解from typing import Any# 导入httpx库，用于发送HTTP请求import httpx# 从mcp.server.fastmcp模块导入FastMCP类# FastMCP是一个快速构建MCP（Model Control Protocol）服务器的框架from mcp.server.fastmcp import FastMCP# 创建FastMCP实例，命名为&quot;weather&quot;，日志级别设置为ERROR（只显示错误信息）mcp = FastMCP(&quot;weather&quot;, log_level=&quot;ERROR&quot;)# 常量定义# NWS（National Weather Service）API的基础URLNWS_API_BASE = &quot;https://api.weather.gov&quot;# 用户代理字符串，用于标识应用程序USER_AGENT = &quot;weather-app/1.0&quot;async def make_nws_request(url: str) -&gt; dict[str, Any] | None:    &quot;&quot;&quot;向NWS API发起请求并处理错误。        Args:        url: 要请求的API URL            Returns:        成功时返回解析后的JSON数据字典，失败时返回None    &quot;&quot;&quot;    # 设置请求头信息    headers = &#123;        &quot;User-Agent&quot;: USER_AGENT,           # 用户代理标识        &quot;Accept&quot;: &quot;application/geo+json&quot;    # 接受的数据格式    &#125;        # 创建异步HTTP客户端    async with httpx.AsyncClient() as client:        try:            # 发起GET请求，设置超时时间为30秒            response = await client.get(url, headers=headers, timeout=30.0)            # 如果响应状态码不是2xx，抛出异常            response.raise_for_status()            # 返回解析后的JSON数据            return response.json()        except Exception:            # 捕获所有异常，返回None表示请求失败            return Nonedef format_alert(feature: dict) -&gt; str:    &quot;&quot;&quot;将警报数据格式化为可读的字符串。        Args:        feature: 包含警报信息的字典            Returns:        格式化后的警报字符串    &quot;&quot;&quot;    # 获取警报属性    props = feature[&quot;properties&quot;]    # 格式化警报信息，使用get方法提供默认值防止键不存在    return f&quot;&quot;&quot;事件: &#123;props.get(&#x27;event&#x27;, &#x27;未知&#x27;)&#125;区域: &#123;props.get(&#x27;areaDesc&#x27;, &#x27;未知&#x27;)&#125;严重程度: &#123;props.get(&#x27;severity&#x27;, &#x27;未知&#x27;)&#125;描述: &#123;props.get(&#x27;description&#x27;, &#x27;无描述信息&#x27;)&#125;指示: &#123;props.get(&#x27;instruction&#x27;, &#x27;无具体指示&#x27;)&#125;&quot;&quot;&quot;# 使用@mcp.tool()装饰器将函数注册为MCP工具@mcp.tool()async def get_alerts(state: str) -&gt; str:    &quot;&quot;&quot;获取指定美国州的天气警报。        Args:        state: 两个字母的美国州代码（例如：CA, NY）            Returns:        格式化后的警报信息字符串    &quot;&quot;&quot;    # 构建获取州警报的URL    url = f&quot;&#123;NWS_API_BASE&#125;/alerts/active/area/&#123;state&#125;&quot;    # 发起API请求获取数据    data = await make_nws_request(url)    # 检查数据是否有效    if not data or &quot;features&quot; not in data:        return &quot;无法获取警报或未找到警报。&quot;    # 检查是否有警报    if not data[&quot;features&quot;]:        return &quot;该州无活动警报。&quot;    # 格式化所有警报    alerts = [format_alert(feature) for feature in data[&quot;features&quot;]]    # 用分隔符连接所有警报    return &quot;\\n---\\n&quot;.join(alerts)# 注册为MCP工具的天气预报函数@mcp.tool()async def get_forecast(latitude: float, longitude: float) -&gt; str:    &quot;&quot;&quot;获取指定位置的天气预报。        Args:        latitude: 位置的纬度        longitude: 位置的经度            Returns:        格式化后的天气预报字符串    &quot;&quot;&quot;    # 首先获取预报网格端点    points_url = f&quot;&#123;NWS_API_BASE&#125;/points/&#123;latitude&#125;,&#123;longitude&#125;&quot;    points_data = await make_nws_request(points_url)    # 检查点数据是否获取成功    if not points_data:        return &quot;无法获取此位置的预报数据。&quot;    # 从点响应中获取预报URL    forecast_url = points_data[&quot;properties&quot;][&quot;forecast&quot;]    forecast_data = await make_nws_request(forecast_url)    # 检查预报数据是否获取成功    if not forecast_data:        return &quot;无法获取详细预报。&quot;    # 将时间段格式化为可读的预报    periods = forecast_data[&quot;properties&quot;][&quot;periods&quot;]    forecasts = []    # 只显示接下来的5个时间段    for period in periods[:5]:        forecast = f&quot;&quot;&quot;&#123;period[&#x27;name&#x27;]&#125;:温度: &#123;period[&#x27;temperature&#x27;]&#125;°&#123;period[&#x27;temperatureUnit&#x27;]&#125;风力: &#123;period[&#x27;windSpeed&#x27;]&#125; &#123;period[&#x27;windDirection&#x27;]&#125;预报: &#123;period[&#x27;detailedForecast&#x27;]&#125;&quot;&quot;&quot;        forecasts.append(forecast)    # 用分隔符连接所有预报    return &quot;\\n---\\n&quot;.join(forecasts)# 程序入口点if __name__ == &quot;__main__&quot;:    # 初始化并运行服务器，使用stdio传输方式    mcp.run(transport=&#x27;stdio&#x27;)\n\n配置到cline中\n&quot;weather&quot;: &#123;    &quot;disabled&quot;: false,    &quot;timeout&quot;: 60,    &quot;command&quot;: &quot;uv&quot;,    &quot;args&quot;: [      &quot;--directory&quot;,      &quot;E:/MCP/weather&quot;,      &quot;run&quot;,      &quot;weather.py&quot;    ],    &quot;transportType&quot;: &quot;stdio&quot;  &#125;\n\n\n\n\n\n\n\n\n\n\n“disabled”: false 表示该服务是否被禁用。false 表示该服务是启用状态，可以正常运行。\n“timeout”: 60 设置该服务的超时时间，单位为秒。\n“command”: “uv” 指定执行该服务时使用的命令。\n“args” 出了执行 command 时需要传递的参数。\n“transportType”: “stdio” 指定服务的通信方式。stdio 表示标准输入输出流（Standard Input Output），通常用于进程间通信。\n大部分的MCP server是通过输入输出与cline沟通的，如果MCP server是在终端启动的，那可以直接看到输入和输出，但是目前是有cline启动的，输入输出只有cline才能看到\n相关资源mcp.so\n魔搭MCP广场\n百度搜索开放平台\nMCP b站视频\nMCP笔记\n"},{"title":"Typora教程","url":"//post/Typora%E6%95%99%E7%A8%8B.html","content":"Typora安装教程下载百度网盘下载地址（提取码tttt）\n验证序列号将从网盘中下载的app.asart替换掉下图软件目录下的文件\n\n\n\n\n序列号在key.txt，随便一个，输入序列号，即可成功\n\n\n\n\n\n\n\n\n\nkey:DZTX2H-6MCQZT-QL4GCT-5EBWFXG7LPKN-HP4NLD-FA3BGF-6JDQ5R3MH4Y8-YJWT37-G5JL9Y-UHNQDJ85ZPHY-ELQ9FQ-94J3VP-D92YLUVEZ7NV-USYN3G-8TL2N3-DADUG4\n选择以上的任一个输入就可以\n\n","categories":["工具"],"tags":["工具"]},{"title":"RAG","url":"//post/RAG.html","content":""},{"title":"fastApi项目","url":"//post/fastApi%E9%A1%B9%E7%9B%AE.html","content":"什么是FastApi一个用于构建API的现代、快速的Web框架，快速构建api，异步架构，易于使用和学习，自动生产的交互式文档。原生异步支持，释放真正性。\n\n\n同步和异步同步请求当出现I&#x2F;O阻塞时候，需等待I&#x2F;O操作完成在继续处理下一个请求，耗时较长\n异步请求当出现I&#x2F;O阻塞时，可以去执行其他的请求\n\n\n\n\n\n\n类型提示与验证\n\n\n路由分发\n\n路由  URL地址与处理函数之间的映射关系\n参数简介和路径参数\n参数就是客户端发送请求时附带的额外信息和指令，作用是让同一个接口能根据不同的输入，返回不同的输出结果\n\n\n路径参数 可以设置 对应的范围\n\n\n\n\n\n\n\n\n请求体参数 \n\n\n\n\n\n\n\n\n\n\n中间件\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n依赖注入\n可以让我们的视图函数在执行之前，先执行一段逻辑代码，这段逻辑代码可以返回新的值给视图函数\n就是将一些重复性的代码，单独写成依赖，在需要的视图函数中，注入这个依赖。\n使用场景：\n把公共的逻辑（比如处理分页参数、查询条件等）提取出来，让多个不同的 API 接口可以共享。\n共享业务逻辑、共享数据库连接\n实现安全、验证、角色权限 \nrestful风格的apiORMORM（Object-RelationalMapping,对象关系映射）是一种编程技术，用于在面向对象编程语言和关系型数据库之间建立映射。允许开发者通过操作对象的方式与数据库进行交互，而无需直接编写复杂的SQL语句。\n优势：\n减少重复的SQL代码\n代码更简洁易读\n自动处理数据库连接和事务\n防止SQL注入攻击\nORM使用流程\n①安装\n②建库建表\n③操作数据\n\n\n\n\n\n\n\n\n\n\nUvicorn 主要是用来运行fastapi的\n\n\n\n\nPydantic 模型Pydantic是一个基于 Python 类型注解（type hints） 的：\n\n数据校验（validation）\n数据解析（parsing）\n数据序列化（serialization）\n\n\n\n\n\n\n\n\n\n\n用类型定义数据结构，用模型自动校验和转换数据\n","categories":["fastApi"],"tags":["fastApi"]},{"title":"LangGraph","url":"//post/LangGraph.html","content":"LangGraph图控制Agent    \n开发Agent\n节点 边\n","categories":["AI"],"tags":["LangGraph"]},{"title":"hexo博客搭建教程","url":"//post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B.html","content":"\n\n\n\n\n\n\n\n\n初衷：\n我记得在刚上大三那会儿，想把自己学的一些东西记录到微信公众号上。刚开始坚持了几天，但是后来放弃了，因为大部分是Copy，也缺少自己的思考。\n经过最近的经历，我明白了一个道理：记录也是一个输出的过程。先自己理解，再把学习内容记录下来（记录适合自己学习或者找资料的过程），也是一种输出。\n所以，我决定从此开始，记录自己的过程，无论是：\n技术学习 、碎碎念  、成长困惑  、考试学习\n我想说，我可能走得很慢，但是我不会停下来，向内生长，加油!\n1. hexo介绍正如hexo的首页所显示的，它是一款非常快速，简介，高效的博客框架平台，我们可以利用hexo快速生成博客网站的模板，然后部署为我们自己的博客网站\n\n\n2. hexo教程下面博客记录完整搭建的教程，比较简易，我就是根据这个教程来搭建的，简短的时间就可以搭建一个属于自己的博客。\n其中主要步骤包括：\n\n软件的安装如git、Nodejs\nhexo部署到Github\nhexo配置（如用户个人信息、头像、主题下载配置分类目录）\n\n配置好hexo以及主题之后就可以开始写个人博客了，常见的命令是 \nhexo  clean             # 清除缓存文件和生成的静态文件hexo  new &quot;文章名称&quot;     # 新建界面hexo  generate          # 生成静态文件 可以简写成hexo g hexo  server            # 启动服务器   可以简写hexo shexo  deploy            # 部署网站，构建在GitHub的服务器中，网页文件将上传到关联的个人仓库 可以简写成hexo d\n\n\n\nHexo+Next部署github搭建个人博客+优化全过程（完整详细版）\n3. hexo中图片上传问题\n\n\n\n\n\n\n\n\n平时我们写文章可能会记录相关的图片，我个人也喜欢将别人写得好好理解的图片记录下来，但是在图片处理的过程中遇到一些问题（网上的方法各异，试了很多都不行），找了很多的教程，也是自己没有好好思考问题出在哪里，弄了很长时间，最后发现了相应的问题，仅以此记录我的处理方式。（参考CSDN并修改）\nTypora安装Typora\nTypora破解教程(破解序列号在评论区)\n​       修改Typora 偏好设置  如下图更改，此操作将图片文件保存路径: .&#x2F;${filename} 即保存到与 当前正在编辑的文件名相同的同级文件\n\n\n修改hexo配置修改_config.yml中的post_asset_folder，false 改为 true，这样修改后，每次 hexo new page生成新文章，都会在文章文件同级目录创建一个与文章文件名同名的文件夹，我们就在这里存放此文章的图片\n注：在md文档中存放的路径为文件夹/图片名称  \n之前找到有一种方式自定义安装一个插件，将md文档中的路径进行转换，第一天可以，但是第二天就不可以，找了很多办法，还是借助AI写了一个脚本实现相应的功能\n\n\n\n\n\n\n具体实现以下是在 hexo 中实现：Markdown 写 文件夹/图片名称 也能自动到相对应文章资源文件夹并生成 &#123;% asset_img %&#125; 标签。（使用插件进行实现）\n创建文件夹mkdir hexo-asset-imgcd hexo-asset-imgnpm init\n\n编写插件index.js&#x27;use strict&#x27;;/** * md文件返回 true * @param &#123;*&#125; data  */function ignore(data) &#123;    // TODO: 好奇怪，试了一下, md返回true, 但却需要忽略 取反!    var source = data.source;    var ext = source.substring(source.lastIndexOf(&#x27;.&#x27;)).toLowerCase();    return [&#x27;md&#x27;,].indexOf(ext) &gt; -1;&#125;function action(data) &#123;    var reverseSource = data.source.split(&quot;&quot;).reverse().join(&quot;&quot;);    var fileName = reverseSource.substring(3, reverseSource.indexOf(&quot;/&quot;)).split(&quot;&quot;).reverse().join(&quot;&quot;);    // ![example](postname/example.jpg)  --&gt;  &#123;% asset_img example.jpg example %&#125;    var regExp = RegExp(&quot;!\\\\[(.*?)\\\\]\\\\(&quot; + fileName + &#x27;/(.+?)\\\\)&#x27;, &quot;g&quot;);    // hexo g    data.content = data.content.replace(regExp, &quot;&#123;% asset_img $2 $1 %&#125;&quot;,&quot;g&quot;);    // log.info(`hexo-asset-img: filename: $&#123;fileName&#125;, title: $&#123;data.title.trim()&#125;`);        return data;&#125;hexo.extend.filter.register(&#x27;before_post_render&#x27;,(data)=&gt;&#123;    if(!ignore(data))&#123;        action(data)    &#125;&#125;, 0);\n\n本地测试插件\nHexo 根目录下 package.json 中 dependencies 添加一行 &quot;hexo-asset-img&quot;: &quot;^1.0.0&quot;, \n\n将 hexo-asset-img 文件夹复制到 Hexo 根目录下 node_modules 文件夹下 \n   hexo clean &amp;&amp; hexo g   hexo s # 本地预览   #编译后的文件在public文件夹下Markdown 图片写法在 Markdown 里可以写带文件夹的图片：```markdown![示例](demo/demo.png)![另一张](test/other.png)\n\n\n\n\n\n\n\n\n\n\n图片相对路径是相对于 Markdown 文件所在目录。\n4.Netlify部署Netlify部署方法\n5. 相关资料插件方法 （插件方法可行）\n","categories":["博客搭建教程"],"tags":["博客搭建教程"]},{"title":"hot100题-双指针","url":"//post/hot100%E9%A2%98-%E5%8F%8C%E6%8C%87%E9%92%88.html","content":"移动零（283）283. 移动零\n\n\n\n\n\n\n\n\n\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n①两次单循环，一次用于将数组中大于0的数移动到首部，然后另一次将后面的值补上0\nclass Solution:    def moveZeroes(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        k = 0        for i in range(len(nums)):            if nums[i]:                nums[k] = nums[i]                k += 1        for i in range(k,len(nums)):            nums[i] = 0\n\n②使用快慢双指针，快慢指针都是从头开始，快指针出发去寻找大于0的数（只有在大于0的时候才进行交换），然后左指针指向为0的数或者就是大于0 的数，交换两个元素的值，然后左指针右移动。右指针左侧一直到左指针，中间都是0。（如果都是正数，那本质就是自己跟自己交换，左右指针同时移动）\nclass Solution:    def moveZeroes(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        #双指针        n = len(nums)        left = right = 0        for right in range(n):            if nums[right]:                nums[left],nums[right] = nums[right],nums[left]                left += 1          \n\n\n\n盛水最多的容器（11）11. 盛最多水的容器\n\n\n\n\n\n\n\n\n\n给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。\n找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n返回容器可以储存的最大水量。（说明：你不能倾斜容器。）\n①暴力法 （会超时）\n固定左端点不动，右端点不断左移动，计算容积\nclass Solution:    def maxArea(self, height: List[int]) -&gt; int:        # 确定两个位置 可以容纳最多的水 就是两个位置的距离之差 乘以最小的高度        # 不能排序 什么时候更新指针的移动难点         n = len(height)        res = 0        for left in range(n):            right = n-1            while left &lt; right:                v = (right - left)* min(height[right],height[left])                  right -= 1                res = max(res,v)        return res\n\n②双指针\n本题最难的点就是双指针的移动策略，因为容积计算是两个位置距离之差，乘以最小的高度，因此本题目的移动策略就是移动最小的高度，因为长的那一边即使不动，高度还是由短的那边决定。 \nclass Solution:    def maxArea(self, height: List[int]) -&gt; int:        # 确定两个位置 可以容纳最多的水 就是两个位置的距离之差 乘以最小的高度        # 不能排序 什么时候更新指针的移动难点         n = len(height)        res = 0        left,right = 0,n-1        while left &lt; right:            v = (right - left)*min(height[right],height[left])              res = max(res,v)            if height[left]&lt;height[right]:                left += 1            else:                right -= 1        return res\n\n三数之和（15）15.三数之和\n\n\n\n\n\n\n\n\n\n给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。（答案中不可以包含重复的三元组）\n①暴力破解  三重循环  问题：超时 、需要去重（通过不了）\nclass Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        #暴力破解  三重循环进行 问题是：时间问题 而且还要去重        res = []        n = len(nums)        for i in range(n):            for j in range(i+1,n):                for k in range(j+1,n):                    if nums[i]+nums[j]+nums[k]==0:                        res.append([nums[i], nums[j], nums[k]])        result = set(tuple(sorted(x)) for x in res)        return [list(x) for x in result]\n\n②双指针移动\n因为本题目不能留下重复的三元组，所以将数组进行排序，然后遇到重复的数进行跳过，然后从当前位置i开始，区间为i+1~n-1，不断去遍历，当满足条件的值就加入列表，如果不满足，则指针进行移动，如果小于0，说明左边的数太小了，左指针需要右移动；如果大于0，说明右边的数太大了，右指针需要往左移动，直至满足条件\nclass Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        #双指针  排序 去重        res = []        #排序         nums.sort()        n = len(nums)        for i in range(n):            #跳过重复的值            if i&gt;0 and nums[i] == nums[i-1]:                continue            #左指针从i+1的位置开始  右指针从最后的位置开始            l,r = i+1,n-1            while l&lt;r:                s = nums[i]+nums[l]+nums[r]                if s==0:                    res.append([nums[i], nums[l], nums[r]])                    while l&lt;r and nums[l] ==nums[l+1]:                        l += 1                    while l&lt;r and nums[r] == nums[r-1]:                        r -= 1                    l += 1                    r -= 1                elif s&lt;0:                    l += 1                else:                    r -= 1        return res\n\n\n\n接雨水（42）42. 接雨水\n\n\n\n\n\n\n\n\n\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n 某一位置的积水量 &#x3D; min(左边最高柱子, 右边最高柱子) - 当前高度\n双指针解法：\n首先确定了某一位置的积水量计算公式之后，那么重点就是确定左边和右边的最高柱子。使用双指针从两侧往中间进行，如果当前左高度小于右边的高度，说明此时可以计算左边的积水，此时公式就是左边的最高柱子的高度-当前高度，但是如果当前的高度大于左侧的最高高度，那么是不能积水的（因为水要依靠比它更高的墙才能积起来，如果当前位置本身就是新最高的墙，那么这里是不会积水的），此时只能更新左侧的最高高度。同理，右侧也如此\n\n\n\n\n\n\n\n\n\n开始有困惑，我理解了对于每个位置来说的积水量的计算，取决于它左右最高的柱子（决定的还是左右两侧低的柱子）。使用双指针的时候，计算的事局部最高墙，不理解。后面借助AI的提示。想象水从上往下落，左边最高墙挡住了水，当前柱子比左边墙高 → 水直接落在它两侧，不会在它顶上停留，所以只要局部左边最高墙等于或小于当前位置，当前位置就不会积水\nclass Solution:    def trap(self, height: List[int]) -&gt; int:        #问题 雨水的位置 怎么计算雨水        n = len(height)        left_max = right_max = 0        res = 0         left,right = 0,n-1        while left &lt; right:            #说明此时可以计算左侧的积水            if height[left]&lt;height[right]:                if height[left] &gt; left_max:                    #说明当前位置是局部最高墙  不会积水                    left_max = height[left]                else:                    res += left_max -height[left]                left += 1            else:                if height[right] &gt; right_max:                    #说明当前位置是局部最高墙  不会积水                    right_max = height[right]                else:                    res += right_max -height[right]                right -= 1        return res\n\n\n\n","categories":["hot-100题"],"tags":["hot100-双指针"]},{"title":"hot100题-二分查找","url":"//post/hot100%E9%A2%98-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html","content":"二分查找区间的选择（易错点） \n两种区间定义方式 [l,r] 和 [l,r) 都可以用在所有场合，只是写法不同，关键是要保证「区间定义 → 循环条件 → 更新规则 → 退出条件」保持一致\n①左闭右闭区间[l,r]   查找目标值\n\n\n\n\n\n\n\n\n\n含义：查找的范围内，l和r都位置都是可能的答案\n指针变化：r  &#x3D; mid -1 或 l &#x3D; mid+1\nclass Solution:    def search(self, nums: List[int], target: int) -&gt; int:        left, right = 0, len(nums) - 1  # 定义target在左闭右闭的区间里，[left, right]        while left &lt;= right:            middle = left + (right - left) // 2                        if nums[middle] &gt; target:                right = middle - 1  # target在左区间，所以[left, middle - 1]            elif nums[middle] &lt; target:                left = middle + 1  # target在右区间，所以[middle + 1, right]            else:                return middle  # 数组中找到目标值，直接返回下标        return -1  # 未找到目标值\n\n②左闭右开区间[l,r)   找插入位置 \n\n\n\n\n\n\n\n\n\n含义：查找的范围内，l是可能的答案，但r一定不是\n指针变化：r  &#x3D; mid  或 l &#x3D; mid+1\nclass Solution:    def search(self, nums: List[int], target: int) -&gt; int:        left, right = 0, len(nums)  # 定义target在左闭右开的区间里，即：[left, right)        while left &lt; right:  # 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;            middle = left + (right - left) // 2            if nums[middle] &gt; target:                right = middle  # target 在左区间，在[left, middle)中            elif nums[middle] &lt; target:                left = middle + 1  # target 在右区间，在[middle + 1, right)中            else:                return middle  # 数组中找到目标值，直接返回下标        return -1  # 未找到目标值\n\n搜索插入位置\n\n\n\n\n\n\n\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。请必须使用时间复杂度为 O(log n) 的算法。\n35. 搜索插入位置\n本题可以使用二分查找进行查找，使用的是闭区间的形式，最后left &gt; right ，如果目标值在数组中则直接返回数组中的索引，如果不存在则应该插入的位置就是left的位置\nclass Solution:    def searchInsert(self, nums: List[int], target: int) -&gt; int:        left,right = 0,len(nums)-1        while left&lt;=right:            mid = (left+right)//2            if nums[mid] == target:                return mid             elif nums[mid] &gt; target:                right = mid -1            else:                left = mid + 1        return left \n\n搜索二维矩阵\n\n\n\n\n\n\n\n\n给你一个满足下述两条属性的 m x n 整数矩阵：\n\n每行中的整数从左到右按非严格递增顺序排列。\n每行的第一个整数大于前一行的最后一个整数。\n\n给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。\n74. 搜索二维矩阵\n暴力求解本题不适用，首先得确定目标值在元素中的哪一行，第一种方式是直接判断，在确定的行中在使用二分查找。第二种方式。\n① 直接当确定目标值的行之后 使用二分查找进行查找\nclass Solution:     def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:        # 遍历每一行，找到存在 target 的那一行        for nums in matrix:            if target &gt;= nums[0] and target&lt;=nums[-1]:                left,right = 0,len(nums)-1                while left &lt;=right:                    mid = (left+right)//2                    if nums[mid] == target:                        return True                    elif nums[mid] &gt; target:                        right = mid -1                    else:                        left = mid + 1                return False        return False\n\n②因为数组第一列的元素是有序的，因此可以先对数组第一列的元素进行二分查找，当然条件判断跟二分查找的条件不一样（此时不是值相等），然后针对那一行使用二分查找。\nclass Solution:     def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:        # 遍历每一行，找到存在 target 的那一行        m,n = len(matrix),len(matrix[0])        top,bottom = 0,m-1        row = -1         while top&lt;=bottom:            mid = (top+bottom)//2            if matrix[mid][0] &lt;= target &lt;=matrix[mid][-1]:                row = mid                break            elif matrix[mid][0] &gt; target:                bottom = mid - 1            else:                top = mid + 1        if row == -1:            return False        left,right = 0,n-1        while left&lt;=right:            mid = (left+right)//2            if matrix[row][mid] == target:                return True            elif matrix[row][mid] &gt;target:                right = mid -1            else:                left = mid + 1        return False\n\n在排序数组中查找元素的第一个和最后一个位置\n\n\n\n\n\n\n\n\n给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。\n34. 在排序数组中查找元素的第一个和最后一个位置\n搜索旋转排序数组\n\n\n\n\n\n\n\n\n整数数组 nums 按升序排列，数组中的值 互不相同 。\n在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 向左旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 下标 3 上向左旋转后可能变为 [4,5,6,7,0,1,2] 。\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。\n33. 搜索旋转排序数组\n寻找旋转排序数组中的最小值\n\n\n\n\n\n\n\n\n已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：\n\n若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]\n若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]\n\n注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。\n给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。\n你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\n153. 寻找旋转排序数组中的最小值\n寻找两个正序数组的中位数\n\n\n\n\n\n\n\n\n给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\n算法的时间复杂度应该为 O(log (m+n)\n4. 寻找两个正序数组的中位数\n","categories":["hot-100题"],"tags":["hot100-二分查找"]},{"title":"hot100题-数组","url":"//post/hot100%E9%A2%98-%E6%95%B0%E7%BB%84.html","content":"最大子数组和(53)最大子数组和\n\n\n\n\n\n\n\n\n\n给一个整数数组 nums ，找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n开始想到使用滑动窗口来进行解题，发现在求解过程中，窗口大小不固定，没办法确定窗口长度，这里选择动态规划算法，对于每个位置 i，找到 nums[i] 结尾的最大子数组和(动态规划算法还需要强加学习)\nclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        n = len(nums)        dp = [0] * n  # dp[i] 表示以 nums[i] 结尾的最大子数组和        dp[0] = nums[0]        max_sum = dp[0]        for i in range(1, n):            # 状态转移公式            dp[i] = max(nums[i], dp[i-1] + nums[i])            # 更新全局最大值            max_sum = max(max_sum, dp[i])        return max_sum\n\n合并区间（56）合并区间\n\n\n\n\n\n\n\n\n\n以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 \n\n按照左端点进行排序  \n定义返回的列表  \n每次对当前子数组的值和列表中最后一个数组的尾部进行比较  \n如果当前子数组的 start &gt; 列表中最后一个的尾部，则不需要更新  \n如果当前子数组的 start &lt;&#x3D; 列表中最后一个的尾部，则需要更新列表中最后的尾部，取两者之间较大的值\n\nclass Solution:    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:        intervals.sort(key=lambda x:x[0])        merged = []        for interval in intervals:            if not merged or merged[-1][1] &lt; interval[0]:                #当前区间的start和最后的end 如果当前区间的start 大于 最后的end                #已存在最后的[0,1]  当前的[2,3] 没有重叠                merged.append(interval)            else:                #最后的[0,2]  当前的[1,2]  或者 最后的[0,2] 当前 [0,4]                 merged[-1][1] = max(interval[1],merged[-1][1])        return merged        \n\n轮转数组（189）轮转数组\n\n\n\n\n\n\n\n\n\n将整数数组向右轮转 k 个位置\n① 切片法  \n\nk 可能大于数组长度，因此对 k 取余  \n使用切片法：截取原数组后 k 个和除去数组后 k 个之前的进行拼接\n\nclass Solution:    def rotate(self, nums: List[int], k: int) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        #定义一个循环的数组 然后一直移动就可以        n = len(nums)        k %= n        nums[:] = nums[-k:]+nums[:-k]\n\n② 使用额外的数组  \n\n在原数组之后再加上一个一样的数组，然后进行截取\n\nclass Solution:    def rotate(self, nums: List[int], k: int) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        #定义一个循环的数组 然后一直移动就可以        n = len(nums)        if n==0:            return         k %= n        extend = nums+nums        rotated = extend[n-k:n-k+n]         nums[:] = rotated\n\n③ 数组翻转  \n\n将数组向右移动 k 次，尾部 k mod n 个元素会移动到数组头部，其余元素会向后移动 k mod n 个位置  \n先将所有元素翻转  \n再翻转 [0, k mod n−1] 区间和 [k mod n, n−1] 区间即可\n\n除自身以外数组的乘积（238）\n\n\n\n\n\n\n\n\n给一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 \n除自身以外数组的乘积\n① 暴力解法  \n\n两层循环进行解答，但是会超时\n\n② 前后缀积  \n\n分别计算左前缀和右前缀，然后进行相乘\n\nclass Solution:    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:        n = len(nums)        left ,right, res = [0]*n,[0]*n,[0]*n        #计算第i个位置的左前缀积        left[0] = 1        for i in range(1,n):            left[i] = left[i-1]*nums[i-1]        #计算第i个位置的右前缀积        right[n-1] = 1        for i in reversed(range(n-1)):            right[i] = right[i+1]*nums[i+1]        #分别将左前缀和右前缀对应进行相乘        for i in range(n):            res[i] = left[i]*right[i]        return res\n\n缺失的第一个正数(41)\n\n\n\n\n\n\n\n\n已知一个未排序的整数数组 nums ，找出其中没有出现的最小的正整数\n缺失的第一个正数\n数组有N个元素，对应索引值为0~n-1，并设置标记。如果当前的值小于n，那么将其n-1位置上面的元素做标记，如设置为负数， 如果全部被标记 ，那返回的就是n+1 ，反之，那就是第一个正数的位置 （因为其中有负数或者大于n的数 ，这样初始处理就是将这些数设置为n+1 ）\nclass Solution:    def firstMissingPositive(self, nums: List[int]) -&gt; int:        n = len(nums)        #忽略无用数        for i in range(n):            if nums[i]&lt;=0 or nums[i] &gt; n :                nums[i] = n+1        #进行标记        for i in range(n):        #为啥要取绝对值呢  因为如果是3  4 6 5  当遍历到3时候，会修改后续位置为 3 4 -6 5，所以需要取绝对值，避免索引值为负数            num = abs(nums[i])            if num &lt;= n:                nums[num-1] = -abs(nums[num-1])        for i in range(n):            if nums[i]&gt;0:                return i+1        return n+1\n\n","categories":["hot-100题"],"tags":["hot100-数组"]},{"title":"hot100题-滑动窗口","url":"//post/hot100%E9%A2%98-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.html","content":"滑动窗口（定长、不定长、多指针）定长的滑动窗口三步走  入–更新–出\n入：下标为 i 的元素进入窗口，更新相关统计量。如果 i&lt;k−1 则重复第一步。\n更新：更新答案。一般是更新最大值&#x2F;最小值。\n出：下标为 i−k+1 的元素离开窗口，更新相关统计量。\n思考：先找到前面k-1个元素，然后进入的元素与前面的k-1的元素成定长窗口，然后前面的元素出，后面的元素进入\n解决循环数组问题 可以使用扩展数组 将数组扩大一倍 \n滑动窗口模版题\n\n\n\n\n\n\n\n\n&#x2F;&#x2F;外层循环扩展右边界，内层循环扩展左边界 \nfor (int l &#x3D; 0, r &#x3D; 0 ; r &lt; n ; r++) { \n​\t&#x2F;&#x2F;当前考虑的元素 \t\nwhile (l &lt;&#x3D; r &amp;&amp; check()) {&#x2F;&#x2F;区间[left,right]不符合题意 &#x2F;&#x2F;扩展左边界 } &#x2F;&#x2F;区间[left,right]符合题意，统计相关信息 }\n无重复字符的最长子串（3）\n\n\n\n\n\n\n\n\n3. 无重复字符的最长子串\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。\n本题使用滑动窗口的思想，满足条件时进入窗口，当条件不满足时，移动窗口的值，然后更新相关的值。使用 list 里的 in 和 pop(0) 操作时间复杂，因此合理的方式是使用哈希集合+滑动窗口\n①列表+滑动窗口\nclass Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        #定义列表 如果当前字符不在列表中 则进入列表        #如果在列表中 需要循环删除 直到当前字符不在列表中        t = []        res = 0        for i in range(len(s)):            while s[i] in t:                t.pop(0)   #删除之前的值 使得当前加入的值             t.append(s[i])            res = max(res,len(t))        return res\n\n②哈希集合+滑动窗口\nclass Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        #使用滑动窗口+双指针进行维护         char_set = set()        l = 0        res = 0        for r in range(len(s)):            while s[r] in char_set:   # 如果重复，就缩小窗口                char_set.remove(s[l])                l += 1            char_set.add(s[r])            res = max(res, r - l + 1)  # 更新窗口最大长度        return res\n\n\n\n找到字符串中所有字母异位词（438）\n\n\n\n\n\n\n\n\n438. 找到字符串中所有字母异位词\n给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n本题使用滑动窗口+计数的方式来进行，维持一个维持一个 跟字符串p长度相等的滑动窗口，然后转化成字符列表进行计算来判断是否是异位词\nclass Solution:    def findAnagrams(self, s: str, p: str) -&gt; List[int]:        #维持一个 跟字符串p长度相等的 滑动窗口        #转化成字符列表或者哈希表来比较滑动窗口组成的值和字符串p是否是异位词        s_len,p_len = len(s),len(p)        if s_len &lt; p_len:            return []        ans = []        p_count = [0]*26        s_count = [0]*26        for i in range(p_len):            s_count[ord(s[i])-ord(&#x27;a&#x27;)]+= 1            p_count[ord(p[i])-ord(&#x27;a&#x27;)]+= 1        if s_count==p_count:            ans.append(0)        for i in range(s_len-p_len):            #把下标为i的数去掉            s_count[ord(s[i])-ord(&#x27;a&#x27;)]-= 1            #加入下标为i+p_len的数 此时区间就为 [i+1,i+p_len]            s_count[ord(s[i+p_len])-ord(&#x27;a&#x27;)]+= 1            if s_count==p_count:                #如果相等 则将首部索引加入                ans.append(i+1)                    return ans          \n\n","categories":["hot-100题"],"tags":["hot100-滑动窗口"]},{"title":"hot100题-哈希","url":"//post/hot100%E9%A2%98-%E5%93%88%E5%B8%8C.html","content":"两数之和（1）\n\n\n\n\n\n\n\n\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标\n1.两数之和\n①暴力解法 \n使用两层循环暴力进行解答\n②使用哈希表\n为啥要用到哈希表呢？ 在数组中查询时间复杂度太高，需要顺序查找，而哈希表可根据值快速查找\n\n\n\n\n\n\n\n\n\npython中字典也是哈希表的一种实现。定义哈希表后，遍历数组，如果目标值-当前值不在哈希表中，则将当前值以及对应的索引存入哈希表。如果能在哈希表中找到对应的值，则返回对应的下标\nclass Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        #定义哈希表 如果 target-当前元素不在哈希表中 就加入哈希表         t = &#123;&#125;        for i,num in enumerate(nums):            if target-num in t:                return [t[target-num],i]            t[num] = i        return \n\n字母异位词分组（49）49. 字母异位词分组\n\n\n\n\n\n\n\n\n\n给你一个字符串数组，请你将字母异位词组合在一起。可以按任意顺序返回结果列表。\n字母异位词组成单词相同，仅仅是位置不一样，可以建立哈希表，找到作为字母异位词的相同点作为哈希表的键，字母异位词的键值都是相等的，根据这一点，实现了不同的字母异位词的分类\n然后将每个字符串进行排序之后组合新的字符串作为哈希表的键，加入到哈希表中，这样就实现了不同的字母异位词的分类\n①将每个字符串按照字典顺序进行排序，排列组合成新的字符串作为哈希表的键\nclass Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        mp = defaultdict(list)  # 创建哈希表，value 默认是列表        for st in strs:            key = &quot;&quot;.join(sorted(st))  # 对字符串排序，得到 key            mp[key].append(st)         # 加入对应分组        return list(mp.values())       # 返回所有分组\n\n②计数，定义数组计算每个字符串字母出现的个数，组成字母异位词的字符个数是相等的，但是列表是可变的所以不能哈希，需要转化成元组才能哈希\nclass Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        mp = defaultdict(list)  # 创建哈希表，value 默认是列表        for st in strs:            counts = [0]*26            for ch in st:                counts[ord(ch)-ord(&quot;a&quot;)] += 1            mp[tuple(counts)].append(st)        return list(mp.values())       # 返回所有分组\n\n最长连续序列（128）128. 最长连续序列\n\n\n\n\n\n\n\n\n\n给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n本题目限制了时间复杂度为O(N)，因此不能使用排序。\n如果单独从列表找元素时间较长，因此先可以将列表转化为哈希集合，直接检索哈希结合，在找序列的时候也要注意就是，因为没有排序，那可能从当前位置x开始，可能x-1在哈希集合中因此如果x-1在哈希集合中，此时就跳过。\nclass Solution:    def longestConsecutive(self, nums: List[int]) -&gt; int:        #把nums转化成哈希集合        st = set(nums)        ans = 0        for x in st:            #如果x-1在集合里面 从x为起点 不如x-1为起点的序列长            if x-1 in st:                continue            y = x +1             #一直往后遍历 找到连续的序列            while y in st:                y += 1            ans = max(ans,y-x)        return ans \n\n","categories":["hot-100题"],"tags":["hot100-哈希"]},{"title":"python-GIL","url":"//post/python-GIL.html","content":"GILGIL是什么GIL 是 CPython 为了简化内存管理而引入的全局解释器锁，它保证同一时间只有一个线程执行 Python 字节码。这使得 Python 的多线程在 CPU 密集型任务中无法利用多核，但在 I&#x2F;O 密集型任务中依然有效。\n🔒 互斥锁的定义：\n\n\n\n\n\n\n\n\n\n互斥锁是一种同步原语，用于防止多个线程同时访问共享资源。\nGIL 正是这样一把锁：\n\n共享资源 &#x3D; CPython 解释器的内部状态（如对象引用计数、内存管理器）\n保护方式 &#x3D; 任何线程要执行 Python 代码，必须先获取 GIL\n\n为什么要设计 GILGIL 的核心原因：CPython 的内存管理模型\n🔑 关键点：\n\n\n\n\n\n\n\n\n\nCPython 使用 “引用计数（Reference Counting）” 作为主要的内存管理机制，而引用计数的增减操作必须是原子的。\n🔑 核心逻辑链：\n\n\n\n\n\n\n\n\n\nPython（CPython）使用引用计数（Reference Counting）管理内存 ↓ 引用计数的增减必须是原子操作（否则会出错） ↓ 为了保证原子性，CPython 引入了 GIL（全局互斥锁） ↓ GIL 确保同一时刻只有一个线程能修改引用计数\n什么是引用计数（Reference Counting）在 CPython 中，每个 Python 对象（如 list, str, 自定义类实例）都有一个字段叫 ob_refcnt，记录 “有多少变量 &#x2F; 容器引用了它”。\na = [1, 2, 3]      # ob_refcnt = 1b = a              # ob_refcnt = 2c = [a, &quot;hello&quot;]   # ob_refcnt = 3（因为 c[0] 也引用了a）del b              # ob_refcnt = 2\n\n当 ob_refcnt 降到 0 时，对象立即被销毁（内存回收）。\n如果没有 GIL假设两个线程同时执行 b = a：\n\n\n\n线程 A\n线程 B\n实际 ob_refcnt\n\n\n\n读取 ob_refcnt = 1\n读取 ob_refcnt = 1\n1\n\n\n计算 1 + 1 = 2\n计算 1 + 1 = 2\n—\n\n\n写回 ob_refcnt = 2\n写回 ob_refcnt = 2\n2（但正确值应为 3！）\n\n\n👉 结果：引用计数错误 → 对象可能被提前释放（程序崩溃）或内存泄漏。\n\n\n\n\n\n\n\n\n\n💥 这就是竞态条件（Race Condition）：多个线程 &#x2F; 进程并发访问共享资源时，最终结果依赖于它们的执行顺序或 timing（时序），导致程序行为不可预测、错误或崩溃。\n为什么 Java&#x2F;Go 不需要 GIL？\n\n\n语言\n内存管理\n是否需要全局锁\n\n\n\nPython (CPython)\n引用计数（运行时增减）\n✅ 需要（GIL）\n\n\nJava &#x2F; Go &#x2F; C#\n垃圾回收（GC）\n❌ 不需要\n\n\nRust\n编译期所有权检查\n❌ 不需要\n\n\n\nGC 语言：对象分配 &#x2F; 回收由专用 GC 线程处理，用户线程不直接操作引用计数\nRust：内存安全在编译期保证，运行时无引用计数开销\n\n什么是 GCGC（Garbage Collection，垃圾回收） 是现代编程语言中自动管理内存的核心机制。其核心思想为， 自动找出 “不再使用的对象”，并回收其内存，无需程序员手动释放。\n🆚 对比：手动管理 vs 自动管理\n\n\n\n方式\n代表语言\n特点\n\n\n\n手动管理\nC, C++\n程序员用 malloc/free 或 new/delete 管理内存 → 容易出错（内存泄漏、野指针）\n\n\n自动管理\nJava, Go, C#, Python\n语言运行时自动回收内存 → 安全，但有性能开销\n\n\nGC 是如何工作的主流 GC（如 Java、Go）使用 “可达性分析”（Reachability Analysis）判断对象是否存活：\n🌳 核心概念：根对象（Roots）\n\n全局变量\n当前函数的局部变量\nCPU 寄存器中的引用\n\n📌 判断规则：\n\n\n\n\n\n\n\n\n\n从根对象出发，能通过引用链到达的对象 &#x3D; 存活对象 无法到达的对象 &#x3D; 垃圾（可回收）\npython 的程序并行由于 CPython 的 GIL（全局解释器锁）存在：\n\n多线程无法在多核 CPU 上并行执行 Python 字节码（尤其是 CPU 密集型任务）；\n但多进程可以绕过 GIL，每个进程拥有独立的解释器和内存空间，因此能真正并行，充分利用多核 CPU。\n\n\n\n\n类型\n是否受 GIL 限制\n能否利用多核\n适用场景\n\n\n\n多线程（Threading）\n✅ 受限（CPU 任务串行）\n❌ CPU 任务不能✅ I&#x2F;O 任务可以（因释放 GIL）\n网络请求、文件读写、数据库查询等 I&#x2F;O 密集型\n\n\n多进程（Multiprocessing）\n❌ 不受限\n✅ 能（真并行）\n图像处理、模型推理、加密计算等 CPU 密集型\n\n\n\n\n\n\n\n\n\n\n\n📌 注意：“并行”（parallelism）≠ “并发”（concurrency）- 多线程在 Python 中实现的是 并发（交替执行），不是 并行（同时执行）（对 CPU 任务而言）。\n参考资料带大家感受一下没有 GIL 的 CPython_哔哩哔哩_bilibili\n【python】天使还是魔鬼？GIL 的前世今生。一期视频全面了解 GIL！_哔哩哔哩_bilibili\n","categories":["python"],"tags":["python"]},{"title":"python-asyncio","url":"//post/python-asyncio.html","content":"Python 异步编程概念学习\n\n\n\n\n\n\n\n\n通俗理解：操作系统对CPU时间和内存进行管理，进程好比单独的一间办公室有自己独立的空间和资源，线程好比办公室中的员工，共享办公室（进程）的数据，协程是一种工作方式，员工在不同的任务之间进行切换。\n并发并发（Concurrency）是一种 “效果”—— 多个任务在一段时间内交替或同时推进。 它可以通过多种方式实现，常见的有：\n\n多线程（Multithreading）\n异步编程（Asynchronous programming，如 asyncio）\n多进程（Multiprocessing）（严格说更偏向 “并行”，但也支持并发）\n\n\n\n\n特性\n进程 (Process)\n线程 (Thread)\n协程 (Coroutine)\n\n\n\n定义\n操作系统资源分配的最小单位\nCPU 调度的最小单位\n用户态的轻量级线程（由程序控制）\n\n\n资源占用\n极高：拥有独立的内存空间\n中等：共享进程内存，但有独立栈\n极低：本质是函数，占用内存非常小\n\n\n数据通信\n困难：需要 IPC（如管道、队列）\n容易：直接共享全局变量\n极易：直接共享全局变量\n\n\n并行能力\n支持并行（利用多核 CPU）\n受限于 GIL，无法真正并行\n无法并行（单线程内切换）\n\n\n切换开销\n巨大：需要内核态切换\n较大：由操作系统强制切换\n极小：在用户态由程序自主切换\n\n\n适用场景\n计算密集型（如视频渲染、加密）\nI&#x2F;O 密集型（旧版网络请求）\n高并发 I&#x2F;O（如现代 Web 异步服务器）\n\n\n\n\n\n维度\n多进程 (Multiprocessing)\n多线程 (Threading)\n协程 (Asyncio)\n\n\n\n工作原理\n启动多个独立的 Python 解释器进程，每个进程拥有独立的内存和 GIL。\n在单个进程内创建多个执行流，共享内存，受限于全局解释器锁（GIL）。\n在单线程内由程序控制切换任务，遇到 I&#x2F;O 等待时自动切换（事件循环）。\n\n\n底层调度\n由操作系统内核调度。\n由操作系统内核调度。\n由用户程序&#x2F;代码调度。\n\n\n核心优势\n真正并行。能利用多核 CPU，任务互不影响。\n共享数据方便，开销比进程小。\n极致的高并发。极低的内存占用和切换成本。\n\n\n核心劣势\n内存开销巨大，进程间通信（IPC）复杂。\nGIL 导致无法并行。存在线程竞争（需加锁），切换有开销。\n无法利用多核 CPU。代码逻辑较复杂（需 async/await）。\n\n\n适用任务类型\n计算密集型 (CPU-bound)\n中低并发 I&#x2F;O 密集型\n超高并发 I&#x2F;O 密集型\n\n\n典型场景\n科学计算、视频渲染、加密解密、大数据离线处理。\n简单的磁盘读写、旧版同步库的爬虫、GUI 界面保持响应。\nWeb 服务器（FastAPI）、高性能爬虫、即时通讯、长连接服务。\n\n\n线程” 在 CPU 核心上运行。 进程是资源容器，线程是执行单位。\n当你运行一个 Python 脚本（如 python app.py），操作系统会：\n\n创建一个新进程（Process）\n加载 Python 解释器（CPython）\n在该进程中启动主线程（Main Thread）\n执行你的代码\n\n\n\n\n\n\n\n\n\n\n📌 所以：一个正在运行的 Python 程序 &#x3D; 1 个进程 + 至少 1 个线程（主线程）\n但注意：\n\n程序可以创建更多进程（通过 multiprocessing）\n程序可以创建更多线程（通过 threading）\n所以 “一个程序” 最终可能对应 多个进程、多个线程\n\nasyncio概念：asyncio是python用于异步编程的库，专门用来处理耗时I&#x2F;O的操作，比如网络请求文件读写、数据库查询等等，这些操作需要等待响应，造成程序堵塞，浪费时间。使用 asyncio可以在等待时，执行其他任务，提升效率。\n协程 (coroutine)：可以暂停运行和恢复运行的函数 协程函数由async def 进行定义（跟普通函数的区别是 不会真的执行里面的代码 而是返回一个协程对象 在执行协程对象时才执行协程里面的代码）。当出现await时，会暂时执行，让出控制权。当await请求完成了会在请求控制权执行。拥有控制权的协程才可以执行，没有控制权的协程只能等待。\n\n\n任务(task)：对协程的封装，并记录了协程的状态，只要一个协程被包装成任务了，就可以被事件循环调度执行。\nawaitawait 是 Python 异步编程中的核心关键字，它的作用是：\n\n\n\n\n\n\n\n\n\n暂停当前协程的执行，等待一个 “可等待对象”（awaitable）完成，并获取其结果，同时将控制权交还给事件循环，使其能运行其他任务。\n三大功能：\n\n挂起（Suspend）：当前协程在此处暂停，不阻塞线程。\n等待（Wait）：等待一个异步操作（如网络请求、文件读写、定时器）完成。\n恢复（Resume）：当被等待的对象完成后，协程从此处恢复执行，并拿到结果。\n\n\n\n\n\n\n\n\n\n\n⚠️ 关键：await 不会阻塞整个线程，而是让事件循环去执行其他就绪的协程。\n事件循环（Event Loop）与任务（Task）\n\n\n\n\n\n\n\n\n用来调度协程执行，掌握着控制权。做三件事：①检查协程，检查有没有可以执行的线程。②让出控制，将控制权传递给可以执行的协程。③等待协程，等当前协程暂停或者结束，放开控制权给自己，然后又执行第一步。\n事件循环（Event Loop） 是异步编程的核心引擎，尤其在 Python 的 asyncio 模型中，它是驱动协程执行、管理异步 I&#x2F;O、调度任务的中枢系统。\n\n\n\n\n\n\n\n\n\n事件循环是一个程序结构，用于监听和分发事件或消息，实现非阻塞 I&#x2F;O 和协作式多任务调度。\n在 Python asyncio 中，事件循环：\n\n维护一个待执行协程队列\n管理定时器（如 asyncio.sleep）\n使用操作系统提供的 I&#x2F;O 多路复用机制（如 Linux 的 epoll、macOS 的 kqueue、Windows 的 IOCP）来高效监听大量文件描述符（如 socket）\n在 I&#x2F;O 就绪时，恢复对应的协程\n\n那事件循环如何知道哪些协程可以执行，哪些协程需要暂停呢\n在 Python 异步编程（特别是 asyncio）中，任务（Task） 是是对协程（Coroutine）的封装，用于被事件循环调度和并发执行。\n\n\n\n\n\n\n\n\n\nTask 是 asyncio 中表示 “未来会完成的异步操作” 的对象，它是 Future 的子类，用于包装协程并自动调度其执行。\n核心作用：\n\n将协程注册到事件循环中，使其能够并发运行（而非顺序等待）\n提供状态管理（如是否完成、是否取消、结果或异常）\n支持取消操作（task.cancel()）\n允许多次 await（协程对象只能 await 一次，但 Task 可以）\n\nimport asyncioasync def work(name, delay):    print(f&quot;开始 &#123;name&#125;&quot;)    await asyncio.sleep(delay)    print(f&quot;完成 &#123;name&#125;&quot;)    return f&quot;result-&#123;name&#125;&quot;async def main():    # 创建任务 → 立即开始执行！     task1 = asyncio.create_task(work(&quot;A&quot;, 2))    task2 = asyncio.create_task(work(&quot;B&quot;, 1))    # 等待任务完成（可获取结果）    r1 = await task1    r2 = await task2    print(r1, r2)#建立事件循环asyncio.run(main())\n\n开始 A开始 B完成 B完成 Aresult-A result-B\n\n\n\n\n\n\n\n\n\n\n在 asyncio 中，create_task 会让协程并发启动；当某个协程执行到 await 时，它会主动挂起；事件循环就去调度其他“可运行”的协程继续执行。\n\n\n\n\n\n\n\n\n\n💡 Task 是实现并发的关键：它让多个协程 “同时启动”，而不是 “一个接一个等”。\n实战学习from time import sleep, perf_counterdef fetch_url(url):    print(&#x27;Fetching the URL&#x27;)    sleep(1)#模拟阻塞    print(&#x27;Finished fetching&#x27;)    return &#x27;url_content&#x27;def read_file(filepath):    print(&#x27;Reading the file&#x27;)    sleep(1)#模拟阻塞    print(&#x27;Finished reading&#x27;)    return &#x27;file_content&#x27;def main():    url = &#x27;example.com&#x27;    filepath = &#x27;example.txt&#x27;    fetch_result = fetch_url(url)    read_result = read_file(filepath)if __name__ == &#x27;__main__&#x27;:    start_time = perf_counter()    main()    end_time = perf_counter()    print(f&#x27;Time taken: &#123;end_time - start_time:.2f&#125; seconds&#x27;)\n\n结果输出：以上是一段同步执行代码的实例， sleep(1)用来模拟阻塞，只有 等fetch_url执行完成之后才能执行read_file。\nFetching the URLFinished fetchingReading the fileFinished readingTime taken: 2.02 seconds\n\n异步编程的三步核心流程：\n三部曲：①使用async def 定义协程  ②包装协程为任务   ③创建事件循环\nfrom time import sleep, perf_counterimport asyncioasync def fetch_url(url):    print(&#x27;Fetching the URL&#x27;)    await asyncio.sleep(1) #异步等待 让出控制权    print(&#x27;Finished fetching&#x27;)    return &#x27;url_content&#x27;async def read_file(filepath):    print(&#x27;Reading the file&#x27;)    await asyncio.sleep(1)    print(&#x27;Finished reading&#x27;)    return &#x27;file_content&#x27;async def main():    url = &#x27;example.com&#x27;    filepath = &#x27;example.txt&#x27;    # 创建任务    tasks = [asyncio.create_task(coro) for coro in [        fetch_url(url),        read_file(filepath)]]    fetch_result = await tasks[0]    read_result = await tasks[1]if __name__ == &#x27;__main__&#x27;:    start_time = perf_counter()    #创建事件循环    asyncio.run(main())    end_time = perf_counter()    print(f&#x27;Time taken: &#123;end_time - start_time:.2f&#125; seconds&#x27;)#task 决定“谁在跑”，await 决定“我等谁”，event loop 决定“谁先跑”。\n\n输出为：\nFetching the URLReading the fileFinished fetchingFinished readingTime taken: 1.01 seconds\n\n\n\n\n\n学习资源【Py】asyncio：为异步编程而生 | Python 特性 | 并发编程 | 协程_哔哩哔哩_bilibili\n【python】asyncio 的理解与入门，搞不明白协程？看这个视频就够了。_哔哩哔哩_bilibili\n笔记\n","categories":["python"],"tags":["python"]},{"title":"python 依赖管理","url":"//post/python-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86.html","content":"\n\n\n\n\n\n\n\n\n本文主要介绍python中虚拟环境管理的另一种方式uv，开始接触深度学习conda用得比较多，后面发现有的项目是用uv进行环境管理，因此简单介绍一下这种方式。我的理解就是conda和uv都可以用来创建虚拟环境，如果是深度学习项目可使用conda建立虚拟环境，uv来下载依赖。其余的如web项目都可以使用uv来建立环境来进行管理依赖\nPython-uv虚拟环境管理uv简介uv和conda一样是python中的包管理工具，与其他Python中的包管理工具相比，uv更像是一个全能选手，有以下优势：\n\n速度快\n统一管理 Python 版本\n自动解决依赖冲突\n跨平台一致性\n\nuv工具主要使用的两个文件：\npyproject.toml：定义项目的主要依赖，包括项目名称、版本、描述、支持的 Python 版本等信息uv.lock：记录项目的所有依赖，包括依赖的依赖，且跨平台，确保在不同环境下安装的一致性。由 uv 自动管理，不用手动编辑\nuv安装\n\n\n\n\n\n\n\n\n主要介绍在windows uv的安装，以及uv建立虚拟环境，下载依赖\n# On Windows.powershell -ExecutionPolicy ByPass -c &quot;irm https://astral.sh/uv/install.ps1 | iex&quot;# With pip.pip install uv\n\nuv使用# 创建指定 Python 版本的环境uv venv --python=3.11 myenv  #或者使用uv init -p 版本号# 从 requirements.txt 安装（带哈希校验！）uv pip install -r requirements.txt# 生成精简版依赖uv pip compile requirements.in -o requirements.txt# 查看当前环境已安装的依赖uv pip list#安装依赖并写入 pyproject.tomluv add requests #移除依赖uv remove requests #同步依赖到虚拟环境uv sync #导出 lock 文件为 requirements.txt 等格式uv export #构建源码包和 wheeluv build发布到 PyPI #发布到 PyPIuv publish \n\nuv安装并设置镜像\nuv使用\n相关资料python环境管理大比拼\nUV笔记\n【uv】Python 迄今最好的项目管理 + 环境管理工具（吧？）_哔哩哔哩_bilibili\n从 pip 到 uv：一口气梳理现代 Python 项目管理全流程！_哔哩哔哩_bilibili\n","categories":["python依赖管理"],"tags":["python"]},{"title":"python哈希","url":"//post/python%E5%93%88%E5%B8%8C.html","content":"\n\n\n\n\n\n\n\n\n本文是借助ChatGPT结合总结的关于哈希相关的知识，以及哈希表的相关定义和使用，帮助理解哈希表的作用以及哈希表的使用场景\nPython中的哈希哈希的含义哈希的含义是把 任意长度的数据（如字符串、数字、对象）通过 哈希函数（Hash Function），转换成一个 固定长度的整数，通常用作 索引或标识。\n哈希函数的作用：把数据“映射”到一个整数，用这个整数可以在数组或表里快速找到对应位置\n哈希表（Hash Table）哈希表是哈希的最常见应用：\n\n由 数组 + 哈希函数 构成\n使用 key 的哈希值快速找到 value 的存储位置\n插入&#x2F;查找&#x2F;删除平均时间复杂度 O(1)\n\nkey = &quot;apple&quot;hash(&quot;apple&quot;) = 7  → 存在数组索引 7value = 5\n\n哈希表基础哈希表（Hash Table） 是一种 基于键值映射的数据结构，核心特点：\n\n键（key） → 哈希函数 → 数组索引 → 值（value）\n查找、插入、删除平均时间复杂度 O(1)\nPython 内部使用 开放寻址 + 链表&#x2F;红黑树 来处理冲突\n\nkey=&quot;apple&quot; → hash(&quot;apple&quot;) → 索引 7 → value=5key=&quot;banana&quot; → hash(&quot;banana&quot;) → 索引 3 → value=2\n\ndict（字典）Python中内置的哈希表类型\nkey：不可变的类型（int，str，tuple）\nvalue：任意类型\nscores = &#123;&quot;Alice&quot;: 90, &quot;Bob&quot;: 85&#125;print(scores[&quot;Alice&quot;])  # 90scores[&quot;Charlie&quot;] = 92  # 新增\n\ndefaultdict（带默认值的字典）来自来自 collections 模块，工厂函数指定默认值类型\n常用类型：\n\nint → 默认 0，用于计数\nlist → 默认 []，用于分组\nset → 默认 set()，用于去重\n\nfrom collections import defaultdict# 计数cnt = defaultdict(int)for ch in &quot;abracadabra&quot;:    cnt[ch] += 1print(cnt)  # &#123;&#x27;a&#x27;:5, &#x27;b&#x27;:2, &#x27;r&#x27;:2, &#x27;c&#x27;:1, &#x27;d&#x27;:1&#125;# 分组groups = defaultdict(list)words = [&quot;eat&quot;,&quot;tea&quot;,&quot;tan&quot;,&quot;ate&quot;,&quot;nat&quot;,&quot;bat&quot;]for w in words:    key = &quot;&quot;.join(sorted(w))    groups[key].append(w)print(groups.values())  # [[&#x27;eat&#x27;,&#x27;tea&#x27;,&#x27;ate&#x27;], [&#x27;tan&#x27;,&#x27;nat&#x27;], [&#x27;bat&#x27;]]\n\nCounter（计数器）\ncollections.Counter 是 dict + int 封装的计数工具\n功能：统计元素频率，直接返回哈希表\n\nfrom collections import Counters = &quot;abracadabra&quot;cnt = Counter(s)print(cnt)  # &#123;&#x27;a&#x27;:5,&#x27;b&#x27;:2,&#x27;r&#x27;:2,&#x27;c&#x27;:1,&#x27;d&#x27;:1&#125;\n\nset（集合）哈希实现的无序集合，元素唯一、查找快速，常用于去重、快速判断元素是否存在\nnums = [1,2,2,3,4,4,5]s = set(nums)print(s)  # &#123;1,2,3,4,5&#125;print(3 in s)  # True\n\n哈希使用场景\n\n\n场景\n常用类型\n说明\n\n\n\n元素去重\nset\n判断元素是否存在\n\n\n计数&#x2F;频率统计\ndict / Counter / defaultdict(int)\n统计出现次数\n\n\n分组&#x2F;归类\ndefaultdict(list)\n通过 key 分组元素\n\n\n查找&#x2F;索引映射\ndict\nkey → value 快速查找\n\n\n注意事项Python 中的哈希表主要是 dict、defaultdict、set、Counter\n核心思想：key → hash → 索引 → value\n\nkey 必须可哈希（不可变类型）\n哈希表顺序：Python 3.7+ 保留插入顺序\n冲突处理：Python 内部自动解决，一般不需要手动处理\n空间换时间：哈希表使用额外内存来换取 O(1) 查找速度\n\n","categories":["python哈希"],"tags":["python"]},{"title":"python相关","url":"//post/python%E7%9B%B8%E5%85%B3.html","content":"python相关dotenv什么是 dotenv？dotenv 是一个用于从 .env 文件中加载环境变量到程序中的工具。它广泛用于各种编程语言（如 Python、Node.js、Ruby 等），目的是把敏感信息（比如 API 密钥、数据库密码）和配置从代码中分离出来，避免硬编码，提高安全性与灵活性。\n基本使用#安装pip install python-dotenv#.envdb_host=localhostdb_port=3306db_user=rootdb_password=123456db_name=testfrom dotenv import load_dotenvload_dotenv()import osdb_host = os.getenv(&quot;db_host&quot;)db_port = os.getenv(&quot;db_port&quot;)db_user = os.getenv(&quot;db_user&quot;)db_password = os.getenv(&quot;db_password&quot;)db_name = os.getenv(&quot;db_name&quot;)print(db_host)print(db_port)print(db_user)print(db_password)print(db_name)\n\n在.gitignore 增加\n# Environment variables*.env\n\n\n\n\n写法\n含义\n\n\n\n.env\n只忽略名为 .env 的文件（精确匹配）\n\n\n*.env\n忽略所有以 .env 结尾的文件（通配符匹配）\n\n\n装饰器\n\n\n\n\n\n\n\n\nPython 装饰器用于在不修改原函数定义的情况下，为函数或类添加额外行为，是实现横切关注点（日志、权限、缓存等）的重要工具。本质上接收函数，返回新函数的函数\ndef my_decorator(func):    def wrapper():        print(&quot;before&quot;)        func()        print(&quot;after&quot;)    return wrapper@my_decoratordef hello():    print(&quot;hello&quot;) &#x27;&#x27;&#x27; 调用 hello() 执行的是beforehelloafter &#x27;&#x27;&#x27;\n\n","categories":["python"],"tags":["python"]},{"title":"python项目结构","url":"//post/python%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.html","content":"Python 项目结构和打包pip install 的本质从 PyPI（默认）或其他源（如私有仓库、本地文件）查找指定名称的包，下载对应的.whl 文件\nwhl 文件\n.whl 是 Wheel 的缩写，是 Python 的一种标准打包格式（PEP 427 定义）。\n它本质上是一个 ZIP 格式的压缩包，扩展名改为 .whl。\n\n安装 .whl 文件\npip install package_name.whl\n\nhachlinghatchling 是 Python 生态中一个现代的、轻量级的构建后端（build backend），主要用于将 Python 项目打包成可分发的格式（如 .whl 或源码包）。它是 Hatch 项目的一部分，由 PyPA（Python Packaging Authority）推荐使用。\n在 pyproject.toml 添加\n[build-system]requires = [&quot;hatchling&quot;]build-backend = &quot;hatchling.build&quot;\n\n当你运行：\npip install .# 或python -m build\n\n如果项目配置了 hatchling 作为构建后端，pip 或 build 工具就会调用 hatchling 来完成打包和安装。\n例如以下项目结构\nmy_project/├── pyproject.toml├── src/│   └── my_utils/               ← 你写的包│       ├── __init__.py│       └── math.py├── scripts/│   └── run_demo.py             ← 想在这里用 my_utils\n\n想让项目的其他文件使用自己编写的包，在 pyproject.toml 增加\n# 👇 新增：显式声明包位置[tool.hatch.build.targets.wheel]packages = [&quot;src/my_utils&quot;]\n\n在项目根目录（my_project/）执行：\nuv pip install -e .\n\n\n\n\n\n\n\n\n\n\n✅ 这会把 src/my_utils/ 注册为一个可导入的包。\nsrc layoutsrc layout（也称为 src 布局 或 src 目录结构）是 Python 项目中一种推荐的源代码组织方式，其核心思想是：将你的 Python 包（package）放在一个名为 src/ 的子目录下，而不是直接放在项目根目录中。\n❌ 传统布局（不推荐）\nmy_project/├── my_package/│   ├── __init__.py│   └── module.py├── tests/├── setup.py└── README.md\n\n✅ src 布局（推荐）\nmy_project/├── src/│   └── my_package/│       ├── __init__.py│       └── module.py├── tests/├── pyproject.toml└── README.md\n\nuv build 和 uv pip install . 什么区别一、uv build\n✅ 作用：构建分发包（不安装）\n\n调用项目的构建后端（如 hatchling、setuptools 等）。\n生成标准的分发文件：\n一个 Wheel 文件（.whl）\n一个 源码分发包（sdist，.tar.gz）\n\n\n输出到项目根目录下的 dist/ 文件夹。\n不会将包安装到当前 Python 环境中。\n\n🔧 示例：\nuv build\n\n输出：\ndist/my_package-0.1.0-py3-none-any.whldist/my_package-0.1.0.tar.gz\n\n\n\n\n\n二、uv pip install .\n✅ 作用：安装当前项目到当前环境\n\n首先（隐式）构建项目（类似 uv build 的过程）。\n然后将构建结果安装到当前激活的 Python 环境（如虚拟环境或系统环境）。\n安装后，你可以在 Python 中 import 该包。\n默认是 “非可编辑安装”（即代码改动不会自动生效，除非重新安装）。\n\n🔧 示例：\nuv pip install .\n\n效果： - 包被安装到 site-packages/ - 可在 Python 中 import my_package\nEditable install（可编辑安装）Editable install（可编辑安装） 是 Python 包管理中的一种安装模式，它让你在安装一个包的同时，保留对源代码的直接引用。\nuv pip install -e .\n\n\n核心机制：\n不复制代码到 site-packages/。\n而是在 site-packages/ 中创建一个 .pth 文件 或 my_package.egg-link，指向你本地项目中的 src/（或包目录）。\nPython 解释器在导入时，会顺着这个链接去读你本地的源码。\n\n\n\nimage-20251018193022973\n\npython 是从哪里查找模块的Python 查找模块（module）的机制由 模块搜索路径（module search path） 决定，这个路径是一个字符串列表，存储在 sys.path 中。当你执行 import some_module 时，Python 会按顺序在这个列表中的每个目录里查找对应的模块文件。\n可以通过以下代码查看当前 Python 的模块搜索路径：\nimport sysprint(sys.path)\n\nsys.path 通常包含以下几类路径（顺序很重要）：\n\n脚本所在目录（或当前工作目录）\n\n\n如果你运行 python /path/to/script.py，那么 /path/to/ 会被加到 sys.path[0]。\n如果你运行 python 进入交互模式，或运行 python -c &quot;...&quot;，则当前工作目录（os.getcwd()） 会被放在首位。\n⚠️ 这是很多 “意外导入” 问题的根源（比如项目根目录下有同名包）。\n\n\n环境变量 PYTHONPATH 中的目录\n\n\n类似系统的 PATH，你可以通过设置 PYTHONPATH 添加自定义搜索路径。\n\n示例（Linux&#x2F;macOS）：\nexport PYTHONPATH=&quot;/my/custom/modules:$PYTHONPATH&quot;python my_script.py\n\nWindows（PowerShell）：\n$env:PYTHONPATH = &quot;C:\\my\\custom\\modules;&quot; + $env:PYTHONPATH\n\n\n标准库目录\n\n\nPython 自带的模块（如 os, sys, json）所在位置。\n通常位于 Python 安装目录下的 lib/ 子目录中。\n\n\n第三方包安装目录（site-packages）\n\n\n通过 pip install、uv pip install 等安装的包，会被放到 site-packages 目录。\n\n路径可通过以下命令查看：\nimport siteprint(site.getsitepackages())  # 全局环境print(site.getusersitepackages())  # 用户级安装\n\n\n.pth 文件中指定的路径\n\n\n某些包（尤其是 editable install）会在 site-packages/ 中放置 .pth 文件，动态添加路径到 sys.path。\n\n参考资料build + hatchling 15 分钟搞懂 Python 项目结构和打包_哔哩哔哩_bilibili\n","categories":["python"],"tags":["python"]},{"title":"transformer学习","url":"//post/transformer%E5%AD%A6%E4%B9%A0.html","content":"Transformer1. Transformer 主要结构及对比 RNN编码器（Encoder）编码器由多个相同的编码器层堆叠而成，每一层包含以下部分：\n\n多头自注意力机制（Multi-Head Self-Attention）：通过多个注意力头从不同角度学习词与词之间的关系。\n前馈神经网络（Feed-Forward Neural Networks）：对注意力机制的输出进行非线性变换，增强模型的表达能力。\n残差连接和层归一化（Residual Connection &amp; Layer Normalization）：帮助信息流动并稳定训练过程，防止梯度消失。\n\n解码器（Decoder）解码器与编码器类似，但每层解码器额外包含以下机制：\n\n掩蔽多头自注意力机制（Masked Multi-Head Attention）：用于处理目标序列，通过掩码防止当前位置关注未来位置，确保生成过程的自回归特性。\n\n编码器 - 解码器注意力机制（Encoder-Decoder Attention）：使解码器能够关注编码器输出的上下文信息，建立输入与输出序列之间的关联。\n\n前馈神经网络（Feed-Forward Neural Network）：对注意力机制的输出进行非线性变换，增强解码器的表达能力。\n\n\n\n\n对比 RNN\n优点：\n并行化：取消递归结构，Transformer 允许序列中的所有位置同时处理，而 RNN 是逐步处理的，这使得 Transformer 能在训练过程中实现并行化，从而大幅加速训练。\n长距离依赖：RNN 在处理长序列时，容易出现梯度消失或梯度爆炸的问题，而 Transformer 通过自注意力机制能够直接捕捉到序列中任意位置的依赖关系。（引入位置编码， 在不依赖 RNN 结构的情况下，通过位置编码为序列中的每个元素嵌入位置信息，从而使模型能够感知输入的顺序）\n计算效率：Transformer 在每一层的计算是对称的，计算效率较高，且可以扩展到大规模的训练数据。\n\n\nRNN 的缺点：\n训练速度慢：由于其顺序处理的特点，RNN 的计算速度较慢，无法进行高效并行。\n长程依赖问题：RNN 在捕捉长期依赖时表现较差，通常会遭遇梯度消失或爆炸问题，导致学习效果不佳。\n\n\n\n2. 为什么要进行位置嵌入（Positional Encoding）？位置嵌入的作用Transformer 不像 RNN 那样天然具有序列顺序的处理能力，因此需要通过位置嵌入来为模型提供位置信息，使其能理解输入数据的顺序。\n位置嵌入的方式最常用的方式是通过 正弦和余弦函数 来生成位置嵌入。具体做法是为每个位置计算一个向量，使用不同频率的正弦和余弦函数来表示不同位置的信息。这个方式的优点是它可以在不依赖训练的情况下生成，且具有很好的可扩展性。\ntransformer 的自注意力机制（Self-Attention）是位置无关（position-agnostic）的。也就是说，如果不做任何处理，模型无法区分 “我爱你” 和 “你爱我” 这两个句子的差异，因为自注意力机制只关注 token 之间的相关性，而不考虑它们在序列中的顺序。\n为了让模型感知到 token 的位置信息，Transformer 引入了位置编码。\n在原始论文中，Transformer 使用的是固定位置编码（Positional Encoding），其公式如下：\n\n\n其中：\npos 表示位置索引（Position）。\ni 表示维度索引。\ndmodel 是嵌入向量的维度。\n流程：输入的是一个整数索引（位置序号 0,1,2,…）。位置编码模块先把这些整数映射成与词向量同维度的向量（例如 512 维），再把结果加到词向量上。\n如何理解位置嵌入\nhttps://www.zhihu.com/question/347678607\n3. 自注意力机制自注意力机制的作用\n随着模型处理输入序列的每个单词，自注意力会关注整个输入序列的所有单词，帮助模型对本单词更好地进行编码。在处理过程中，自注意力机制会将对所有相关单词的理解融入到我们正在处理的单词中。更具体的功能如下：\n序列建模：自注意力可以用于序列数据（例如文本、时间序列、音频等）的建模。它可以捕捉序列中不同位置的依赖关系，从而更好地理解上下文。这对于机器翻译、文本生成、情感分析等任务非常有用。\n并行计算：自注意力可以并行计算，这意味着可以有效地在现代硬件上进行加速。相比于RNN和CNN等序列模型，它更容易在GPU和TPU等硬件上进行高效的训练和推理。（因为在自注意力中可以并行的计算得分）\n长距离依赖捕捉：传统的循环神经网络（RNN）在处理长序列时可能面临梯度消失或梯度爆炸的问题。自注意力可以更好地处理长距离依赖关系，因为它不需要按顺序处理输入序列。\n\nQ, K, V 的含义\nQ（Query）：查询向量，表示当前关注的词。\nK（Key）：键向量，表示其它词的特征。\nV（Value）：值向量，表示与键向量关联的实际信息。\n\n注意力分数计算公式\n\n\n\n注意力分数的计算方式是通过 Q 和 K 的点积 来衡量 Query 与 Key 之间的相关性。计算公式为：其中，d_k 是 K 向量的维度，* 表示矩阵乘法，softmax 用于标准化分数，使其成为概率分布。\n问题：为什么要除以dk？\n当 dk 较大时，点积的数值可能会过大，导致 Softmax 过后的梯度变得极小\n\n\n\n\n\n\n\n\n\n\nSoftmax函数\n\n在 Transformer 模型中，Softmax 函数不仅在计算注意力权重时用到，在预测阶段的输出处理环节也会用到，因为预测 token 的过程可以看成是多分类问题。\nSoftmax或称归一化指数函数，它将每一个元素的范围都压缩到（0，1）之间，并且所有元素的和为1\n最后经过线性层后进入softmax函数，将每个值向量乘以softmax分数(这是为了准备之后将它们求和)。这里的直觉是希望关注语义上相关的单词，并弱化不相关的单词(例如，让它们乘以0.001这样的小数)。\nSoftmax 通过指数变换放大数值间的差异，让较大的值对应更高的概率，同时避免了负值和数值过小的问题，让模型聚焦于权重最高的位置，同时保留全局信息（低权重仍非零）\n4. 多头注意力机制多头注意力机制就是存在多个不同的权重矩阵（Q、K、V），形成多个矩阵 Z，再把它们 按最后一维（hidden）拼接（concat）→ 做一次线性变换 得到最终输出。\n线性层把拼接后的多头结果 Z_concat（形状 batch×seq×d_model）重新线性映射回与输入相同的维度，同时让网络可以学习如何融合不同头的信息。\n\n\n\n\n\n\n\n\n\n\n5. 残差层和归一化层的作用Add（残差连接，Residual Connection）残差连接是一种跳跃连接（Skip Connection），它将层的输入直接加到输出上（观察架构图中的箭头）：\nAdd，就是在z的基础上加了一个残差块X，加入残差块的目的是为了防止在深度神经网络的训练过程中发生退化的问题，退化的意思就是深度神经网络通过增加网络的层数，Loss逐渐减小，然后趋于稳定达到饱和，然后再继续增加网络层数，Loss反而增大\n\n\n通过直接将输入添加到输出中，帮助缓解深度网络中的梯度消失问题，保证信息能够有效流动。这种连接方式有效缓解了深层神经网络的梯度消失问题\nResNet残差神经网络为了了解残差块，我们引入ResNet残差神经网络，神经网络退化指的是在达到最优网络层数之后，神经网络还在继续训练导致Loss增大，对于多余的层，我们需要保证多出来的网络进行恒等映射。只有进行了恒等映射之后才能保证这多出来的神经网络不会影响到模型的效果。残差连接主要是为了防止网络退化。\n\n\n上图就是构造的一个残差块，X是输入值，F（X）是经过第一层线性变换后并且激活的输出，在第二层线性变化之后，激活之前，F（X）加入了这一层输入值X，然后再进行激活后输出。\n要恒等映射，我们只需要让F（X）&#x3D;0就可以了。x经过线性变换（随机初始化权重一般偏向于0），输出值明显会偏向于0，而且经过激活函数Relu会将负数变为0，过滤了负数的影响。这样当网络自己决定哪些网络层为冗余层时，使用ResNet的网络很大程度上解决了学习恒等映射的问题，用学习残差F(x)&#x3D;0更新该冗余层的参数来代替学习h(x)&#x3D;x更新冗余层的参数。\nNorm（层归一化，Layer Normalization）用于将每一层的输出进行标准化，保持均值为 0，方差为 1。它有助于加速训练，并且提高模型的稳定性。 使用到的归一化方法是Layer Normalization)\nLN是在同一个样本中不同神经元之间进行归一化，而BN是在同一个batch中不同样本之间的同一位置的神经元之间进行归一化。BN是对于相同的维度进行归一化，但是咱们NLP中输入的都是词向量，一个300维的词向量，单独去分析它的每一维是没有意义地，在每一维上进行归一化也是适合地，因此这里选用的是LN。\n  \n\n\n\n6. 前馈神经网络 Position-wise Feed-Forward Networks（FFN）\n\n在 Transformer 中，前馈网络层（Feed-Forward Network，FFN）的作用可以概括为一句话： “对每个位置的向量进行非线性变换，增加模型的表达能力。\n全连接层是一个两层的神经网络，先线性变换，然后ReLU非线性，再线性变换。这两层网络就是为了将输入的Z映射到更加高维的空间中然后通过非线性函数ReLU进行筛选，筛选完后再变回原来的维度经过6个encoder后输入到decoder中。\n7. 三种注意力对比学习（三种注意力）Masked Attention、Self-Attention 和 Cross-Attention 的本质是一致的，这一点从代码调用可以看出来，三者的区别在于未来掩码的使用和输入数据的来源：\n\nMasked Attention：用于解码过程，通过掩码屏蔽未来的时间步，确保模型只能基于已生成的部分进行预测，论文中解码器部分的第一个 Attention 使用的是 Masked Self-Attention。\n\nSelf-Attention：查询、键和值矩阵来自同一输入序列，模型通过自注意力机制学习输入序列的全局依赖关系。\n\nCross-Attention：查询矩阵来自解码器的输入，而键和值矩阵来自编码器的输出，解码器的第二个 Attention 模块就是 Cross-Attention，用于从编码器输出中获取相关的上下文信息。\n以机器翻译中的中译英任务为例：对于中文句子 “中国的首都是北京”，假设模型已经生成了部分译文  “The capital of China is”，此时需要预测下一个单词。\n在这一阶段，解码器中的交叉注意力机制会使用当前已生成的译文 “The capital of China is” 的编码表示作为查询，并将编码器对输入句子 “中国的首都是北京” 编码表示作为键和值，通过计算查询与键之间的匹配程度，生成相应的注意力权重，以此从值中提取上下文信息，基于这些信息生成下一个可能的单词（token），比如：“Beijing”。\n\n\n需要掩码注意力的原因在解码阶段，每一步生成的词语只依赖于前面已生成的词语。因此，需要通过 掩码（Masking） 来确保每个位置的注意力只关注其前面的位置，而不允许查看未来的位置。\n输入需要编码器的输入的原因解码器需要编码器的输出作为上下文信息来生成最终的目标序列。编码器提供的上下文信息有助于解码器更好地理解输入序列的语义和结构。\n解码器和编码器的输出\n编码器的输出：编码器生成的隐藏状态序列，包含了输入序列的语义信息。这些信息将被解码器用于生成最终的输出。\n解码器的输出：解码器根据编码器的输出和已生成的部分输出，逐步生成目标序列（首先经过一次线性变换（线性变换层是一个简单的全连接神经网络，它可以把解码组件产生的向量投射到一个比它大得多的，被称为对数几率的向量里），然后Softmax得到输出的概率分布（softmax层会把向量变成概率），然后通过词典，输出概率最大的对应的单词作为我们的预测输出。）\n\n8. GPT与 Transformer 的关系GPT，即 Generative Pre-Training Language Model，是由 OpenAI 团队于 2018 年发布的预训练语言模型。虽然学界普遍认可 BERT 作为预训练语言模型时代的代表，但首先明确提出预训练 - 微调思想的模型其实是 GPT。\nGPT 提出了通用预训练的概念，也就是在海量无监督语料上预训练，进而在每个特定任务上进行微调，从而实现这些任务的巨大收益。虽然在发布之初，由于性能略输于不久后发布的 BERT，没能取得轰动性成果，也没能让 GPT 所使用的 Decoder-Only 架构成为学界研究的主流，但 OpenAI 团队坚定地选择了不断扩大预训练数据、增加模型参数，在 GPT 架构上不断优化，最终在 2020 年发布的 GPT-3 成就了 LLM 时代的基础，并以 GPT-3 为基座模型的 ChatGPT 成功打开新时代的大门，成为 LLM 时代的最强竞争者也是目前的最大赢家。\n9. 相关资料Transformer 论文精读\nCSDN博客文章\nTransformer快速入门\n","categories":["transformer"],"tags":["AI"]},{"title":"从当下开始","url":"//post/%E4%BB%8E%E5%BD%93%E4%B8%8B%E5%BC%80%E5%A7%8B.html","content":"对学历的理解本硕双非，曾经的理解，双非就像一个标签刻在自己身上，也是会有一种想法，觉得考上双非特别是研究生，是不是落后别人一大截，怎么挺身而出？其实在现在看来，我不会这么想了，每个人都会有自己的一段路程，在读研的过程中，我深刻体会到需要自洽、自强，好的学历会接触更多优秀的人、有更好的资源，强大的开始就是对学历祛魅跟自己和解，找到自己的舒服方式，接触更多优秀的人，让自己有实力有能力去接受挑战，双非不是标签，理性看待学历，专注于自身硬实力和软实力的成长。\n对自律的理解最近在寻找 AI 相关资料时，看到了一个博主的技术博客，特别是博主写的碎碎念。我开始深思：自己在过去的一段时间里，好像不太明白学习的目的究竟是什么，没有明确坚定的方向，学习似乎更多是为了感动自己。我开始思考何为自律，是自愿的学习，还是仅仅担忧未来是否能够有一个好的事业。回头想想，我没有坚持培养积极的爱好，容易陷入误区。\n我也看到许多高考励志的故事，或许在今后的路上，我再也不会指责过去的自己。无论结果如何，如果可以再来一次，我可能会走上相似的道路，经历相似的挑战。\n关于学习与成长我很喜欢阅读美文，自己表达的能力并不强，常常遇到一些好的文章或句子时，会将它们收藏起来。在业余时间，我会选择去阅读书籍，这是之前的领导给我的建议，很多事情其实可以在书中找到答案。虽然一些道理我已经看过很多遍，但真正能执行下去的却并不多。\n从这么长时间的读书生涯中，我意识到自己并不是一个特别擅长学习的人，对自己的专业也没有特别深的热爱。有时候，学习并没有深入专研，我一直处于输入阶段，却没有足够的输出。与此同时，我也意识到软实力同样重要——交际表达、为人处事等等。\n未来的路在今后的日子里，可能我会走得比较慢，但我依然希望不负当下的时光，成为一个更好的自己。我会向优秀的人学习，跳出眼前的视野，继续前行。\n","categories":["碎碎念念"],"tags":["碎碎念念"]},{"title":"你好2026","url":"//post/%E4%BD%A0%E5%A5%BD-2026.html","content":"你好2026\n\n\n\n\n\n\n\n\n在2026的开始之际，首先我想回忆过去一年我所做的事情，其次是想给自己在2026定下目标与方向。\n关于2025这一年，我更看见了自己2025年于我而言，是很特别的一年，在这一年里，我有过徘徊、失落、焦虑与不安，虽从现在来看，不过是过眼云烟，在这一年里，我仿佛更好地看到了自己。\n项目与论文：告别、投递、开心我在项目组又待了一年，不管是解决小的Bug又或是负责整个项目的开发与分工，在项目组我收获了正向的反馈，给自己充能。恰逢2026年的第一天，我收到了来自项目组的最后一笔酬金，在2026的开始有一个好彩头，终归于结束，我在项目组的故事要结束啦，始于24年9月，止于25年11月。也是经历了很长时间的努力与折腾，在2025年的12月31日，把自己的第一篇英文小论文投出去了，在我看来写得不怎么样，但是也是我这么长时间的折腾，对我而言也是一件很开心的事情，我终于写了一篇垃圾出来啦，心路历程太坎坷了，希望后续在去弄论文的时候会少走一些弯路和少一点纠结。\n🌱 2026：完成优先，平衡前行我感觉自己做事情就是想追求一点稍微比较完美的一点的人，如果觉得不太好了我就想推倒重来，我现在发现也不是一件特别好的事情，希望今年自己可以改变这一点想法，完成和完美，我觉得还是得先完成，一个故事再好可能也会有不完美的地方，也不能太折腾自己。关于技术的沉淀，我觉得一个人的精力确实没办法做到很多事情都能兼顾好，平衡技术与科研还有生活确实我面对的一大课题，有的时候也会请教别人怎么做得到的，有个博主说，一天的时间很长，双线程的学习也是可以做到的，比如上午和晚上学技术，下午时间最长就把时间留给科研。那个博主确实也很厉害，我在过去的时间里，很多时候一天完全花在论文上面，到了晚上，我就会头疼，然后晚上就睡不好。因此呢，我觉得在今年的时间里，尽量做一个平衡，一周来一个时间线规划，完全把时间花在论文上面也是不行的。\n关于心态的成长，在2025年里，我面对了很多的事情，处理与导师的关系等等，我反思过自己确实当初有些鲁莽，让自己失去了一些机会，忍受了不公平的待遇，在斗争中成长，是因为这场斗争，让我在这个过程中成长了很多。老师对我说过一些说过话，我一直都记得，“我们这个研究生这个学校学历的标签也不能给你带来很多的优势，用内驱力去做好一件事，你不比别人差”，“努力强大自己，该来的总会来的”，有的时候我觉得他说的话我能理解，因为他本身就是一个非常努力奋斗的人，我觉得自己在新的开始，不仅仅是思考与反思，而是不断去行动。在这一年里，AI大模型奋起直追，在这一年里我也在不断使用AI的工具来帮助自己解决问题，有人说“做事情前让AI分析一遍”，老师说：“在人机交互的时代，我们要做AI的驱动者，但是不能一味使用AI，不能失去自己的思考能力。“当然，希望以后自己还是不能缺乏思考。我也做了接近两个月的关于AI应用的实习，让我初步了解了AI的相关应用场景，今年希望有机会能去更好的平台去实习锻炼。2025的故事其实还有很多很多，我只是回忆其中的主要部分，希望2026不遗余力，勇敢向前，路虽远，我想相信行之将至。\n新的目标在2026年我想给自己定几个目标：①真正做好平衡科研与技术，尽快完成论文②保持专注，不遗余力去做好应该做的事情③继续强大自己，把握机会，努力成长 \n\n\n","categories":["总结"],"tags":["总结"]},{"title":"大模型基础","url":"//post/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80.html","content":""},{"title":"实习感想","url":"//post/%E5%AE%9E%E4%B9%A0%E6%84%9F%E6%83%B3.html","content":"实习感受在不知不觉中，实习已经有一个多月的时间了，简单概括一下这段经历。\n回想起在找实习的这段时间里，心里还是很没底的，坦白说我的简历项目全是网上 Copy 的，接触 AI 这个方向也是因为小红书上面的博主分享的一些经历，跟着博主的路径，了解到 AI 应用开发这个新的方向，目前赛道还不是很卷。之前也接触过 AI 低代码平台，想着试一试。\n公司是一个比较大一点的外包公司，要说有啥活，倒是真的没啥活，项目也不是很多。坦白说，要想在这个公司学点高一点的技术还是很难的，部门主要是后端开发的部分，AI 刚刚起步。目前做的相关技术就是 LangChain 实现 RAG 系统，Python 后端相关的技术，暂时还没有涉及到大模型微调和 RAG 优化技术。\n最后想对自己说，确实是先出发很重要，慢慢认识自己，定目标，达到成就，有责任感，让自己充满力量去抵御未知的困难。最后呢，还是挺感恩每一次的遇见，记录每个阶段的感受，达成阶段性可实现的目标和计划，最后也要好好生活，认真对待当下的时光。\n\n\n\n\n\n\n\n\n\n在 8 月也和前同事一起交流了，他也告诉我很多道理，但是呢，有的时候其实确实得自己去经历去感受一些事情。比如学会做实事、定阶段性的目标和规划、学会理财（当然得先有资本，但得有意识）\n\n","categories":["实习"],"tags":["实习感想"]},{"title":"我的2025","url":"//post/%E6%88%91%E7%9A%842025.html","content":"✨ 最近抖音里面看到一种流行的方式以作文的形式记录我的2025，我也想在记录的同时对自己说，相信自己，所有的经历都是成长的缩影。\n🌿 关于我\n\n\n\n\n\n\n\n\n这是一段简短的回忆，主要是想告诉自己要不忘初心\n我来自一个普通的家庭，靠自己的努力成了家族第一个一本大学生，第一个研究生。在高考成绩出来的那一刻，我舅舅劝我复读的那一刻，我留下了泪水，我觉得对不起父母和努力的自己。离开县城去往大学的那一刻，我一个人带着箱子，坐上去往武汉的车上，当时我一直在听的那首歌是《去年夏天》。在本科，感受了一段特别的时光，它教会我真诚待人，崇真尚美的纺大精神，是作为纺大人不能忘的。在武汉天喻教育公司，它再次教会我，认知的重要性。过去虽有遗憾，但也是必经之路，追忆过去也不是内耗，是不忘来时的路，珍惜当下的时光。来到湖大一年近半载，它教会我需要不断强大自我，需要积累持续正向的反馈给自己充能。在项目组一年多的时间，让我持续积累的一点点正向的反馈，这段时光也是值得的。在小红书与更多名校的同学请教过科研和技术相关的问题，也让我明白需要找到自己的方向，沉淀自己。在党校的学习中，让我理解何为真正的优秀。在接下来的时间里，还需继续努力，但更需要的是不遗余力。\n🌙 关于内耗在2025年，对我而言，发生了很多的事情。很重要的一件事，就是关于论文。我对老师说，我想发论文，可能更多的是想要证明自己。但是想象是美好的，现实是残酷的，这条路并不简单，看到身边的同学学技术那种自信的表现，在看看自己搞论文一无所获的心情是无语言表的。那个时候就容易焦虑，加上老师的话语，“为什么别人能搞出来，你为什么不行”，这样的刺激，就更想证明自己是可以的。于是，就这样跟自己对抗，邮箱中堆满了论文，找论文无所不尽其极。那时候就容易内耗，跟老师关系也不好。慢慢的，我从一个听话的好学生慢慢转变，去寻找自己的路。于是，我短暂的放弃了几个月搞论文的时间，那段时间我天天学技术，了解新的岗位，学习Ai相关的知识。那段时间真的不内耗了，因为技术的学习是可以立竿见影的，会带来积极的反馈，做下去就更有动力。“世界源于我的认知”，理想跟现实是一定会有差距的，因此，我现在觉得有些事情不用纠结，在自己的能力范围内做到最好。\n🔥 关于勇敢说到勇敢，我的电脑首页就选择了勇气是自由的序章作为背景，提醒自己需要有勇气。在本科期间，我明白我缺乏勇敢，失去了很多锻炼自己的机会。因此，在研究生的生活中，从组会到上台汇报，我会把握每一次真实锻炼自我的机会。还有就是我在考试的过程中，也经历了一点点的挫败感，以前总是会沉浸在悲伤的氛围中，慢慢觉得，真正的勇敢需要敢于承担失败的勇气，不会一直失败，但是需要真的明白自己的不足。在找实习的过程中，在找工作的经历中，也需要勇敢的展现自己，不怯场，可以接受不会或是失败，但是不能失去重来的勇气。\n\n📌 关于未来我想在读研接下来的时间里，第一是明确方向，就业的方向，提前做好准备；第二是保持自律，把握松弛感，持续学习，沉淀自己；第三是学习和保持美好的品质，真诚待人；第四是珍惜当下的事和人，向优秀的人学习。\n","categories":["总结"],"tags":["总结"]},{"title":"扣子智能体教程","url":"//post/%E6%89%A3%E5%AD%90%E6%99%BA%E8%83%BD%E4%BD%93%E6%95%99%E7%A8%8B.html","content":"Agent\nChatGPT\n\n\n\n\n角色 \n技能\n输出格式\n限制条件\n\n\n系统提示词 针对大模型的场景\n用户提示词 针对的是特定的任务 用户的问题或者指令\n一个bot可以关联多个知识库 是按照顺序来执行检索的\nFunction Calling  \n大语言模型调用外部工具的能力\n调用外部函数  或者服务 \n\n\n大模型不会调用函数  仅仅返回函数的参数\n真正执行函数的是 背后的服务\n工作原理 \n用户请求-大模型判断是否调用函数-函数结果返回大模型-给出答案\n在coze平台中 模型通过阅读插件描述来决定是否调用该插件\n工作流节点\n大模型节点：\n系统提示词：规定大模型的角色和功能\n用户提示词：可以理解为用户的问题组合\n跨境电商答疑助手","tags":["AI"]},{"title":"念念不忘，必有回响","url":"//post/%E5%BF%B5%E5%BF%B5%E4%B8%8D%E5%BF%98%EF%BC%8C%E5%BF%85%E6%9C%89%E5%9B%9E%E5%93%8D.html","content":"","categories":["碎碎念念"],"tags":["碎碎念念"]},{"title":"摘抄语录","url":"//post/%E7%83%AD%E7%88%B1%E7%94%9F%E5%91%BD.html","content":"热爱生命🍂 我不去想，是否能够成功。既然选择了远方，便只顾风雨兼程。  \n🌹 我不去想，能否赢得爱情。既然钟情于玫瑰，就勇敢地吐露真诚。  \n🌬️ 我不去想，身后会不会袭来寒风冷雨。既然目标是地平线，留给世界的只能是背影。  \n🛤️ 我不去想，未来是平坦还是泥泞。只要热爱生命，一切，都在意料之中。  \n恰到好处的幸福🫧 有些东西，并不是越浓越好，要恰到好处。🌿 深深的话我们浅浅地说，🐾 长长的路我们慢慢地走。  \n📖 —— 毕淑敏《恰到好处的幸福》\n目送🚶 我慢慢地、慢慢地了解到，所谓父女母子一场，只不过意味着，你和他的缘分，就是今生今世不断地在目送他的背影渐行渐远。  \n🌫️ 你站在小路的这一端，看着他逐渐消失在小路转弯的地方，而且，他用背影默默告诉你：不必追。  \n📖 —— 龙应台《目送》\n🌱你好生活🕯️ 每一个优秀的人都有一段沉默的时光，⏳ 那段时光是付出了很多努力却得不到结果的日子，🌿 我们把它叫做扎根。  \n📺 ——《你好生活》\n🌳时间🪴 种一棵树最好的时间是十年前，🕰️ 其次是现在。\n","categories":["阅读"],"tags":["阅读"]},{"title":"王阳明：知行合一的智慧","url":"//post/%E7%8E%8B%E9%98%B3%E6%98%8E%EF%BC%9A%E7%9F%A5%E8%A1%8C%E5%90%88%E4%B8%80%E7%9A%84%E6%99%BA%E6%85%A7.html","content":"王阳明：知行合一的智慧简介王阳明是明代“心学”的集大成者，他以“心即理”“知行合一”“致良知”的思想，开创了影响深远的哲学体系。阳明心学融汇儒释道三家智慧，启人自省、修身立德，揭示了心性与实践的统一之道。本书由国内知名心学专家罗智倾心撰写，凝结三年研究心血，以通俗而深刻的笔触，带领读者理解阳明心学的精神内核，体悟知行合一的真义，修炼笃定自信的心智，开启充盈而自在的人生。\n\n\n\n\n\n\n\n\n\n感受：断断续续的看完了这一本书，但是自己对于本书所有传递的道理和精髓没有很好的体会，于是决定在读一遍，认真读几遍，然后记录下自己的感想。先认识到，再去执行，认识是行动的开始。\n阅读笔记（一）\n\n\n\n\n\n\n\n\n时间 ：2025&#x2F;10&#x2F;25\n第一章：立志乃完事之本            \n本书第一章要传达的核心，是“树立志向是成功的根本”，以及在实现目标的过程中所必备的品质。我们生活在一个物质丰富、诱惑无处不在的时代，如果没有足够的定力与清醒，很容易被外界牵着走，从而忘记自己最初想做的事。每个人都有不同的追求，或渴望外在的富足，或追求内心的宁静。然而，在欲望与诱惑面前，唯有坚定志向、专注前行，才能不偏离轨道，真正做到“业精于勤”，实现心中所想。\n确定坚定的志向\n书中提到，一个人要想达到人生中的目标，首先得树立坚定的志向。说到这一点，我也深受感受，举一个例子，我的本科室友当初在考研的时候就树立要考211大学，而且就为了这个目标真的全身心投入，最后终于成功了。但是我呢，我在这个其中有一些个人的原因，遇到一些问题，然后缺乏正向的思维，导致我失败了。坚定的志向我认为很重要，好比指南针，指引前进的方向。为什么要强调坚定呢？上面是我自己的一个例子，坚定的志向，就是强大的能量，有的时候会发现身边的大家可能都差不多，为啥后面会那么优秀呢？在努力追求梦想、志向的过程中，会遇到各种因素如挫败感、外在的干扰等等，导致可能没有那么坚定了，志向如果没有坚定，那相当于存在动力不足，可能心里会想到失败的结果就不会那么努力。有道是：苦心人，天不负。要相信上天不会辜负每一个努力的人，困难只是暂时的，总会有拨云见日的那天。树立坚定的志向，排除掉外界的各种干扰，用尽全部的努力，一心奔赴自己的前程，梦想才有实现的可能。\n\n\n\n\n\n\n\n\n\n因此，在确定志向方向后，时常问一问自己，自己是否为之付出了不遗余力的努力了吗？是否尽全力了吗？跟自己对比，不让自己留下遗憾。\n正向的思维\n那确定了志向之后，在实现的过程中需要有哪些品质呢？第一，坚定，要相信每个志向都有实现的可能；第二，正向的思维；第三，保持耐心；第四，在头脑中看到自己的志向。成长的过程中会遇到各种各样的困难和挫折，但是不能让挫折的情绪一直困扰着我们，可以短暂停留，但是更重要的是还要继续前行。王阳明在仕途中也遇到了很多的挫折，有一个故事是他被贬后，惨遭追杀，逃离之后发现自己的士兵都病了，照顾他的人都没有，但是王阳明还是没有抱怨当时的环境，改变心态，自己做家务，组织娱乐活动，结果是士兵们都好了起来。在我成长的过程中也遇到了很多的挫败，在回看过去的经历，能感触到很多。书中说到，其实历史上的很多人物，都遭遇了很多的挫折，但是他们并没有就此放弃自己，如孙斌、司马迁等等，还留下了许多著名的著作。因此，在困难面前，抱怨是没有用的，改变我们的心态，保持正向的思维，持续不断地努力，当情绪涌上心头的时候，可以想想假设是别人，他会怎么做，换一个角度来思考问题，避免一直处于抱怨的情绪中。\n保持耐心\n所谓欲速则不达，不以绝对的动机去完成任务。书中谈到王阳明对兵法精髓的理解，兵法不是书本上的死的、教条的东西，需要千锤百炼，理解之后融会贯通，而不是背下来，然后纸上谈兵。因此，就如很多专家说的，在一个领域专心科研，第一是可以成为自己的职业，第二是热爱，不断学习更深层次的东西。因此，在科研的路上或者是在未来的职业发展道路中，保持耐心，不冲动行事，慢慢积累，对领域达到更深层的理解。\n看到自己的志向\n谈到在头脑中看到自己的志向，我想到现实生活中的一个例子，我姐在干销售的过程中，有很大的愿力，就是每个月一定要达到规划的业绩。她不仅写下来，还常常在心里描绘完成后的场景。这种愿力让她在压力中始终充满斗志，最后是她真的实现了。就好比我第二次考研，我心中就知道我一定可以考上，结果我花了50多天的时间就考上了。\n\n\n\n\n\n\n\n\n\n最后附上书中的一段语录：\n首先，在心中思索、想象自己想要达成什么样的理想，要尽量想得清晰，确立一个具体的目标。其次，找出自己树立志向的动机或意义，想清楚为了实现目标自己要做些什么，要成为什么样的人。\n最后，以行动来实践、证明自己的志向，在行动中不断强化自己的信念，调整自己的心态，让志向成为生命中最重要的一件事。\n阅读笔记（二）\n\n\n\n\n\n\n\n\n时间：2025&#x2F;11&#x2F;8\n第二章：王阳明的修养之道\n本文第二章讲授的王阳明的心性修养之道，主要包含掌握情绪、培养定力、认识自我\n镇静\n当下是一个容易让人心浮气躁的时代，或多或少的杂事围绕着，短视频的兴起让大家都没有耐心，导致我们都慢慢变得很急躁，做一件事想立马看到效果，一段关系急着想知道答案。为什么要静心？静下来去感受，允许自己慢慢思考，不急功切利，缓一缓，遇到问题静心思考，在采取行动，会有不一样的效果。临危不惧者，乃强者也。不管遇到什么，先让自己静下心来，在冷静思考，达成很好的执行力。\n凡是要小心谨慎\n书中提到敬畏，并不是心中有恐惧忧患的意思，而是在别人看不见听不到的地方，也要自觉地进行修养，不因没人看见而放荡不羁，时时保持戒慎恐惧之心在不同的环境场合之中，保持敬畏、谨慎和自我约束的态度，不太放纵和大意，言行谨慎，学会倾听，洞察事物之间微妙的关系，学会掌握情绪。\n不让负面情绪折磨自己\n俗话说：“人非圣贤，孰能无过。”绝大多数人都会犯错，既然已经发生的事情，那么沉浸在过错之中就会一直消耗自己的情绪。比如一场考试的失利，没有准备好，结果是失利，这个时候如果说“要是自己好好准备就能过了”这样的话已经为时已晚。可以允许自己犯错，因为有些因素我们没法把控，但是也一定要有翻篇的能力，不让那些负面的情绪让自己内耗。如果有失利，要反思失利的原因，经历这么多的考试，我也发现周围也有一些同学真的对考试很认真的一个态度去学习，我自认为在这一点上我还需要努力。我也才慢慢感受到，有些选择是冥冥之中注定的，不用去责怪过去的自己，更不用去后悔，可能再来一次，又会有相同的结局。\n\n\n\n\n\n\n\n\n\n王阳明认为，对于做错的事情，有悔恨之心可以理解的，也是改正错误必经的过程，但必须要有一个‘度’，有了失误察觉到了，及时改正就行了。如果对不如意的事念念不忘，老是让这种负面情绪停留在心中折磨自己，则又会因此产生新的毛病。\n认识自己\n如果要问我这个问题：“你认识自己吗？”我可能还不知道完整回答这个问题，但是我想说我在慢慢认识自己的路上。明确内心真正要成为的人和实现的目标，倾听内心的声音，心无旁旁骛朝着目标前进。书中讲到王阳明探索圣贤之路的历程，老师说了一句这样的话深深触动了王阳明的内心，“圣人必可学而至“。在他的脑海里仿佛就看到经过重重困难，成为圣人的场景，这是我们常常听到的念念不忘，必有回响。因此，不要说”江山易改，本性难移“，我们要说为了成为心中那个更好的自己，愿意改变自己的缺点和不足，接纳短暂的失利，不断打破旧的自己，在默默无闻之处沉淀，朝着大路走，为实现长期的目标，永远相信美好的事情即将发生。\n\n\n\n\n\n\n\n\n\n在安静放松的状态中，排除一切干扰，向内心的自我提问，在你的心目中，自己希望过着怎样的人生，什么东西是你生命中最重要的？如果自己的梦想有可能实现的话，自己为什么不去采取行动？当前是什么东西阻碍了自己？如果你一定要追求自己的梦想，你要改变哪些行为习惯？你会做些什么?\n释放怒气\n在不同的环境之中，我们每个人都会有偏激的情绪，学会掌控情绪也是一个很重要的事情。对我来说，这也是我也需要学习的，有的事情其实换个角度来说真的不一样，不积累糟糕的情绪，真正做情绪的掌控者。\n\n\n\n\n\n\n\n\n\n书中提到的一种释放方式：在觉得自己心中那些愤懑的情绪在不断积累，即将爆发出来时，一定要及早觉察，知道情绪不对了，就赶快转移自己的注意力，坚决制止自己，深呼吸放松自己，不再往负面事件联想下去，同时想想辽阔的天空，宽厚的大地，尽量往好的方面去想，用大自然的力量来冲淡心头的愤懑，让心胸保持一种豁达的状态。\n阅读笔记（三）\n\n\n\n\n\n\n\n\n时间：2025&#x2F;12&#x2F;18\n第三章：王阳明的为人处事之道\n处世哲学\n在人际交往过程中，不能过于对身边的人过于苛责，学会严于律己，宽以待人，对自己严格要求，言行举止需要掌握分寸。不自傲，学会人情事故，避免关系过于复杂。陷入争论时，学会以柔克刚，问一问自己，“一味顶下去，能够解决问题吗？”如果不能，可以换一种灵活有效的方法。\n\n\n\n\n\n\n\n\n\n从更高的层次来说，本来是没有什么杂念的，正如古人所说：“世上本无事，庸人自扰之。”这些杂念只是我们的心神受到扰动，而我们又不肯放弃，不肯和它们和平共处所引起的，如我们千方百计想将杂念剔除的这一个念头，它就是一个杂念。只有当我们的心态柔和下来了，连驱除杂念的想法都不再有了，非常平和、非常自然地停留在当下的事情上，如观看一个念头或一个部位，或数着自己的气息或一串念珠，没有什么分别，也没有什么执着，原来的杂念不用我们刻意驱赶，自然消失得无影无踪，因为这些杂念、障碍本来就是没有的。\n接受现实\n不论过去和理想，更重要的需着眼于当下，接受现实，学会透过现象看本质，当明白一件事的本质之后，也就不用那么纠结了，集中精力把时间花在需要做的事情上。\n\n\n\n\n\n\n\n\n\n在通向成功的道路上，不仅需要你的才华和能力，更需要你在奋斗的过程中，不断战胜自身的弱点，如胆怯、绝望、浮躁、彷徨等等。最重要的是，你要有一颗能安于现实，埋头苦干的心。一个人的时间和精力都是有限的，要想能更快地达到目标，就要求你必须停止胡思乱想，一心将注意力集中到需要做的事情上。\n做正确的事\n在很多时候，在看似忙碌的时间里，也会做着很多的杂事，我深有体会，跟自己的理想有偏移。\n“吾日三省吾身”，时常反省自己，看问题出在哪里，是否存在一些消极的信念在阻止自己行动，还是其他的负面情绪影响了自己的行动。\n\n\n\n\n\n\n\n\n\n做正确的事情是需要智慧、勇气和能力的，很多时候，我们不敢或不想去做正确的事情，其实就是害怕付出，害怕自己没有足够的勇气投入战斗，害怕自己的智慧不够，害怕自己的能力不足以担当，所以就退缩了，而用另一种现象来安慰自己，以显示自己并没有因为无所事事而虚度时光。\n不要在意过多闲话\n\n\n\n\n\n\n\n\n\n王阳明认为，一个人在致良知的路上，应该有一种“定力”，要有“咬定青山不放松，任尔东南西北风”的精神，在往人生巅峰迈进的过程，注定是孤独的，会有各种打击、讥笑、诽谤、侮辱等，只有不顾一切，排除干扰向上攀登的人，才有可能到达顶峰。\n","categories":["阅读"],"tags":["阅读"]},{"title":"知识图谱","url":"//post/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.html","content":"知识图谱实体在自然语言处理中，实体（Entity）通常指的是文本中具有独立存在、能够被明确识别并且具有特定意义的对象。实体通常是指一些特定的名词，它们代表现实世界中的对象或概念，可以是人、地点、组织、事件、日期、物品、概念等。\n例如：\n\n人名：维克托·迈尔-舍恩伯格、肯尼斯·库克耶\n地点：北京、美国\n组织名：微软公司、谷歌\n事件：新冠疫情、2024东京奥运会\n日期：2024年12月、2023年11月\n物品：iPhone、蓝牙耳机\n概念：大数据、机器学习\n\n知识图谱中的实体\n在知识图谱中，每个实体都有其独特的标识符和属性（例如，姓名、类型、描述等）。这些属性和关系帮助我们理解实体在特定领域中的作用和上下文。实体识别是图谱构建的重要步骤之一。\n例如，假设我们有以下句子：”维克托·迈尔-舍恩伯格是《大数据时代》一书的作者，他是大数据领域的专家。”\n在这个句子中，实体包括：\n\n维克托·迈尔-舍恩伯格（人名）\n《大数据时代》（书名）\n大数据领域（概念）\n\n这些实体在知识图谱中将被标识为节点，并且可以与其他节点（如其他作者、书籍、领域等）通过关系（如“写书”，“属于领域”）连接，形成知识图谱中的一个网络结构。同时，在知识图谱中，实体是基础组成单元，它们通过关系（relationship）连接，构成一个图的结构。实体和关系是构建知识图谱的两个基本元素。实体之间的连接关系定义了图谱中的知识和数据。\n","categories":["知识图谱"],"tags":["知识图谱"]},{"title":"语录","url":"//post/%E8%AF%AD%E5%BD%95.html","content":"优秀是一种惯性，会要求自己各方面都做得好，而马虎也是一种惯性，会习惯什么都是低水平徘徊。  \n优秀的人之所以优秀，不是因为他们最终达到了什么样的高度，而是因为在实现目标的过程中，他们挤压出了灵魂中全力以赴的一面。  \n如果你想要征服星辰大海，必须先征服自己的内心。  \n🌟 坚持，是最温柔的力量。\n\n\n\n\n\n\n\n\n\n这是今天课上PPT上的一段话，我想把他拿出来，然后就是今天从历史故事中学到了很多，以后当自己遇到一些想不通的事情或者是一些困难的时候，换个角度来看看怎么解决问题。\n","categories":["语录"],"tags":["语录"]},{"title":"语录分享","url":"//post/%E8%AF%AD%E5%BD%95%E5%88%86%E4%BA%AB.html","content":"昙花若只一现，更要开得耀眼 🌸✨\n毕淑敏 有一句很励志的话： “在光芒万丈之前，我们都要欣然接受眼下的孤独和偶然无助，认真做好眼前的每一件事， 你想要的都会有。” 💪🌟\n村上春树 的话也常常触动心灵： “我知道你最近很累，是那种看不见、身体上和精神上的疲惫感，但是请你一点要坚持下去。就算无人问津也好，技不如人也罢，千万别让烦躁和焦虑，毁了你本就不多的热情和定力。前路漫漫，当克己，当慎独，别贪心，我们不可能什么都有，也别灰心，我们不可能什么都没有。” 🌙🌱\n“尽管当下的糟糕也只是黎明前的短暂黑暗而已，所有经历的苦难都会是未来惊喜的伏笔。花会沿路盛开，我们未来的路也是。” 🌅🌸 —— 你一定会看到属于你的美好！ 🌈💖\n","categories":["语录"],"tags":["语录"]},{"title":"设计模式","url":"//post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html","content":"设计模式什么是设计模式设计模式是对软件设计中常见问题的通用解决方案总结，它关注的是代码结构与职责划分，目的是让系统更易维护、扩展和理解。\n\n\n\n\n\n\n\n\n\n把容易变化的部分隔离出来：创建变化 → 工厂 算法变化 → 策略 功能增强 → 装饰器 对象复杂 → 建造者\n “未来哪一部分最容易变化？” 然后提前把它从核心逻辑中隔离出去。\n工厂模式解决问题：对象创建逻辑复杂，或者经常变化，不想在业务代码中到处写if/elif/new\n原始写法：\nclass DatabaseConnection:    def __init__(self, host, port, username, password):        self.host = host        self.port = port        self.username = username        self.password = password    def connect(self):        return f&quot;Connecting to database at &#123;self.host&#125;:&#123;self.port&#125; with username &#x27;&#123;self.username&#125;&#x27;&quot;def client():    main_db = DatabaseConnection(&#x27;localhost&#x27;, 3306, &#x27;root&#x27;, &#x27;password123&#x27;)    analytics_db = DatabaseConnection(&#x27;192.168.1.1&#x27;, 5432, &#x27;admin&#x27;, &#x27;securepass&#x27;)    cache_db = DatabaseConnection(&#x27;10.0.0.1&#x27;, 27017, &#x27;cacheuser&#x27;, &#x27;cachepass&#x27;)    print(main_db.connect())    print(analytics_db.connect())    print(cache_db.connect())client()#新增一种数据库连接 就需要修改上述代码 违反开闭原则\n\n思路：把创建对象的责任集中到一个地方，业务代码只负责用。把对象的创建过程封装起来，调用者不需要关心具体创建的是哪个类，只需要知道“我要一个某种类型的东西”。\ndef connection_factory(db_type):    db_configs = &#123;        &#x27;main&#x27;: &#123;            &#x27;host&#x27;: &#x27;localhost&#x27;,            &#x27;port&#x27;: 3306,            &#x27;username&#x27;: &#x27;root&#x27;,            &#x27;password&#x27;: &#x27;password123&#x27;        &#125;,        &#x27;analytics&#x27;: &#123;            &#x27;host&#x27;: &#x27;192.168.1.1&#x27;,            &#x27;port&#x27;: 5432,            &#x27;username&#x27;: &#x27;admin&#x27;,            &#x27;password&#x27;: &#x27;securepass&#x27;        &#125;,        &#x27;cache&#x27;: &#123;            &#x27;host&#x27;: &#x27;10.0.0.1&#x27;,            &#x27;port&#x27;: 27017,            &#x27;username&#x27;: &#x27;cacheuser&#x27;,            &#x27;password&#x27;: &#x27;cachepass&#x27;        &#125;    &#125;        return DatabaseConnection(**db_configs[db_type])# 测试工厂模式if __name__ == &quot;__main__&quot;:    # 使用工厂函数创建不同类型的数据库连接    main_db = connection_factory(&#x27;main&#x27;)    analytics_db = connection_factory(&#x27;analytics&#x27;)    cache_db = connection_factory(&#x27;cache&#x27;)        # 测试连接    print(main_db.connect())    print(analytics_db.connect())    print(cache_db.connect())\n\n将数据库的配置信息提取到 config.py\n#factory_pattern.pydef connection_factory(db_type):    &quot;&quot;&quot;    工厂函数：根据数据库类型创建相应的数据库连接        Args:        db_type (str): 数据库类型 (&#x27;main&#x27;, &#x27;analytics&#x27;, &#x27;cache&#x27;)        Returns:        DatabaseConnection: 数据库连接实例        Raises:        KeyError: 当提供的数据库类型不存在时    &quot;&quot;&quot;    from config import DATABASE_CONFIGS    if db_type not in DATABASE_CONFIGS:        raise ValueError(f&quot;Unknown database type: &#123;db_type&#125;. Available types: &#123;list(DATABASE_CONFIGS.keys())&#125;&quot;)        return DatabaseConnection(**DATABASE_CONFIGS[db_type])\n\n#config.py# 数据库配置字典DATABASE_CONFIGS = &#123;    &#x27;main&#x27;: &#123;        &#x27;host&#x27;: &#x27;localhost&#x27;,        &#x27;port&#x27;: 3306,        &#x27;username&#x27;: &#x27;root&#x27;,        &#x27;password&#x27;: &#x27;password123&#x27;    &#125;,    &#x27;analytics&#x27;: &#123;        &#x27;host&#x27;: &#x27;192.168.1.1&#x27;,        &#x27;port&#x27;: 5432,        &#x27;username&#x27;: &#x27;admin&#x27;,        &#x27;password&#x27;: &#x27;securepass&#x27;    &#125;,    &#x27;cache&#x27;: &#123;        &#x27;host&#x27;: &#x27;10.0.0.1&#x27;,        &#x27;port&#x27;: 27017,        &#x27;username&#x27;: &#x27;cacheuser&#x27;,        &#x27;password&#x27;: &#x27;cachepass&#x27;    &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n这样做的好处：所有配置信息都在一个地方，便于统一管理和维护；易于修改 ;配置变更不需要修改业务逻辑代码\n工厂模式的核心就是工厂函数,工厂函数是一个返回对象的函数(而不是类），它封装了对象的创建逻辑，根据输入参数决定返回哪种具体对象。\n建造模式解决问题：对象很复杂，参数很多，构造过程有顺序，不同配置组合很多。\n 建造者模式通过 “分步构建 + 最终组装” 的方式，让创建过程清晰、灵活、可读性强。\nclass DatabaseConnectionBuilder:    &quot;&quot;&quot;数据库连接建造者类&quot;&quot;&quot;        def __init__(self,host,port,username,password):        self._config = &#123;            &#x27;host&#x27;: host,            &#x27;port&#x27;: port,            &#x27;username&#x27;: username,            &#x27;password&#x27;: password,        &#125;            def set_max_connections(self, max_connections):        &quot;&quot;&quot;设置最大连接数&quot;&quot;&quot;        if max_connections is not None and max_connections &lt;= 0:            raise ValueError(&quot;Max connections must be positive&quot;)        self._config[&#x27;max_connections&#x27;] = max_connections        return self        def set_timeout(self, timeout):        &quot;&quot;&quot;设置超时时间&quot;&quot;&quot;        if timeout is not None and timeout &lt;= 0:            raise ValueError(&quot;Connect timeout must be positive&quot;)        self._config[&#x27;timeout&#x27;] = timeout        return self            def build(self):        &quot;&quot;&quot;构建最终的数据库连接对象&quot;&quot;&quot;          return DatabaseConnection(**self._config)                # 演示建造者模式的使用if __name__ == &quot;__main__&quot;:    # 创建一个数据库连接建造者    builder = DatabaseConnectionBuilder(        host=&#x27;localhost&#x27;,        port=3306,        username=&#x27;root&#x27;,        password=&#x27;password123&#x27;    )        # 使用建造者模式构建数据库连接    connection = builder.set_max_connections(100) \\                        .set_timeout(30) \\                        .enable_ssl() \\                        .set_connection_pool(&#x27;my_pool&#x27;) \\                        .set_retry_attempts(3) \\                        .enable_compression() \\                        .set_read_preference(&#x27;secondaryPreferred&#x27;) \\                        .build()\n\n单例模式解决问题：单例模式确保一个类只有一个实例，并提供一个全局访问点来获取该实例。不管调用多少次创建对象，始终返回的是同一对象。\nclass DatabaseConnection:    &quot;&quot;&quot;数据库连接单例类&quot;&quot;&quot;        _instance = None    _lock = threading.Lock()  # 线程锁，确保线程安全        def __new__(cls, *args, **kwargs):        &quot;&quot;&quot;重写__new__方法实现单例模式&quot;&quot;&quot;        if cls._instance is None:            with cls._lock:  # 使用双重检查锁定                if cls._instance is None:                    cls._instance = super().__new__(cls)        return cls._instance        def __init__(self, host, port, username, password):        &quot;&quot;&quot;初始化数据库连接参数&quot;&quot;&quot;        # 防止重复初始化        if hasattr(self, &#x27;_initialized&#x27;):            return                self.host = host        self.port = port        self.username = username        self.password = password        self._initialized = True        def connect(self):        &quot;&quot;&quot;连接数据库&quot;&quot;&quot;        return f&quot;Connecting to database at &#123;self.host&#125;:&#123;self.port&#125; with username &#x27;&#123;self.username&#125;&#x27;&quot;def client():    db1 = DatabaseConnection(host=&#x27;localhost&#x27;, port=3306, username=&#x27;root&#x27;, password=&#x27;password&#x27;)    db2 = DatabaseConnection(host=&#x27;localhost&#x27;, port=3306, username=&#x27;root&#x27;, password=&#x27;password&#x27;)    print(db1 is db2)client()\n","categories":["python"],"tags":["python"]},{"title":"魔方方法","url":"//post/%E9%AD%94%E6%96%B9%E6%96%B9%E6%B3%95.html","content":"魔方方法什么是魔方方法Python 的魔法方法是以双下划线命名的特殊方法，它们定义了对象在 Python 语法下的行为， 让自定义对象能够像内置类型一样使用。\n当使用像 +、len()、str()、in、[] 等语法时，Python 其实是在背后调用对应的魔法方法。\n常见魔法方法举例__init__：初始化对象class Person:    def __init__(self, name):        self.name = namep = Person(&quot;Alice&quot;)  # 调用 __init__\n\n__str__ 和 __repr__：控制对象的字符串表示\n__str__ 用于 str(obj) 或 print(obj)，面向用户。\n__repr__ 用于调试，面向开发者，通常返回可执行的代码字符串。\n\nclass Point:    def __init__(self, x, y):        self.x = x        self.y = y    def __str__(self):        return f&quot;Point(&#123;self.x&#125;, &#123;self.y&#125;)&quot;    def __repr__(self):        return f&quot;Point(x=&#123;self.x&#125;, y=&#123;self.y&#125;)&quot;p = Point(1, 2)print(p)        # Point(1, 2) ← 调用 __str__print(repr(p))  # Point(x=1, y=2) ← 调用 __repr__\n\n__len__：支持 len(obj)class MyList:    def __init__(self, items):        self.items = items    def __len__(self):        return len(self.items)my_list = MyList([1, 2, 3])print(len(my_list))  # 3\n\n__getitem__ &#x2F; __setitem__：支持 obj[key] 和 obj[key] = valueclass Vector:    def __init__(self, data):        self.data = data    def __getitem__(self, index):        return self.data[index]    def __setitem__(self, index, value):        self.data[index] = valuev = Vector([10, 20, 30])print(v[1])      # 20v[1] = 99print(v[1])      # 99\n\n__add__：支持 + 运算符class Vector:    def __init__(self, x, y):        self.x = x        self.y = y    def __add__(self, other):        return Vector(self.x + other.x, self.y + other.y)    def __repr__(self):        return f&quot;Vector(&#123;self.x&#125;, &#123;self.y&#125;)&quot;v1 = Vector(1, 2)v2 = Vector(3, 4)print(v1 + v2)  # Vector(4, 6)\n\n__eq__：支持 == 比较class Book:    def __init__(self, title):        self.title = title    def __eq__(self, other):        return self.title == other.titleb1 = Book(&quot;Python&quot;)b2 = Book(&quot;Python&quot;)print(b1 == b2)  # True\n\n__call__：让对象像函数一样被调用class Multiplier:    def __init__(self, factor):        self.factor = factor    def __call__(self, x):        return x * self.factordouble = Multiplier(2)print(double(5))  # 10\n\n参考资料【Python 特性】魔法方法：让你的类和原生类一样顺滑_哔哩哔哩_bilibili\n","categories":["python"],"tags":["python"]}]